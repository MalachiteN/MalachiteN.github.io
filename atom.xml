<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://malachiten.github.io</id>
    <title>Malachite</title>
    <updated>2019-10-22T05:52:35.018Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://malachiten.github.io"/>
    <link rel="self" href="https://malachiten.github.io/atom.xml"/>
    <subtitle>夕焼けの中に吸い込まれて消えてった</subtitle>
    <logo>https://malachiten.github.io/images/avatar.png</logo>
    <icon>https://malachiten.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Malachite</rights>
    <entry>
        <title type="html"><![CDATA[Screeps 教程]]></title>
        <id>https://malachiten.github.io/post/screeps-jiao-cheng</id>
        <link href="https://malachiten.github.io/post/screeps-jiao-cheng">
        </link>
        <updated>2019-10-22T01:12:35.000Z</updated>
        <content type="html"><![CDATA[<p>不了解的人可以前往<a href="https://screeps.com/">Screeps官网</a>了解一下，也许我们能成为同一个<code>Shard</code>的邻居。</p>
<p>不过，看完简介也不要贸然在Steam购买，我打教程都打了不止一整天，肯定是退不了款的。在真正接触到本身之前，也不会知道它到底怎样玩。不过，在官网上有它的 Live DEMO 可供试玩，建议尝试。</p>
<h2 id="让我们开始吧界面简介">让我们开始吧：界面简介</h2>
<blockquote>
<p>Let's begin. This is a playing field called a &quot;room&quot;. In the real game, rooms are connected to each other with exits, but in the simulation mode only one room is available to you.</p>
</blockquote>
<p>屏幕中间的一大片叫做<code>room</code>，在实际游戏中，它与其他房间相连，但是在教程这里，它仅对你开放。</p>
<blockquote>
<p>The object in the center of the screen is your first spawn, your colony center.</p>
</blockquote>
<p>屏幕中间的物体是你的<code>creep</code>们的生成器。</p>
<blockquote>
<p>You play by writing code in the panel in the bottom of the screen.</p>
</blockquote>
<p>你要操作这个游戏，就得在屏幕下方的黑框框里面打代码，嘿嘿嘿。</p>
<blockquote>
<p>You can see all the characteristics of your creep (or other objects) by utilizing the &quot;View&quot; action.</p>
</blockquote>
<p>你要想看到你的所有物体的信息，需要切换到<code>View</code>视图。具体一点，点击屏幕上方的眼睛<br>
图标就可以了。</p>
<blockquote>
<p>Hide the editor panel with Alt+Enter and select your creep with the help of the &quot;View&quot; action.</p>
</blockquote>
<p>当你需要查看信息时，按下<code>Alt+Enter</code>隐藏编辑器，然后点击目标。</p>
<blockquote>
<p>Here you can see the characteristics of the object you are now looking at. Values of each characteristic and functions of body parts are described in the documentation.</p>
</blockquote>
<p>这样，在屏幕右侧工具栏中，你就能看见所选目标的全部属性。</p>
<h2 id="第一个要接触的东西控制台">第一个要接触的东西：控制台</h2>
<p><code>Console</code> 控制台 其实是一个<code>JavaScript</code>的 <strong>REPL</strong> (读入 - 执行 - 打印 - 循环) 。</p>
<p>输入一行或一块<code>JavaScript</code>语句，然后按下<code>Enter</code>执行。</p>
<blockquote>
<p>Your command returns a response <s>or execution error</s> in the console below. All output is duplicated into your browser console (Ctrl+Shift+J) where you can expand objects for debugging purposes. You can open and close the bottom panel by pressing Alt+Enter.</p>
</blockquote>
<p>你的命令返回一个结果或一个错误，将立即显示在控制台。</p>
<blockquote>
<p>It is time to put the creep to work! This yellow square is an energy source — a valuable game resource. It can be harvested by creeps with one or more WORK body parts and transported to the spawn by creeps with CARRY parts.</p>
</blockquote>
<p>下面测试下控制台，在控制台中生成一个具有<code>WORK</code>,<code>CARRY</code>,<code>MOVE</code> 的身体部件的 Creep 。</p>
<p>其实这使用了 API ：</p>
<blockquote>
<p>Game.spawns<br>
StructureSpawn.spawnCreep</p>
</blockquote>
<pre><code class="language-javascript">Game.spawns['Spawn1'].spawnCreep( [WORK, CARRY, MOVE], 'Harvester1' );
</code></pre>
<p>这就是我们的第一个<code>Creep</code>，可见，它是由名为<code>Spawn1</code>的生成器生成的，，且名为<code>Harvester1</code>。</p>
<blockquote>
<p>You can address your spawn by its name the following way: Game.spawns['Spawn1'].</p>
</blockquote>
<p>这就是生成器的路径：<code>Game.spawns['Spawn1']</code>。</p>
<blockquote>
<p>Great! You now have a creep with the name &quot;Harvester1&quot; that you can control.</p>
</blockquote>
<h2 id="然后就是最重要的脚本中的-main-模块">然后就是最重要的，脚本中的 Main 模块</h2>
<blockquote>
<p>To give your creep a permanently working command, the console is not enough, since we want the creep to work all the time. So we'll be using the Script tab rather than the console.</p>
</blockquote>
<p>控制台不能满足我们给<code>creep</code>编写工作脚本的需求。我们需要使用脚本编辑器来编写这些脚本。</p>
<blockquote>
<p>Here you can write scripts that will run on a permanent basis, each game tick in a loop. It allows writing constantly working programs to control behaviour of your creeps which will work even while you are offline (in the real game only, not the Simulation Room mode).</p>
</blockquote>
<p>只要你写了脚本，它就会一直循环执行，每<code>Tick</code>一次，即使你离线，也是如此，除非你的<strong>所有</strong>据点都被人炸没了。值得一提，<code>Tick</code>是游戏的时间单位，具体长度由服务器性能及建立据点的玩家数目决定。Screeps一共包含四个服务器，越老的服务器运行速度越慢。最老的服务器<code>shard0</code>的平均ticks时长甚至达到了惊人的5.9秒。也就是说，每过5.9秒。你的代码才会被运行一次。玩家越来越不满缓慢的游戏速度，甚至决定到其他服务器从头开始。</p>
<blockquote>
<p>To commit a script to the game so it can run, use this button or Ctrl+Enter.</p>
</blockquote>
<p>按下<code>Ctrl + Enter</code>提交你的代码。跟发个 QQ 消息一样简单。</p>
<blockquote>
<p>To send a creep to harvest energy, you need to use the methods described in the documentation section below. Commands will be passed each game tick. The harvest method requires that the energy source is adjacent to the creep.</p>
</blockquote>
<p>为了让一个<code>creep</code>收集能量，你需要学习官方 API 文档中定义的方法。执行这些方法，以让它们工作。</p>
<blockquote>
<p>You give orders to a creep by its name this way: Game.creeps['Harvester1']. Use the FIND_SOURCES constant as an argument to the Room.find method.</p>
</blockquote>
<p>具体来说，在收集资源时，需要用到<code>Game.creeps[]</code>数组、将常数<code>FIND_SOURCES</code>作为参数的方法<code>Room.find()</code>。</p>
<p>这次使用的 API 如下，可以在官方文档中查到：</p>
<blockquote>
<p>Game.creeps<br>
RoomObject.room<br>
Room.find<br>
Creep.moveTo<br>
Creep.harvest</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">module.exports.loop = function () {
    var creep = Game.creeps['Harvester1'];
    var sources = creep.room.find(FIND_SOURCES);
    if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
        creep.moveTo(sources[0]);
    }
}
</code></pre>
<p>这时你的唯一一个<code>Creep</code>会向地图上最近的黄点移动，然后开始工作。这个黄点称为<code>Source</code>，即能量源。</p>
<blockquote>
<p>A bubbling yellow spot inside the creep means that it has started collecting energy from the source.</p>
</blockquote>
<p>如果一个<code>Creep</code>内部的颜色变成亮黄色，则说明它正在收集能量源中的能量。</p>
<p><strong>It works!</strong></p>
<p>可是，当其收集满自身容量之后，就需要返回出生点 (即<code>Creep</code>的生成器，<code>Spawn</code>) 。</p>
<blockquote>
<p>To make the creep transfer energy back to the spawn, you need to use the method Creep.transfer. However, remember that it should be done when the creep is next to the spawn, so the creep needs to walk back.</p>
</blockquote>
<p>使用 API 提供的方法<code>Creep.transfer</code>来达成这个任务。</p>
<blockquote>
<p>If you modify the code by adding the check .carry.energy &lt; .carryCapacity to the creep, it will be able to go back and forth on its own, giving energy to the spawn and returning to the source.</p>
</blockquote>
<p>这是算法的实现方法：简单判断目标<code>Creep</code>的携带能量是否小于其最大容量。如果小于，则一直让它收集。否则，令其返回<code>Spawn</code>，将能量注入其中。</p>
<p>要实现这些，可参见 API 文档：</p>
<blockquote>
<p>Creep.transfer<br>
Creep.carry<br>
Creep.carryCapacity</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">module.exports.loop = function () {
    var creep = Game.creeps['Harvester1'];

    if(creep.carry.energy &lt; creep.carryCapacity) {
        var sources = creep.room.find(FIND_SOURCES);
        if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
            creep.moveTo(sources[0]);
        }
    }
    else {
        if( creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE ) {
            creep.moveTo(Game.spawns['Spawn1']);
        }
    }
}
</code></pre>
<blockquote>
<p>Great! This creep will now work as a harvester until it dies. Remember that almost any creep has a life cycle of 1500 game ticks, then it &quot;ages&quot; and dies (this behavior is disabled in the Tutorial).</p>
</blockquote>
<p>这样就完成了让它一直收集能量直到死亡的规划。</p>
<p>值得一提的是，每个<code>Creep</code>在出生时均具备 1500 个<code>Ticks</code>的生命时长，之后逐步减少。不过，这个行为在教程中被禁用了，目前你的<code>Creep</code>具有无限寿命。</p>
<blockquote>
<p>Let's create another worker creep to help the first one. It will cost another 200 energy units, so you may need to wait until your harvester collects enough energy. The spawnCreep method will return an error code ERR_NOT_ENOUGH_ENERGY (-6) until then.</p>
</blockquote>
<p>我们马上就要建造另一个工人<code>Creep</code>来帮助减轻第一个的负担了。这会消耗 200 个之前的工人收集来的能量单位，所以你需要等待你的收集者收集足够的能量。在 API 中提供的<code>spawnCreep</code>方法在没有足够能量的时候，不会生成<code>Creep</code>，而是返回一个错误常量<code>ERR_NOT_ENOUGH_ENERGY</code>。值得一提的是，它的值为 -6 。</p>
<blockquote>
<p>Remember: to execute code once just type it in the &quot;Console&quot; tab.</p>
</blockquote>
<p>像这种只需要执行一次的命令，可以只用将其输入到控制台。</p>
<p>那么具体的指令就很简单了：</p>
<pre><code class="language-javascript">Game.spawns['Spawn1'].spawnCreep( [WORK, CARRY, MOVE], 'Harvester2' );
</code></pre>
<blockquote>
<p>The second creep is ready, but it won't move until we include it into the program.</p>
</blockquote>
<p>由于我们根本没写它的脚本，所以它暂时还不会动。</p>
<blockquote>
<p>To set the behavior of both creeps we could just duplicate the entire script for the second one, but it's much better to use the for loop against all the screeps in Game.creeps.</p>
</blockquote>
<p>我们可以单独为它编写脚本，但是我们注意到它的脚本和第一个几乎没有差别。为了<s>偷懒</s>提高代码复用率，我们可以使用循环来解决这个问题。</p>
<p>Code:</p>
<pre><code class="language-javascript">module.exports.loop = function () {
    for(var name in Game.creeps) {
        var creep = Game.creeps[name];

        if(creep.carry.energy &lt; creep.carryCapacity) {
            var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0]);
            }
        }
        else {
            if(creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                creep.moveTo(Game.spawns['Spawn1']);
            }
        }
    }
}
</code></pre>
<h2 id="为了更加极致的脱发体验我们还可以编写其他模块达成目的">为了更加极致的脱发体验，我们还可以编写其他模块达成目的。</h2>
<blockquote>
<p>Now let's improve our code by taking the workers' behavior out into a separate module. Create a module called role.harvester with the help of the Modules section on the left of the script editor and define a run function inside the module.exports object, containing the creep behavior.</p>
</blockquote>
<p>除了<code>Main</code>之外的模块就像 C / C++ 中的头文件，供给<code>Main</code>调用。我们可以使用这个特性，编写一个专们描述收集能量的工人<code>Creep</code>的行为的模块。</p>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = {

    /** @param {Creep} creep **/
    run: function(creep) {
	    if(creep.carry.energy &lt; creep.carryCapacity) {
            var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0]);
            }
        }
        else {
            if(creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                creep.moveTo(Game.spawns['Spawn1']);
            }
        }
	}
};

module.exports = roleHarvester;
</code></pre>
<p>这份脚本描述了所有具有<code>Harvester</code>性质的<code>Creep</code>的工作流程，此处不再赘述。</p>
<p>那么现在，我们如何编写我们的<code>Main</code>来调用刚刚写的这些呢？</p>
<blockquote>
<p>Now you can rewrite the main module code, leaving only the loop and a call to your new module by the method require('role.harvester').</p>
</blockquote>
<p>明显，只需要使用<code>require('role.harvester')</code>的语句，就可以达成与 C / C++ 中<code>#include &quot;role_harvester.hpp&quot;</code>一样的效果了。</p>
<blockquote>
<p>It's much better now!</p>
</blockquote>
<p>头发少多了！</p>
<blockquote>
<p>By adding new roles and modules to your creeps this way, you can control and manage the work of many creeps. In the next Tutorial section, we’ll develop a new creep role.</p>
</blockquote>
<p>通过给你的<code>creep</code>们添加新的角色和模块，你能控制并管理大量的<code>creeps</code>。下一步，我们要开发一个新的角色。</p>
<h2 id="升级房间控制器roomcontroller">升级房间控制器RoomController</h2>
<blockquote>
<p>In this Tutorial section we’ll talk about a key strategic object in your room: Room Controller. By controlling this invincible structure you can build facilities in the room. The higher the controller level, the more structures available to build.</p>
</blockquote>
<p>在设计这个新的角色之前，我们需要认识一个新东西，叫<code>Room Controller</code>。这个东西的等级决定了你能在你房间里面建造哪些结构。</p>
<blockquote>
<p>You will need a new worker creep to upgrade your controller level. Let's call it &quot;Upgrader1&quot;. In following sections we'll discuss how to create creeps automatically, but for now let's send a command manually to the console.</p>
</blockquote>
<p>为了给它升级，我们要造一个名为“Upgrader1”的新工人。</p>
<p>在以后的教程中我们会认识到如何自动生成<code>creeps</code>，不过这次，我们还是使用控制台吧。</p>
<p>Code:</p>
<pre><code class="language-javascript">Game.spawns['Spawn1'].spawnCreep( [WORK, CARRY, MOVE], 'Upgrader1' );
</code></pre>
<p>它具体生成了什么，想必不用多说了。</p>
<blockquote>
<p>Creep &quot;Upgrader1&quot; went to perform the same task as the harvester, but we don't want it to. We need to differentiate creep roles.</p>
</blockquote>
<p>目前它暂时还只能像<code>harvester</code>一样工作。不过，我们得干点什么让它与老前辈不一样。</p>
<blockquote>
<p>To do that, we need to utilize the memory property of each creep that allows writing custom information into the creep's &quot;memory&quot;. Let's do this to assign different roles to our creeps.</p>
<p>All your stored memory is accessible via the global Memory object. You can use it any way you like.</p>
</blockquote>
<p>我们使用<code>memory</code>来区分不同<code>creeps</code>各自的角色。实际上，我们可以往一个<code>creep</code>的“记忆”里面写任何东西来达成我们的任意目的。</p>
<p>Code:</p>
<pre><code class="language-javascript"> Game.creeps['Harvester1'].memory.role = 'harvester';
 Game.creeps['Upgrader1'].memory.role = 'upgrader';
</code></pre>
<blockquote>
<p>You can check your creeps' memory in either the creep information panel on the left or on the &quot;Memory&quot; tab.</p>
</blockquote>
<p>通过检查<code>Memory</code>面板，你可以确认“你的<code>Creeps</code>有没有深入贯彻你的思想”。</p>
<blockquote>
<p>Now let's define the behavior of the new creep. Both creeps should harvest energy, but the creep with the role harvester should bring it to the spawn, while the creep with the role upgrader should go to the Controller and apply the function upgradeController to it (you can get the Controller object with the help of the Creep.room.controller property).</p>
</blockquote>
<p>现在开工了，去设计新<code>creep</code>的行为。每一个<code>creep</code>都应当收集能量，但是<code>harvester</code>应该把能量送到<code>spawn</code>，而<code>upgrader</code>应该把能量送去<code>Room Controller</code>。</p>
<blockquote>
<p>In order to do this, we’ll create a new module called role.upgrader.</p>
</blockquote>
<p>为此，我们应当创建一个名为<code>role.upgrader</code>的<code>module</code>。</p>
<p>这用到了这些 API ：</p>
<blockquote>
<p>RoomObject.room<br>
Room.controller<br>
Creep.upgradeController</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleUpgrader = {

    /** @param {Creep} creep **/
    run: function(creep) {
	    if(creep.carry.energy == 0) {
            var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0]);
            }
        }
        else {
            if(creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {
                creep.moveTo(creep.room.controller);
            }
        }
	}
};

module.exports = roleUpgrader;
</code></pre>
<blockquote>
<p>In our main module, all creeps run the same role. We need to divide their behavior depending on the previously defined property Creep.memory.role by connecting the new module.</p>
</blockquote>
<p>目前我们的<code>main</code>模块中，所有<code>creeps</code>还被当作同一种角色处理。这是不行的：如果<code>main</code>说是一样的就是一样的，那我多没面子。所以</p>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleUpgrader = require('role.upgrader');

module.exports.loop = function () {

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
    }
}
</code></pre>
<p>听我的！听我的！听我的！</p>
<p>所以——</p>
<blockquote>
<p>Perfect, you have upgraded your Controller level!</p>
</blockquote>
<p><code>WA</code>，你的头发又少了几根！</p>
<blockquote>
<p><strong>Important</strong>: If you don’t upgrade your Controller within 20,000 game ticks, it loses one level. On reaching level 0, you will lose control over the room, and another player will be able to capture it freely. Make sure that at least one of your creeps regularly performs the function upgradeController.</p>
</blockquote>
<p>很重要的一点：如果你连续两万个<code>tick</code>不升级你的<code>Room Controller</code>，它就会降级。当它降到 0 级时，你就失去了这个房间的控制权。</p>
<h2 id="建造新结构">建造新结构</h2>
<blockquote>
<p>The Controller upgrade gives access to some new structures: walls, ramparts, and extensions. We’ll discuss walls and ramparts in the next Tutorial section, for now let’s talk about extensions.</p>
</blockquote>
<p>控制器一旦被升级，你就可以获取建造新结构的权限。这些结构主要有：地形墙、防御壁垒，以及扩展。我们教程的下一步会讲到地形墙和城墙，这次只会讲到扩展。</p>
<blockquote>
<p><strong>Extensions</strong> are required to build larger creeps. A creep with only one body part of one type works poorly. Giving it several <strong>WORKs</strong> will make him work proportionally faster.</p>
</blockquote>
<p>当你觉得你的<code>creeps</code>工作能力不行的时候，你想要往你的<code>creeps</code>身上插更多的身体部件。给他更强的工作能力。</p>
<blockquote>
<p>However, such a creep will be costly and a lone spawn can only contain 300 energy units. To build creeps costing over 300 energy units you need spawn extensions.</p>
</blockquote>
<p>可是，这样的<code>creeps</code>势必造成建造花费的提高。你的<code>spawn</code>只能容纳 300 单位的能量，是远远不够的。建造花费高于 300 单位能量的 <code>creeps</code>，就需要使用扩展。</p>
<blockquote>
<p>The second Controller level has 5 extensions available for you to build.This number increases with each new level.</p>
</blockquote>
<p>控制器等级 2 允许你建造 5 个扩展。而且这个数量还会随<code>Room Controller</code>等级不断提升。</p>
<blockquote>
<p>You can place extensions at any spot in your room, and a spawn can use them regardless of the distance. In this Tutorial we have already placed corresponding construction sites for your convenience.</p>
</blockquote>
<p>你可以将扩展放在房间的任何位置，而且一个<code>spawn</code>可以在任何距离使用它们。在教程中，我们已经将其放置在构造好的位置上。</p>
<blockquote>
<p>Let’s create a new creep whose purpose is to build structures. This process will be similar to the previous Tutorial sections. But this time let’s set <code>memory</code> for the new creep right in the method <code>Spawn.spawnCreep</code> by passing it in the third argument.</p>
</blockquote>
<p>我们建造一种新类型的<code>creep</code>来干这事。这种事情非常简单，我们之前都做得多了。不过，这次我们试试新的写法：使用第三个参数来传递内存值，免去重新设置内存的麻烦。</p>
<p>Code:</p>
<pre><code class="language-javascript">Game.spawns['Spawn1'].spawnCreep( [WORK, CARRY, MOVE], 'Builder1',
    { memory: { role: 'builder' } } );
</code></pre>
<p>在<code>builder</code>的定义未声明时，它将不会移动。</p>
<blockquote>
<p>As before, let’s move this role into a separate module role.builder. The building is carried out by applying the method <code>Creep.build</code> to the construction sites searchable by <code>Room.find(FIND_CONSTRUCTION_SITES)</code>. The structure requires energy which your creep can harvest on its own.</p>
</blockquote>
<p>像之前一样，我们需要设计一个新<code>module</code>。</p>
<p><code>Creep.build</code>和<code>Room.find(FIND_CONSTRUCTION_SITES)</code>两个方法可以帮到我们。</p>
<blockquote>
<p>To avoid having the creep run back and forth too often but make it deplete the cargo, let’s complicate our logic by creating a new Boolean variable <code>creep.memory.building</code> which will tell the creep when to switch tasks. We'll also add new <code>creep.say</code> call and <code>visualizePathStyle</code> option to the moveTo method to visualize the creep's intentions.</p>
</blockquote>
<p>为了避免它来回频繁运行耗尽计算资源，我们设计一个布尔值<code>creep.memory.building</code>来控制它究竟是挖矿还是建造。同时，我们打开可视化其移动路径的选项，并使用<code>creep.say</code>方法，来使它所处的模式可视化。</p>
<p>这次用到了这些 API :</p>
<blockquote>
<p>RoomObject.room<br>
Room.find<br>
Creep.build<br>
Creep.say</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleBuilder = {

    /** @param {Creep} creep **/
    run: function(creep) {

	    if(creep.memory.building &amp;&amp; creep.carry.energy == 0) {
            creep.memory.building = false;
            creep.say('🔄 harvest');
	    }
	    if(!creep.memory.building &amp;&amp; creep.carry.energy == creep.carryCapacity) {
	        creep.memory.building = true;
	        creep.say('🚧 build');
	    }

	    if(creep.memory.building) {
	        var targets = creep.room.find(FIND_CONSTRUCTION_SITES);
            if(targets.length) {
                if(creep.build(targets[0]) == ERR_NOT_IN_RANGE) {
                    creep.moveTo(targets[0], {visualizePathStyle: {stroke: '#ffffff'}});
                }
            }
	    }
	    else {
	        var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0], {visualizePathStyle: {stroke: '#ffaa00'}});
            }
	    }
	}
};

module.exports = roleBuilder;
</code></pre>
<blockquote>
<p>Let’s create a call of the new role in the main module and wait for the result.</p>
</blockquote>
<p>这样就可以了。不过我们还得改改主模块<code>Main</code></p>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleBuilder = require('role.builder');

module.exports.loop = function () {

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'builder') {
            roleBuilder.run(creep);
        }
    }
}
</code></pre>
<blockquote>
<p>Your extensions have been built. Now let’s learn to work with them.</p>
</blockquote>
<p>这样一来，扩展就修建好了。那么现在怎么让它们工作呢？</p>
<blockquote>
<p>Maintaining extensions requires you to teach your harvesters to carry energy not just to a spawn but also to extensions. To do this, you can either use the <code>Game.structures</code> object or search within the room with the help of <code>Room.find(FIND_STRUCTURES)</code>. In both cases, you will need to filter the list of items on the condition structure.<code>structureType == STRUCTURE_EXTENSION</code> (or, alternatively, <code>structure instanceof StructureExtension</code>) and also check them for energy load, as before.</p>
</blockquote>
<p>先要教会<code>havester</code>将收集的资源注入扩展。否则这些扩展用处不大。</p>
<p>所用 API：</p>
<blockquote>
<p>Game.structures<br>
Room.find<br>
StructureExtension</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = {

    /** @param {Creep} creep **/
    run: function(creep) {
	    if(creep.carry.energy &lt; creep.carryCapacity) {
            var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0], {visualizePathStyle: {stroke: '#ffaa00'}});
            }
        }
        else {
            var targets = creep.room.find(FIND_STRUCTURES, {
                    filter: (structure) =&gt; {
                        return (structure.structureType == STRUCTURE_EXTENSION || structure.structureType == STRUCTURE_SPAWN) &amp;&amp;
                            structure.energy &lt; structure.energyCapacity;
                    }
            });
            if(targets.length &gt; 0) {
                if(creep.transfer(targets[0], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                    creep.moveTo(targets[0], {visualizePathStyle: {stroke: '#ffffff'}});
                }
            }
        }
	}
};

module.exports = roleHarvester;
</code></pre>
<blockquote>
<p>To know the total amount of energy in the room, you can use the property <code>Room.energyAvailable</code>. Let’s add the output of this property into the console in order to track it during the filling of extensions.</p>
</blockquote>
<p>同时，为了得知房间能源总数，我们需要使用方法<code>Room.energyAvailable</code>，在<code>Main</code>中添加一个输出，让系统输出总能源信息到控制台。</p>
<p>可能用到的 API 文档是：</p>
<blockquote>
<p>Room.energyAvailable</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleBuilder = require('role.builder');

module.exports.loop = function () {

    for(var name in Game.rooms) {
        console.log('Room &quot;'+name+'&quot; has '+Game.rooms[name].energyAvailable+' energy');
    }

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'builder') {
            roleBuilder.run(creep);
        }
    }
}
</code></pre>
<blockquote>
<p>In total, we have 550 energy units in our spawn and extensions. It is enough to build a creep with the body [WORK,WORK,WORK,WORK,CARRY,MOVE,MOVE]. This creep will work 4 times faster than a regular worker creep. Its body is heavier, so we’ll add another MOVE to it. However, two parts are still not enough to move it at the speed of a small fast creep which would require 4xMOVEs or building a road.</p>
</blockquote>
<p>准备好造个大家伙了吗？具体有多大，见英文部分。（笑）</p>
<blockquote>
<p>Building this creep took energy from all storages and completely drained them.</p>
</blockquote>
<p>为了侍候这个大家伙，我们的所有能量存储器都耗尽了。</p>
<blockquote>
<p>As you can see on the right panel, this powerful creep harvests 8 energy units per tick. A few such creeps can completely drain an energy source before it refills thus giving your colony a maximum energy boost.</p>
</blockquote>
<p>不过当你看到它的面板时，你会觉得这是非常值得的。它能够在 1 <code>Tick</code> 中采集 8 单位能量，给予你极大的能源支持。</p>
<blockquote>
<p>Hence, by upgrading your Controller, constructing new extensions and more powerful creeps, you considerably improve the effectiveness of your colony work. Also, by replacing a lot of small creeps with fewer large ones, you save CPU resources on controlling them which is an important prerequisite to play in the online mode.</p>
</blockquote>
<p>可见，升级控制器，建造新扩展和更多强大的<code>Creeps</code>，能够提高工作效率，节省下CPU时间。值得一提，为了避免有玩家使用死循环卡系统，对于每一个玩家的代码，系统都有一个CPU时间限制，如果你的程序运行超出了CPU时间，则会被强制打断，<code>continue</code>到下一次循环中。当然，购买订阅甚至终身无限CPU时间的巨佬可以无视CPU时间限制。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 最小生成树 / Kruskal算法]]></title>
        <id>https://malachiten.github.io/post/bi-ji-zui-xiao-sheng-cheng-shu-kruskal-suan-fa</id>
        <link href="https://malachiten.github.io/post/bi-ji-zui-xiao-sheng-cheng-shu-kruskal-suan-fa">
        </link>
        <updated>2019-10-08T07:10:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="最小生成树是什么">最小生成树是什么</h2>
<p>对于一个这样的连通图：</p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/10/08/ufgOiR.png" alt="graphFull.png"></figure>
<p>表格形式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">起点</th>
<th style="text-align:center">终点</th>
<th style="text-align:center">权值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">9</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">10</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">11</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">7</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
<p>它的极小连通子图，可以表现为一棵树的形式，即为最小生成树(如下图所示)。</p>
<figure data-type="image" tabindex="2"><img src="https://s2.ax1x.com/2019/10/08/uf2tyT.png" alt="graphMini.png"></figure>
<p>看不出这是一棵树？看这个。</p>
<figure data-type="image" tabindex="3"><img src="https://s2.ax1x.com/2019/10/08/ufRjKK.png" alt="trueTree.png"></figure>
<p>表格形式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">起点</th>
<th style="text-align:center">终点</th>
<th style="text-align:center">权值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">9</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<p><s>看，是不是特别小？</s></p>
<p><s>你说是，就是吧</s></p>
<h2 id="我们怎么生成一个最小生成树呢">我们怎么生成一个最小生成树呢？</h2>
<p>此时，我们可以采用多种算法。</p>
<p>其中较好理解的是 <em>Kruskal</em> 算法。</p>
<h3 id="kruskal算法">Kruskal算法</h3>
<p>这种算法的核心是，先建立一个结构体<code>Edge</code>用来描述边：</p>
<pre><code class="language-cpp">struct Edge{
    int u,v,w;
    Edge(){}//数组用默认构造函数
    Edge(int t1,int t2,int t3){
        u=t1;
        v=t2;
        w=t3;
    }
    bool operator &lt; (const Edge &amp;other) const{
        return w&lt;other.w;
    }
}edges[10005];
</code></pre>
<p>其中的<code>u</code>代表了这条边的起点，<code>v</code>代表了这条边的终点，<code>w</code>代表的则是这条边的边权。<strong>重载构造函数是为了以后存边方便</strong>，而<strong>重载运算符则是为了边权排序方便</strong>。数组就是边的<strong>实例</strong>，用来进行存储。</p>
<p>我们通过<strong>并查集连边</strong>的方式，将所有的顶点<strong>依权值次序</strong>相连。所以，我们需要实现一个并查集：</p>
<pre><code class="language-cpp">int fa[10005];//集
int find(int x){//查
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
bool merge(int x,int y){//并
    int a=find(x),b=find(y);
    if(a!=b){
        fa[a]=b;
        return 1;//成功，记录
    }else{
        return 0;//失败，放弃
    }
}
</code></pre>
<p>这里可能产生疑问：并查集实现中的<code>merge</code>函数不应该只是个像这样的<code>void</code>类型的“存储过程”吗？</p>
<pre><code class="language-cpp">void merge(int x,int y){
    fa[find(x)]=find(y);
}
</code></pre>
<p>为什么要给一个<code>bool</code>类型的返回值呢？</p>
<p>原因就在于之后的处理当中，纯粹贪心地连接<strong>权值最小</strong>的边，会发生“连接出<strong>环</strong>”的情况。明显可以看出：</p>
<blockquote>
<p>出现有环的图不成为树。</p>
</blockquote>
<p>为了避免这种情况的发生，我们需要检查即将连接的这一条边的两个顶点<strong>是否已经被连接在一个并查集中</strong>。此处<code>merge</code>函数的这种写法，就实现了<strong>判断是否已经连接</strong>和<strong>告知程序主体部分连接状况</strong>的功能。显而易见，返回0代表<strong>已经连过了</strong>，本次连接失败，需要跳下一条边；返回1表示<strong>之前没有连接过</strong>，现在连边成功。</p>
<p>那么我们可以得出我们的主函数:</p>
<pre><code class="language-cpp">int main(){
    int n/*边数*/,m/*点数*/;
    cin&gt;&gt;n&gt;&gt;m;//初始化
    //存边
    for(int i=1;i&lt;=n;i++){
        int t1,t2,t3;
        cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;
        edges[i]=Edge(t1,t2,t3);
    }
    //排序
    sort(edges+1,edges+n+1);
    //生成树
    for(int i=1;i&lt;=m-1;i++){
        if(!merge(edges[i].u,edges[i].v)){
            m++;
        }
    }
}
</code></pre>
<p>对于“生成树”这一环节中的循环退出条件<code>i&lt;=m-1</code>，可能也会产生一些疑惑。这里用到了一个定理：</p>
<blockquote>
<p>将一个图生成树，则其总边数为总点数-1。</p>
</blockquote>
<p>同时，我们发现，每次遇到连接中出现环的情况，<code>merge</code>都不会进行连接，而是报告<code>main</code>将变量<code>m</code>的值增加1。这是因为，我们跳过了这条边，就<strong>一定要从后方加一条边来补偿</strong>。否则最终边数每次跳边都减少1，无法生成完整的树。</p>
<p>这就是算法的基础实现了。它没有输出，但是它能够承接多数的最小生成树任务：设置一个变量<code>ans</code>用来作为最终的输出结果。如果要输出边数，则只需每次连接成功时<code>ans++</code>;如果要输出总权值，则在连接成功时<code>ans+=edges[i].w</code>即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++面向对象 / 封装 继承 多态]]></title>
        <id>https://malachiten.github.io/post/cmian-xiang-dui-xiang-feng-zhuang-ji-cheng-duo-tai</id>
        <link href="https://malachiten.github.io/post/cmian-xiang-dui-xiang-feng-zhuang-ji-cheng-duo-tai">
        </link>
        <updated>2019-10-07T12:27:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="引入">引入</h2>
<p>我们以一个形象的例子来介绍这几个特性。</p>
<h3 id="一-显而易见的故事">一 显而易见的故事</h3>
<p>作为一个<s>沉迷学习的好孩子</s>，你对于<s>如何藏匿你的手机</s>得心应手。</p>
<p>在你的房间中，有一张<strong>床</strong>、一张<strong>书桌</strong>一个<strong>大大的衣柜</strong>，还有一个<strong>书柜</strong>。</p>
<p><strong>你的学习用品均储存在书柜中</strong>。</p>
<p><strong>生活用品均储存在衣柜中</strong>。</p>
<p>你的_家长_为了检查你的学习，会经常<strong>翻你的书柜和书桌</strong>。</p>
<p>而我们现在假设他们完全不管你的日常生活，因而<strong>几乎</strong>不管你的衣柜和床板底下。</p>
<p>同时，你的_家长_还自诩于重视你的隐私，因此他们还将<strong>从来不翻你自己身上的包</strong>“引以为傲”，作为与其他家长的谈资。</p>
<p>那么我们必定可以得出一个结论</p>
<blockquote>
<p>你的手机<strong>必定放在你的衣柜、床板底下或者自己的身上</strong>。这能够保证你的手机一直安全。</p>
</blockquote>
<p>这是一个显而易见的结论。然而让我们将情况变得更复杂一点：</p>
<p>你的同学们中，有一些_好朋友_会到你的家中玩。一得到难得的关上自己房间门的机会，你就拿出手机跟_朋友_一起玩。_朋友_临走时，他<strong>询问你藏匿手机的技巧</strong>，于是你<strong>告诉了他你的大部分技巧</strong>。</p>
<p>不过，因为朋友的不同，你告诉不同的朋友不同的技巧。你把手机放在身上的事，却因为你不保证_朋友A_的家长是否对他搜身，而提示他不要藏在身上。_朋友B_家更注重孩子隐私，因此从不进他的房间，则可以告诉他全部的技巧。而他也不必提心吊胆地藏在身上。</p>
<p>于是，你的_朋友A_具有了这样的藏匿手机技巧：</p>
<blockquote>
<p>把手机放在衣柜里面或者床板下面。</p>
</blockquote>
<p>_朋友B_变成这样：</p>
<blockquote>
<p>把手机放在书桌、书柜、衣柜或者床上。</p>
</blockquote>
<p>同时我们还发现，你需要悄悄玩手机，但是对于手机的频繁转移，并没有什么需求。不过你还是告诉了他们几个技巧供他们选择。</p>
<p>后来你的手机被发现了，不过你的朋友们将你的技能发扬光大，<s>代代相传</s>。(大雾)</p>
<h3 id="二-抽象这个故事">二 抽象这个故事</h3>
<p>之前也说过：经过抽象,就能研究事物的本质与规律。</p>
<p>抽象的一般方法：</p>
<blockquote>
<ol>
<li>忽略事物中与当前问题或目标无关的特点,集中考虑有关。</li>
<li>忽略非本质的特征,抽取本质性特征</li>
<li>从个体把握一般,从事物把握本质</li>
</ol>
</blockquote>
<p>由此，这个典例事件，我们可以这样抽象：</p>
<p>将你的房间看做一个<strong>类</strong>( <em>class</em> )。这个类有如下的特性：</p>
<ul>
<li>其中的“书柜”和“书桌”是<strong>任由外部访问</strong>的成员。这样的成员，称为<code>public</code>成员。</li>
<li>“床”和“衣柜”禁止<strong>除了你的朋友以外的人访问</strong>。这样的称为<code>protected</code>成员。</li>
<li>“自己身上”禁止<strong>一切外部访问</strong>。这样的则称为<code>private</code>成员。</li>
</ul>
<p>通过严格的将这些容器给<strong>封装</strong>起来，你严格地控制了外部对于你的成员的访问，保证了你的手机的安全。同时，你的朋友们只需要知道找你(接口)就可以跟你一起玩手机，而并不需要亲自翻箱倒柜(了解接口内部的实现)。</p>
<p>而你的朋友们回家之后就在他的房间上<strong>继承</strong>了你房间的特性。这时，可以将你自己的房间称为他们继承的“基类”。相对而言，他们的房间就变成了“派生类”。</p>
<p>_A_的房间具有了<strong>除了跟你身上以外的一切特性</strong>。他也具有了你的<code>public</code>和<code>protected</code>属性，只有<code>private</code>属性不能被继承下来。这样的继承方式，被称为<code>public</code>继承。</p>
<p>_B_的房间中，手机则也可以放在相同的地方。不过，显然，他的书柜和书桌禁止<strong>除了他的朋友以外的人访问</strong>。因而，你的<code>public</code>成员变成了他的<code>protected</code>成员。这样的继承方式，则称为<code>protected</code>继承。这种继承方式中，基类除了<code>private</code>之外的成员都会变成派生类的<code>protected</code>成员。</p>
<p>除此之外，还有<code>private</code>继承，用于<s>跟Vim一起帮助乌干达的可怜儿童</s>。所幸你没有这样的一个朋友。<s>不然我就打不完代码了</s>显然可见，对于这样的人而言，他家的空间都是他不为他人访问的的<code>private</code>成员。他也没有必要去继承你的<code>private</code>。</p>
<p>与此同时，他们继承了你的转移手机方法。你的转移手机方法因为没有必要而并不能执行(因此是一个虚拟函数)，而你的朋友们将其重载而发展开来。这就是由基类提供纯粹的接口而派生类通过重载赋予其实际作用的<strong>多态</strong>特性。</p>
<h2 id="语法">语法</h2>
<p>对于刚刚的例子，我们可以将其写成一个例程来体现封装和继承的语法。</p>
<pre><code class="language-cpp">class your_home{
    private:
        void play_phone(){}//玩手机
        int body;
    protected:
        virtual void transfer_phone()=0;//不需要的转移
        int bed,wardrobe;
    public:
        int desk,bookcase;
};
//其实这个描述不太形象——你的类并不能实例化，因为其包含了一个纯虚函数transfer_phone()，是一个纯虚类/抽象类。
class A_home:public your_home{
    private:
        void play_phone(){};//玩手机
    protected:
        void transfer_phone(){}//实际的转移手机
};
class B_home:protected your_home{
    private:
        void play_phone(){};//玩手机
        void transfer_phone(){}//转移手机
};
class C_home:private your_home{
    private:
        void play_phone(){};//玩手机
        //没有必要转移手机了。
};
</code></pre>
<h2 id="总结">总结</h2>
<p>通过这个形象地例子，我们了解到了类的运用。</p>
<ul>
<li>“封装”——将成员封装在对象<code>public</code>、<code>protected</code>、<code>private</code>属性之中。这些对象的开发者和使用者分离，使用者只需要接入对象提供的<code>public</code>接口，而不用了解到它们的内部实现。这样也实现了对于它们的保护。</li>
<li>“继承”——派生类可以继承基类的属性。在<code>public</code>继承中，派生类会将基类的<code>public</code>属性作为自己的<code>public</code>属性，也可以用使用派生类<code>public</code>成员函数的方式来引用基类中的成员。而在<code>protected</code>继承中，派生类将基类的<code>public</code>属性降级为<code>protected</code>属性，<code>protected</code>保持不变，并废弃<code>private</code>类型属性。<code>private</code>继承只能将基类的<code>public</code>属性变成自己的<code>private</code>属性，将<code>protected</code>和<code>private</code>全部废弃。</li>
<li>“多态”——基类能够定义一个空的接口，下放到派生类来通过重载的方式实现。这对于抽象有极大的益处。不过要注意的是，如果要实现彻底抽象，就需要明确通过定义一个纯虚函数<code>virtual typename functionName()=0</code>。这样会使这个基类变成一个不能被实例化的抽象类(纯虚类)，只有基类将其重载然后实例化基类才能得到体现。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 编译原理 / 引论(1) [Ongoing]]]></title>
        <id>https://malachiten.github.io/post/bi-ji-bian-yi-yuan-li-yin-lun</id>
        <link href="https://malachiten.github.io/post/bi-ji-bian-yi-yuan-li-yin-lun">
        </link>
        <updated>2019-10-06T03:05:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="编译程序">编译程序</h2>
<p>编译程序特指<strong>将高级语言源程序翻译成低级语言目标程序</strong>的翻译程序.</p>
<h3 id="翻译程序">&quot;翻译程序&quot;</h3>
<p>将一种语言的程序(源语言程序)翻译成另一种语言的程序(目标语言程序).</p>
<h3 id="解释程序">&quot;解释程序&quot;</h3>
<p>不产生目标程序,将源语言程序逐条取出语句并立即执行的程序.这是和编译程序不一样的.</p>
<h3 id="编译程序的种类">编译程序的种类</h3>
<ol>
<li>帮助找出错误的 诊断编译程序</li>
<li>提供优化编译开关的 优化编译程序</li>
<li>交叉编译程序 编译程序</li>
</ol>
<h3 id="宿主机与目标机">宿主机与目标机</h3>
<p>宿主机:编译程序运行的平台.</p>
<p>目标机:目标代码程序运行的平台.</p>
<h3 id="可变目标的编译程序">可变目标的编译程序</h3>
<p>能够通过不同编译开关产生不同的目标代码而运行于不同的目标机上的编译程序,称为可变目标的编译程序.</p>
<h3 id="设计语言的流程">设计语言的流程</h3>
<p>设计程序设计语言</p>
<ol>
<li>设计程序设计语言的规范</li>
<li>设计其编译程序</li>
</ol>
<h2 id="抽象的思维">抽象的思维</h2>
<p>经过抽象,就能研究事物的本质与规律.</p>
<h3 id="引入">引入</h3>
<ol>
<li>忽略与当前问题或目标无关的,集中考虑有关的</li>
<li>忽略非本质的特征,抽取本质性特征</li>
<li>从个体把握一般,从事物把握本质</li>
</ol>
<blockquote>
<p>毕加索的《牛》的变化.<br>
伦敦的地铁图的变化.(各个城市的地铁地图)</p>
</blockquote>
<h3 id="图灵机">图灵机</h3>
<p>通过一条无限长的<strong>纸带</strong>,一个<strong>读写头</strong>,一个控制读写头的<strong>规则</strong>,和一个<strong>状态寄存器</strong>,来完成各项的计算.有了这个模型,就可以研究计算的过程的本质.</p>
<blockquote>
<p>对&quot;可计算&quot;和&quot;算法&quot;的定义:&quot;如果一个过程<strong>能被图灵机执行</strong>,则其可计算/为一个算法&quot;</p>
</blockquote>
<h3 id="编译程序设计中的抽象">编译程序设计中的抽象</h3>
<p>抽象在编译程序设计中是普遍的.如:形式文法,有限自动机......</p>
<h4 id="自动化的思维">自动化的思维</h4>
<p>把事物抽象之后,把抽象的事物在计算机上实现.是将计算思维物化的过程.</p>
<p>程序的本质是用自动化的思维解决问题.</p>
<p>自动化的思想,可以指导编译程序设计,并提高开发的效率.(词法分析,语法分析,有限自动机)</p>
<h2 id="分解的思维">分解的思维</h2>
<p>即模块化的思想.</p>
<p>先将问题模块化,分解为各个子问题,如果子问题足够小能够解决则解决,能继续分解则继续分解(将编译过程分解为不同的阶段,先生成中间代码,再生成目标代码)</p>
<p>实际上,递归就是这样的问题.实际上,递归求解的子问题的结构与父问题相同.只是规模减小了.在编译的过程中,广泛的运用了递归.(应用:递归下降分析,语法制导翻译,基于树的遍历的属性计算)</p>
<h2 id="权衡-折中">权衡 / 折中</h2>
<p>对于理论上的设计,由于实际限制条件的存在,实际设计会与理论设计有差别,即需要这种折中的思维.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 欧拉路 [Ongoing]]]></title>
        <id>https://malachiten.github.io/post/bi-ji-ou-la-lu</id>
        <link href="https://malachiten.github.io/post/bi-ji-ou-la-lu">
        </link>
        <updated>2019-10-04T09:06:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是欧拉路">什么是欧拉路</h2>
<p>欧拉路是指从图中任意一个点开始到图中任意一个点结束的路径，并且图中每条边通过的且只通过一次。</p>
<h2 id="怎样判断有欧拉路存在">怎样判断有欧拉路存在</h2>
<h3 id="无向图">无向图</h3>
<p>图一定要联通，且:</p>
<p>所有顶点度数均为偶数，则存在欧拉回路</p>
<p>两个点度数为奇数，其余的为偶数，则存在欧拉通路</p>
<h3 id="有向图">有向图</h3>
<p>图联通依然是一个必要条件。且:</p>
<p>每个点的入度等于出度，则存在欧拉回路(任意一点有度的点都可以作为起点)</p>
<p>除某两点外，所有入度等于出度。这两点中一点的出度比入度大，另一点的出度比入度小，则存在欧拉通路。出度大者是起点，入度大者是终点。</p>
<h2 id="怎样找到欧拉路">怎样找到欧拉路</h2>
<p>之前的内容大致只是用于<strong>发现该题目应该使用欧拉回路的方法求解</strong>。</p>
<p>以下寻找方法均建立在假设图中存在欧拉回路的基础上，其自身并不能判断图是否满足条件。</p>
<p>从一个非孤立的点开始<em>DFS</em>，点可以重复经过，每次任意走一条边，并将这条边从邻接表中删去。走到目标终点(找到欧拉通路)，或者走回起点(找到欧拉回路)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 二分图匹配 / 最大匹配]]></title>
        <id>https://malachiten.github.io/post/bi-ji-er-fen-tu-pi-pei-zui-da-pi-pei</id>
        <link href="https://malachiten.github.io/post/bi-ji-er-fen-tu-pi-pei-zui-da-pi-pei">
        </link>
        <updated>2019-10-02T00:52:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义">定义</h2>
<h3 id="什么是二分图">什么是二分图</h3>
<p>从理解意义上，二分图是指一种特殊的图，其中的顶点可以被划分到两个不同的集合中，同时，每个顶点都有一条到另一个集合中的点的边。</p>
<p>其等效理解则是，图中不含具有奇数边数的环。</p>
<p>对此，百度百科的定义:</p>
<blockquote>
<p>二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边(i，j)所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。</p>
</blockquote>
<h3 id="二分图匹配是啥意思">二分图匹配是啥意思</h3>
<p>这指的是“二分图”的“匹配”。“匹配”则是图论中的一个定义:</p>
<blockquote>
<p>一个<strong>匹配</strong>是一个由边组成的集合，其中任意两条边都没有公共顶点。</p>
</blockquote>
<p>附: 百度百科的定义</p>
<blockquote>
<p>给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。</p>
</blockquote>
<h3 id="匹配点-匹配边-未匹配点-未匹配边">匹配点、匹配边、未匹配点、未匹配边</h3>
<p>显然，匹配点是指在一种匹配中，连有匹配边的点。未匹配点与之相反，没有匹配边。</p>
<p>匹配边则是对于连接在两个匹配点之间，满足匹配定义的特定边。</p>
<p>如图：</p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/10/02/uaMNL9.png" alt="uaMNL9.png"></figure>
<p>在这张图中，有这样两种匹配方式:</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1→5</td>
<td style="text-align:center">1→4</td>
</tr>
<tr>
<td style="text-align:center">2→6</td>
<td style="text-align:center">2→6</td>
</tr>
<tr>
<td style="text-align:center">Null</td>
<td style="text-align:center">3→5</td>
</tr>
</tbody>
</table>
<p>那么，按照第一种匹配方式，匹配点有<code>1</code>,<code>2</code>,<code>4</code>,<code>6</code>这4个,其他点均为未匹配点。匹配边有<code>1→5</code>,<code>2→6</code>这两条,其他边均为未匹配边。</p>
<p>按照第二种匹配方式，匹配点就有<code>1</code>,<code>2</code>,<code>3</code>,<code>4</code>,<code>5</code>,<code>6</code>,全部匹配完了。匹配边有<code>1→4</code>,<code>2→6</code>,<code>3→5</code>,剩下的其他边就是未匹配边了。</p>
<p>因为:</p>
<blockquote>
<p>既得易见平凡，仿照上例显然。留作习题答案略，读者自证不难。</p>
</blockquote>
<p>(手动滑稽)</p>
<h3 id="最大匹配-完美匹配">最大匹配 &amp; 完美匹配</h3>
<p><strong>最大匹配</strong>的定义:</p>
<blockquote>
<p>一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。<br>
每个图必定存在一个最大匹配。</p>
</blockquote>
<p>而<strong>完美匹配</strong>是指:</p>
<blockquote>
<p>如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。<br>
不是每一个图都有完美匹配。<br>
完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突</p>
</blockquote>
<p>需要注意的是，由于完美匹配中所有顶点均为匹配点，所以一个二分图的完美匹配一定是这个图的最大匹配。然而，不是每个二分图都能够找到它的完美匹配，但最大匹配一定存在。因此，每个图的最大匹配不一定是完美匹配。</p>
<p>因此，按照上例:</p>
<p>第一种匹配方式仅仅是一种常规的匹配。</p>
<p>第二种匹配方式是匹配所有点的完美匹配。<strong>因此它又是该图的最大匹配</strong>。</p>
<p>因为:</p>
<blockquote>
<p>反之亦然同理，推论自然成立。略去过程QED，由上可知证毕。</p>
</blockquote>
<p>(手动滑稽)</p>
<p>需要前置了解的基本定义就这些了。</p>
<p>那么，分析算法实现。</p>
<h2 id="算法实现">算法实现</h2>
<h3 id="算法介绍">算法介绍</h3>
<p>一般，求二分图最大匹配的问题由<strong>匈牙利算法</strong>解决。</p>
<p>下面有两个<strong>专为解释该算法而生</strong>(非基础)的概念:</p>
<ul>
<li><strong>交替路</strong></li>
</ul>
<blockquote>
<p>若二分图中存在一种路径，其起点是一个非匹配点，而<strong>依次交替</strong>经过非匹配边、匹配边、非匹配边……那么这样的路径称为<strong>交替路</strong>。</p>
</blockquote>
<ul>
<li><strong>增广路</strong></li>
</ul>
<blockquote>
<p>若二分图中存在一条交替路，其经过一个<strong>除起点外的</strong>非匹配点，那么这一条路径称为<strong>增广路</strong>。</p>
</blockquote>
<blockquote>
<p>注: (2019/10/2)当前暂未开始学习<code>[ 网络流 / 最大流 ]</code>的课程，但是早有耳闻网络流中的增广路。不知道这里有没有联系呢？</p>
</blockquote>
<p>增广路具有一个性质: 非匹配边比匹配边多一条。由此，研究增广路能改进匹配。我们要做的只是:</p>
<ol>
<li>对于当前交替路，找到一条增广路。</li>
<li>把这条增广路中的匹配边和非匹配边调换(把匹配边变成非匹配边，非匹配边变成匹配边)，由此造出一条新的交替路。这样一来，我们的路径长度就比原来增加了1。匹配被改进了。</li>
<li>一直以当前交替路为基础重复找增广路，不断改进匹配。</li>
<li>当当前交替路找不到增广路，即找到最大匹配。</li>
</ol>
<p>实际上，这就是<strong>增广路定理</strong>。匈牙利算法正是利用该定理的流程来找到最大匹配。</p>
<h3 id="模板代码实现">模板代码实现</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

//const prepare
const int N=101;

//prepare
int n/*集合1中的点数*/,m/*集合2中的点数*/,s/*边数*/,l[N][N]/*邻接矩阵*/,matching[N]/*存储与这一个点相匹配的*/;

//kernel
bool dfs(int node){
    for(int i=1;i&lt;=n;i++){
        if(l[node][i]==1&amp;&amp;!vis[i]){
            vis[i]=1;
            if(!matching[i]||dfs(matching[i])){//节点从1开始的。如果是从0开始的,需要先memset(matching,-1,sizeof matching);,这里||的左边判matching[i]==-1
                matching[i]=node;
                return 1;
            }
        }
    }
    return 0;
}

//main process
int main(){
    cin&gt;&gt;s&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=s;i++){
        int tmp1,tmp2;
        cin&gt;&gt;tmp1&gt;&gt;tmp2;
        l[tmp1][tmp2]=1;
        l[tmp2][tmp1]=1;//对于有向图去除这句
    }
    int ans=0;
    for(int i=1;i&lt;=m;i++){
        if(!matching[i]){
            memset(vis,0,sizeof vis);
            ans+=dfs(i);//有增广路则+1,无则+0
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</code></pre>
<h2 id="例题-hdu2063">例题 HDU2063</h2>
<h3 id="题目描述">题目描述</h3>
<p><code>RPG girls</code>今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做<code>partner</code>和她同坐。但是，每个女孩都有各自的想法，举个例子把，<code>Rabbit</code>只愿意和<code>XHD</code>或<code>PQK</code>做<code>partner</code>，<code>Grass</code>只愿意和<code>linle</code>或<code>LL</code>做<code>partner</code>，<code>PrincessSnow</code>愿意和<code>水域浪子</code>或<code>伪酷儿</code>做<code>partner</code>。考虑到经费问题，<code>boss刘</code>决定只让找到<code>partner</code>的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的ACMer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？</p>
<h3 id="输入">输入</h3>
<p>输入数据的第一行是三个整数<code>K</code>,<code>M</code>,<code>N</code>，分别表示可能的组合数目，女生的人数，男生的人数。<code>0&lt;K&lt;=1000</code>,<code>1&lt;=N</code>,<code>M&lt;=500</code>.接下来的K行，每行有两个数，分别表示女生<code>Ai</code>愿意和男生<code>Bj</code>做<code>partner</code>。最后一个<code>0</code>结束输入。</p>
<h3 id="输出">输出</h3>
<p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p>
<h3 id="样例数据">样例数据</h3>
<h4 id="样例输入">样例输入</h4>
<p><code>6 3 3 1 1 1 2 1 3 2 1 2 3 3 1 0</code></p>
<h4 id="样例输出">样例输出</h4>
<p><code>3</code></p>
<h3 id="代码实现">代码实现</h3>
<p>引用自<a href="https://article.itxueyuan.com/Aeava9">乌克兰大野猪</a>的<a href="https://www.itxueyuan.com/">IT学院</a>博客,有改动。</p>
<p><strong>可以看出本题只需要实现有向图的版本</strong></p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
using namespace std;

//const prepare
const int N = 505;

//normal prepare
int mat[N][N];
int boy[N];                                   //记录男孩i被女孩选择的女孩编号，未被选则0
int vis[N];                                   //很巧妙的使用，每次记录男孩i是否被占用了
int k, m, n;

//kernel
bool dfs(int x){
    for(int i = 1; i &lt;= n; i++){              //遍历所有的男生编号 
        if(mat[x][i] == 1 &amp;&amp; vis[i] == 0){    //如果有连线且boy[i]没有被本次查找遍历过 
            vis[i] = 1;                       //假设i号boy被遍历到了 
            if(boy[i] == 0 || dfs(boy[i])){   //如果boy[i]没有被占用或者能把占用boy[i]的人换一个连线，短路原则如果没有被占用则不会执行后面的部分 
                boy[i] = x;                   //这一步的作用是执意要将boy[i]匹配给x(尽可能给腾位置出来，因为她可能占了别的女生相匹配的男生)        
                return true;
            } 
        }
    }
    return false;
}

//main process
int main(){
    while(scanf(&quot;%d&quot;, &amp;k) != EOF){
        if(k == 0) break;
        scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
        memset(mat, 0, sizeof(mat));
        memset(boy, 0, sizeof(boy));           //boy[]数组存放的是已经匹配好的方案，如果是0则未匹配 
        for(int i = 1; i &lt;= k; i++){
            int x, y;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            mat[x][y] = 1;
        }
        int ans = 0;
        for(int i = 1; i &lt;= m; i++){
            memset(vis, 0, sizeof(vis));        //vis每一次都将所有的男生编号都标记为没遍历过，注意区分vis[]和boy[]数组功能的区别 
            if(dfs(i)) ans++;                   //如果能直接相连或别人腾出位置总数+1 
        }
        printf(&quot;%dn&quot;, ans);
    }
    return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 图的存储 / 邻接表-链式前向星]]></title>
        <id>https://malachiten.github.io/post/bi-ji-lin-jie-biao-lian-shi-qian-xiang-xing</id>
        <link href="https://malachiten.github.io/post/bi-ji-lin-jie-biao-lian-shi-qian-xiang-xing">
        </link>
        <updated>2019-10-01T00:52:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="引入">引入</h2>
<p>一般而言采用这种朴素的存储方式( <strong>邻接矩阵</strong> )，读写图时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，存图空间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-cpp">int graph[maxn][maxn],n;
cin&gt;&gt;n;
for(int i=1;i&lt;=n;i++){
    cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;
    graph[t1][t2]=t3;
}
</code></pre>
<p>但是当图特别大的时候，这种操作会直接爆掉内存然后<code>Memory Limit Execeed</code></p>
<p>所以，需要进行优化</p>
<p>于是，巨佬就搞出了链式前向星( <strong>时间空间均最优的存图数据结构</strong> )</p>
<p>Talk is cheap,show me the code:</p>
<p>结构体实现</p>
<pre><code class="language-cpp">int head[maxn],ptr;
struct edge{
    int target,value,next;
    edge(){}
    edge(int x,int y,int z){
        target=x;
        value=y;
        next=z;
    }
}edges[maxn];
void clear(){
    memset(head,-1,sizeof head);
    ptr=0;
}
</code></pre>
<p>纯数组实现</p>
<pre><code class="language-cpp">int head[maxn],target[maxn],value[maxn],next[maxn],ptr;
void addEdge(int x/*起始点*/,int y/*终止点*/,int z/*权值*/){
    ++ptr;
    target[ptr]=y;
    next[ptr]=head[x];
    value[ptr]=z;
}
void clear(){
    memset(head,-1,sizeof head);
    ptr=0;
}
</code></pre>
<h2 id="解析">解析</h2>
<h3 id="结构体-edge">结构体 edge</h3>
<p>显然这个结构体描述的是图中的<strong>边</strong>。它具有三个成员变量: <code>target</code>,<code>value</code>,<code>next</code></p>
<ul>
<li><code>target</code>表示了这条边的终点。</li>
<li><code>value</code>表示了这条边的边权。</li>
<li><code>next</code>表示了与这条边起点相同的上一条边的编号。</li>
</ul>
<h3 id="数组-edges">数组 edges</h3>
<p>显然，这个数组用于存储边，然而其中的边是按照读入顺序存储，对于有序遍历图是乱序的。要想顺序读取则需要由一定的规范进行。</p>
<p>描述这个规范的，就是用于中途遍历的<code>edge</code>型对象的<code>next</code>成员，以及用于查找遍历起点的<code>head</code>数组。</p>
<h3 id="数组-head">数组 head</h3>
<p>这个数组描述了“以点<code>n</code>为起点，那么应该在找到<code>edge[head[n]]</code>，从这个<strong>真实起点</strong>开始遍历”。换句话说，这个数组就是用于描述起点的。</p>
<p>而实际上，它存储的是“从点<code>n</code>出发的存入链式前向星的最后一条边”在<code>edge[]</code>中的位置。</p>
<h2 id="实例">实例</h2>
<p>考虑这样一张图:</p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/10/01/uNB6AO.png" alt="graph"></figure>
<p>边的连接可以表示为:</p>
<table>
<thead>
<tr>
<th style="text-align:center">始发点</th>
<th style="text-align:center">终止点</th>
<th style="text-align:center">权值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<p>文字表述(输入的数据)就是:</p>
<pre><code>1 3 2
1 2 4
2 3 1
2 4 5
</code></pre>
<p>这样一来，</p>
<p><code>head[1]</code>中的数据是2，<code>head[2]</code>的数据是4</p>
<p><code>edges[1]</code>中<code>target</code>的值是3，<code>value</code>存的是2，<code>next</code> 中存的是-1(表示没有前驱了)</p>
<p><code>edges[2]</code>中<code>target</code>值是2，<code>value</code>存的是4，<code>next</code>值是1(表示前驱是<code>edges[1]</code>)</p>
<p><code>edges[3]</code>中<code>target</code>值就是3，<code>value</code>存的是1，<code>next</code>则是-1(无前驱)</p>
<p><code>edges[4]</code>中<code>target</code>是4，<code>value</code>存的是5，<code>next</code>是3(前驱为<code>edges[3]</code>)</p>
<h2 id="存储过程">存储过程</h2>
<p>一共n条边，具体到每一步读入，应该是这样的:</p>
<pre><code class="language-cpp">for(int i=1;i&lt;=n;++i){
	int t1,t2,t3;
	cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;
    edges[i]=edge(t2,t3,head[t1]);
	head[t1]=i;
}
</code></pre>
<p>通过一直更新<code>head[i]</code>的值，来达到链式的作用。实际上，邻接表就是个链表。</p>
<h2 id="遍历过程">遍历过程</h2>
<p>这个例程目的为预计将读入的原封不动输出。实际操作时应当在遍历到目标之后进行某种操作，比如跑最短路</p>
<pre><code class="language-cpp">for(int i=1;i&lt;=m;++i){
	for(int j=head[i];~j.next;j=edges[j].next){
		cout&lt;&lt;i&lt;&lt;' '&lt;&lt;edges[k].target&lt;&lt;' '&lt;&lt;edges[k].value&lt;&lt;endl;
	}
}
</code></pre>
<p>因为我们以<code>j.next==-1</code>为链表上一条链的终止点标记，所以使用<code>~j.next</code>来作为循环终止条件。</p>
<h2 id="总结">总结</h2>
<p>一个整体的代码:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

int head[maxn],esize;

struct edge{
    int target,value,next;
    edge(){}
    edge(int x,int y,int z){
        target=x;
        value=y;
        next=z;
    }
}edges[maxn];

void clear(){
    memset(head,-1,sizeof head);
    esize=0;
}

int main(){
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i){
	    int t1,t2,t3;
	    cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;
        edges[i]=edge(t2,t3,head[t1]);
	    head[t1]=i;
    }
    for(int i=1;i&lt;=m;++i){
	    for(int j=head[i];~j.next;j=edges[j].next){
		    cout&lt;&lt;i&lt;&lt;' '&lt;&lt;edges[k].target&lt;&lt;' '&lt;&lt;edges[k].value&lt;&lt;endl;
	    }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[预处理器命令 #define / 宏定义 实用性说明]]></title>
        <id>https://malachiten.github.io/post/yu-chu-li-qi-ming-ling-define-hong-ding-yi-shi-yong-xing-shuo-ming</id>
        <link href="https://malachiten.github.io/post/yu-chu-li-qi-ming-ling-define-hong-ding-yi-shi-yong-xing-shuo-ming">
        </link>
        <updated>2019-09-27T09:04:09.000Z</updated>
        <content type="html"><![CDATA[<p>注明:本文大量引用、摘抄、改编自 <a href="https://blog.csdn.net/king110108/article/details/80728010">king110108的CSDN博客</a>。若重复引用本文，请别忘了添加对以上博客的引用。</p>
<p>正如引用源标题(《#define用法集锦(非常全)》)所言，该文对<code>#define</code>的用法总结的极为全面，但是对于每种用法的详细介绍较少。因此，本文主要进行的是对该文章内容的总结和重排。</p>
<h2 id="0宏定义是什么">0.宏定义是什么</h2>
<p>define，顾名思义，表示的是进行某些定义。这种定义被称为宏(marco)。</p>
<p>宏定义是一种传递给预处理器的命令。通过提前告诉预处理器本文件中定义的宏，能够使预处理器按照定义的方式自动替换文本中的字符串(这种过程一般称为“宏展开”)，从而大大<strong>简化</strong>代码。</p>
<h2 id="1如何定义宏-取消宏">1.如何定义宏、取消宏</h2>
<p>定义一个宏:</p>
<pre><code class="language-cpp">#define [MacroName)] [MacroValue]
</code></pre>
<p>定义之后，除非存在取消指令，否则对于文件中所有出现该MacroName的地方，就替换为对应的MacroValue。</p>
<p>取消一个宏:</p>
<pre><code class="language-cpp">#undef [MacroName]
</code></pre>
<p>取消之后，除非再次定义，否则对于该MacroName不再进行替换。<s>(形象地理解就是这个MarcoName被预处理器甩了)</s></p>
<h2 id="2定义常量">2.定义常量</h2>
<p>例1:</p>
<pre><code class="language-cpp">#define MAXN 2147483647
</code></pre>
<p>本例将当前文件中所有字符串&quot;MAXN&quot;全部替换成了<code>INT_MAX</code>的值<code>2147483647</code>。这就是简单的使用#define定义常量的方式。<strong>(依然建议使用const关键字来声明常量，以免引起不可预知的问题。)</strong></p>
<h2 id="3定义数据类型">3.定义数据类型</h2>
<p>很多时候，很像定义常量时，我们想<s>少打几个字而实现相同的效果</s>咳咳，使数据修改方便，我们也想使较长的数据类型名称被一个自定义的关键字代表。这时我们可以自定义一个宏来简化数据类型。</p>
<p>例:</p>
<pre><code class="language-cpp">#define ull unsigned long long
</code></pre>
<p>本例将当前文件中所有字符串&quot;ull&quot;全部替换成了<code>unsigned long long</code>。这可以使一个较长的类型名称变得非常短，从而简化代码。<strong>(跟上面一样，通常情况下依然建议使用专门的关键字typedef来简化指定类型的名称，如果发生了不可预知的问题可别怪我啊)</strong></p>
<p>所谓“不可预知的问题”就像下面这个：</p>
<pre><code class="language-cpp">#define pin (int*);
pin a,b;
</code></pre>
<p>a是<code>int</code>型指针类型，而b是<code>int</code>型常规变量。而我们期望的其实是使a和b均为<code>int</code>型指针(<code>int*</code>)。</p>
<p>要使a和b就都是<code>int</code>型指针，我们只能使用<code>typedef</code>了。这也使我们注意到一点：我们在定义的时候，一定要养成一个良好的习惯，建议所有的层次都要加括号。</p>
<p>不过，在某些特殊情形下，比如开发机与目标机的操作系统及硬件存在巨大差异~~(比如你硬要用Core i9的机子给上世纪的80486写程序)~~的时候，由于编译器、操作系统对代码中数据类型的理解大不相同，<code>typedef</code>完全无法满足我们的需求(如果强行通过<code>typedef</code>改变编译器数据类型的定义，似乎会直接报出重复定义的错误)。这时，我们反而建议使用<code>#define</code>。</p>
<p>例:</p>
<pre><code class="language-cpp">typedef  unsigned char      boolean;     /* Boolean value type. */
typedef  unsigned long int  uint32;      /* Unsigned 32 bit value */
typedef  unsigned short     uint16;      /* Unsigned 16 bit value */
typedef  unsigned char      uint8;       /* Unsigned 8  bit value */
typedef  signed long int    int32;       /* Signed 32 bit value */
typedef  signed short       int16;       /* Signed 16 bit value */
typedef  signed char        int8;        /* Signed 8  bit value */
</code></pre>
<p>对于另外一些数据类型，即使是非常情况下，依然不建议使用哦……</p>
<p>就是这些啦</p>
<pre><code class="language-cpp">typedef  unsigned char     byte;         /* Unsigned 8  bit value type. */
typedef  unsigned short    word;         /* Unsinged 16 bit value type. */
typedef  unsigned long     dword;        /* Unsigned 32 bit value type. */
typedef  unsigned char     uint1;        /* Unsigned 8  bit value type. */
typedef  unsigned short    uint2;        /* Unsigned 16 bit value type. */
typedef  unsigned long     uint4;        /* Unsigned 32 bit value type. */
typedef  signed char       int1;         /* Signed 8  bit value type. */
typedef  signed short      int2;         /* Signed 16 bit value type. */
typedef  long int          int4;         /* Signed 32 bit value type. */
typedef  signed long       sint31;       /* Signed 32 bit value */
typedef  signed short      sint15;       /* Signed 16 bit value */
typedef  signed char       sint7;        /* Signed 8  bit value */
</code></pre>
<h2 id="4条件编译">4.条件编译</h2>
<p>例:</p>
<pre><code class="language-cpp">#define debug
#ifdef debug
//do something
#else
//do something
#endif
#ifndef debug
//do something 
#else
//do something
#endif
</code></pre>
<p>本例中，提到了这几种预处理器命令:本文主要介绍的<code>#define</code>,以及依附于它而存在的命令<code>#ifdef</code>、<code>ifndef</code>、<code>else</code>、<code>endif</code>。这些命令，一般被称为“<strong>条件编译开关</strong>”。<s>(虽然我觉得叫预处理器条件分歧之类的更好听……)</s></p>
<p><code>ifdef</code>,展开缩写为：if define，表示<strong>如果定义了</strong>某个宏，则编译从此处开始直到一个<code>endif</code>标记的位置的代码。如果没有定义，则这一部分的代码不会被编译。<s>(就像被注释掉了一样)</s></p>
<p><code>ifndef</code>,展开缩写为：if not define，表示<strong>若未定义</strong>某个宏，则编译从此处开始直到一个<code>endif</code>标记的位置的代码。如果没有定义，则不会编译这些代码。</p>
<p><code>else</code>,表示否则，用于对上述两个预处理器条件命令的“条件表达式”(有没有定义)进行“取反”，只能用于这两个命令作为开头、<code>endif</code>命令作为结尾的区间内。换言之，现有一个区间，从<code>#ifdef test</code>到<code>#endif</code>，其中具备了一个<code>else</code>。那么，如果本程序在该区间开始前定义了宏<code>test</code>，那么，它将编译从<code>#ifdef test</code>后到<code>#else</code>前的部分。如果没有定义该宏，则将编译从<code>else</code>后到<code>endif</code>前的部分。</p>
<p><code>endif</code>,则是表示对于<code>ifdef</code>、<code>ifndef</code>的界限的命令。<code>endif</code>标记之后的所有代码，<strong>不受</strong>之前标记的<code>ifdef</code>、<code>else</code>和<code>ifndef</code>影响。</p>
<p>在大规模的开发过程中，特别是跨平台和系统的软件里，define最重要的功能是条件编译。就像这样，define可以用于跨平台:</p>
<pre><code class="language-cpp">#ifdef WINDOWS
//do something
#endif
#ifdef LINUX
//do something
#endif
</code></pre>
<p>这样就能通过在文件开始时写上<code>#define WINDOWS</code>、<code>#define LINUX</code>而简单地在Windows和Linux中编译不同的代码，而不需要麻烦地寻找哪些需要在Windows下编译，哪些需要在Linux下编译，然后在需要编译出对应平台的程序时注释掉另一部分……<s>(人生苦短，C++可能真比不上Python)</s></p>
<h2 id="5函数式的宏定义">5.函数式的宏定义</h2>
<p>这是一个<strong>宏定义的说明文章不可或缺的部分</strong>哦！敲黑板看重点啦！</p>
<p>~~众所周知，宏定义的知识博大精深。~~它甚至可以当做一个类似函数的东西来用！</p>
<p>例：</p>
<pre><code class="language-cpp">#define Add(a,b) (a)+(b);
</code></pre>
<p>这<strong>看起来似乎</strong>是一个实现将形式参数a与b相加并返回其值的函数。</p>
<p>我们观察这个宏定义，发现其中的结构其实是这样的：</p>
<pre><code class="language-cpp">#define [FunctionalMarcoName]([Argument1],[Argument2],...) [FunctionalMarcoValue]
</code></pre>
<p>同时要注意，FunctionalMarcoValue中对于形式参数的引用，应该使用小括号“()”将它们括起来，否则这些参数变成替换上去的字符串之后是否产生歧义将无法保证！</p>
<p>正因为如此上面这样写，与下面这个函数的效果其实也有差别哦！这些歧义也使函数式宏定义在某些意义下不安全。</p>
<pre><code class="language-cpp">int Add(int a,int b){
    return a+b;
}
</code></pre>
<p>我们考虑这样一个情况：<code>c*Add(a,b)*d</code>。</p>
<p>我们将会发现，正常来说，这行程序的逻辑是：先将a与b相加，将它们的和与c、d连乘。</p>
<p>可是很<s>不</s>明显的是，预处理器将会<s>像个憨憨一样</s>忠实地按照宏定义的定义，将程序文本中的<code>Add(a,b)</code>全给换成<code>a+b</code>！这样一来……它将会计算<code>c*a+b*d</code>的值！它的逻辑将会变成，分别将a与c、b与d相乘，然后将两个乘积相加！这是我们不期望的。一定要警惕！因此，我们应该使用这样写法才能保证安全：</p>
<pre><code class="language-cpp">#define Add(a,b) ((a)+(b))
</code></pre>
<p>宏定义为了防止错误而使用小括号的例子：</p>
<pre><code class="language-cpp">#define DUMP_WRITE(addr,nr) {memcpy(bufp,addr,nr); bufp += nr;}//BUG
#define DO(a,b) do{a+b;a++;}while(0)//应该使用的定义
</code></pre>
<p>当这样使用时：</p>
<pre><code class="language-cpp">if(addr)DUMP_WRITE(addr,nr);
else do_somethong_else();
</code></pre>
<p>宏将展开，程序变为：</p>
<pre><code class="language-cpp">if(addr){memcpy(bufp,addr,nr); bufp += nr;};
else do_something_else();
</code></pre>
<p>gcc在碰到else前面的“;”时就认为if语句已经结束，因而后面的else不在if语句中。而**采用do{} while(0)的定义，在任何情况下都没有问题。**而改为 <code>#define DO(a,b) do{a+b;a++;}while(0)</code> 的定义则在任何情况下都不会出错。</p>
<p>在<strong>避免危险情况出现的前提下</strong>，某些宏定义能够在极短的空间内完成极为复杂的操作！</p>
<p>比如，我们已经知道，宏是用来<strong>在原文本中替换字符串</strong>的。</p>
<p>因此，宏定义为我们提供了这几种操作：<code>#</code>、<code>@#</code>和<code>##</code>。先看一个例子：</p>
<pre><code class="language-cpp">#define paster(n) printf(&quot;token&quot;#n&quot;=%d\n&quot;,token##n)
</code></pre>
<p>我们了解：</p>
<p><code>#</code>用来将宏定义的形式参数转换为“作为字符串(string/char数组)数据类型存在的”字符串，并用于替换。</p>
<p><code>##</code>则用于将转换成“程序文本意义上的”字符串与其他程序文本相连接。</p>
<p>于是我们可以知道：</p>
<p><strong>设token1=1,token2=2,……,tokenn=n</strong></p>
<ul>
<li><code>paster(1)</code>等效于<code>printf(&quot;token1=%d\n&quot;,token1);</code>，输出&quot;token1=1&quot;,</li>
<li><code>paster(2)</code>等效于<code>printf(&quot;token2=%d\n&quot;,token2);</code>，输出&quot;token2=2&quot;;</li>
<li>……</li>
<li><code>paster(n)</code>等效于<code>printf(&quot;tokenn=%d\n&quot;,tokenn);</code>，输出&quot;tokenn=n&quot;。</li>
</ul>
<p>不过我们必须知道，这些处理是在预处理器中完成的！不要希望使用预处理器命令在程序运行过程中临时声明常规变量！不过这种写法不受影响：</p>
<pre><code class="language-cpp">#define newInt(n) int* (n)=new int(##n))
</code></pre>
<p>上例没有提到的写法是<code>@#</code>。它用于将后面的参数变为<strong>单字符(char)字符数据类型意义上的</strong>字符串。</p>
<p>原文作者通过引用另一个作者hustli的文章，提供了几个少见的例子用来阐明这些操作之间的差别,不过日常开发中几乎不会出现，看看就好吧：</p>
<pre><code class="language-cpp">#define A(x) T_##x
#define B（x) #@x
#define C（x) #x
</code></pre>
<p>我们假设：x=1，则有：</p>
<ul>
<li>A(1)等效于程序文本T_1</li>
<li>B(1)等效于字符'1'</li>
<li>C(1)等效于字符串&quot;1&quot;</li>
</ul>
<p><code>#define</code>的特殊操作就这些，很简单吧~</p>
<p>下一个知识点！就像一般函数都包含换行，写成函数形式的宏定义也能包含换行哦。</p>
<p>很出名的MFC官方例：</p>
<pre><code class="language-cpp">#define MACRO(arg1, arg2) do { /
/* declarations */ /
stmt1; /
stmt2; /
/* ... */ /
} while(0) /* (no trailing ; ) */
</code></pre>
<p>可见，要在每一个换行的时候加上一个&quot;/&quot;。这种写法其实非常麻烦，已经违背了实用性说明的原则，因此我其实不建议使用这种写法。<s>(同时希望大家都学着压行)</s></p>
<p>引用源的作者也这样认为。他在原文中对这个例子的评价是：&quot;非常的经典，虽然让人看了恶心&quot;。</p>
<p>对于函数式的宏定义，就说到这里了。下面是几个常用的方便例子：</p>
<ul>
<li>得到指定地址上的一个字节或字</li>
</ul>
<pre><code class="language-cpp">#define  MEM_B(x) (*((byte*)(x)))
#define  MEM_W(x) (*((word*)(x)))
</code></pre>
<ul>
<li>求最大值和最小值</li>
</ul>
<pre><code class="language-cpp">#define  MAX( x, y ) ( ((x) &gt; (y)) ? (x) : (y) )
#define  MIN( x, y ) ( ((x) &lt; (y)) ? (x) : (y) )
</code></pre>
<ul>
<li>得到一个field在结构体(struct)中的偏移量</li>
</ul>
<pre><code class="language-cpp">#define FPOS( type, field ) /
/*lint -e545 */ ( (dword) &amp;(( type *) 0)-&gt; field ) /*lint +e545 */
</code></pre>
<ul>
<li>得到一个结构体中field所占用的字节数</li>
</ul>
<pre><code class="language-cpp">#define FSIZ( type, field ) sizeof( ((type *) 0)-&gt;field )
</code></pre>
<ul>
<li>按照LSB格式把两个字节转化为一个Word</li>
</ul>
<pre><code class="language-cpp">#define  FLIPW( ray ) ( (((word) (ray)[0]) * 256) + (ray)[1] )
</code></pre>
<ul>
<li>按照LSB格式把一个Word转化为两个字节</li>
</ul>
<pre><code class="language-cpp">#define  FLOPW( ray, val ) /
  (ray)[0] = ((val) / 256); /
  (ray)[1] = ((val) &amp; 0xFF)
</code></pre>
<ul>
<li>得到一个变量的地址（word宽度）</li>
</ul>
<pre><code class="language-cpp">#define  B_PTR( var )  ( (byte *) (void *) &amp;(var) )
#define  W_PTR( var )  ( (word *) (void *) &amp;(var) )
</code></pre>
<ul>
<li>得到一个字的高位和低位字节</li>
</ul>
<pre><code class="language-cpp">#define  WORD_LO(xxx)  ((byte) ((word)(xxx) &amp; 255))
#define  WORD_HI(xxx)  ((byte) ((word)(xxx) &gt;&gt; 8))
</code></pre>
<ul>
<li>返回一个比X大的最接近的8的倍数</li>
</ul>
<pre><code class="language-cpp">#define RND8( x )    ((((x) + 7) / 8 ) * 8 )
</code></pre>
<ul>
<li>将一个字母转换为大写</li>
</ul>
<pre><code class="language-cpp">#define  UPCASE( c ) ( ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') ? ((c) - 0x20) : (c) )
</code></pre>
<ul>
<li>判断字符是不是10进值的数字</li>
</ul>
<pre><code class="language-cpp">#define  DECCHK( c ) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')
</code></pre>
<ul>
<li>判断字符是不是16进值的数字</li>
</ul>
<pre><code class="language-cpp">#define  HEXCHK( c ) (  ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9') ||/
                        ((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'F') ||/
                        ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'f') )
</code></pre>
<ul>
<li>防止溢出的一个方法</li>
</ul>
<pre><code class="language-cpp">#define  INC_SAT( val )  (val = ((val)+1 &gt; (val)) ? (val)+1 : (val))
</code></pre>
<ul>
<li>返回数组元素的个数</li>
</ul>
<pre><code class="language-cpp">#define  ARR_SIZE( a )  ( sizeof( (a) ) / sizeof( (a[0]) ) )
</code></pre>
<ul>
<li>返回一个无符号数n尾的值</li>
</ul>
<pre><code class="language-cpp">#define MOD_BY_POWER_OF_TWO( val, mod_by ) /
                           ( (dword)(val) &amp; (dword)((mod_by)-1) )
</code></pre>
<ul>
<li>对于IO空间映射在存储空间的结构，输入输出处理</li>
</ul>
<pre><code class="language-cpp">#define inp(port)         (*((volatile byte *) (port)))
#define inpw(port)        (*((volatile word *) (port)))
#define inpdw(port)       (*((volatile dword *)(port)))
#define outp(port, val)   (*((volatile byte *) (port)) = ((byte) (val)))
#define outpw(port, val)  (*((volatile word *) (port)) = ((word) (val)))
#define outpdw(port, val) (*((volatile dword *) (port)) = ((dword) (val)))
</code></pre>
<ul>
<li>使用一些宏跟踪调试</li>
</ul>
<p>这一部分原文说明得相当清晰，因此直接引用原文。</p>
<p>ANSI标准说明了五个预定义的宏名。它们是：</p>
<pre><code class="language-cpp">__LINE__
__FILE__

//__LINE__ 及 __FILE__ 宏指示，#line指令可以改变它的值，简单的讲，编译时，它们包含程序的当前行数和文件名。

__DATE__

//__DATE__ 宏指令含有形式为月/日/年的串,表示源文件被翻译到代码时的日期。

__TIME__

//__TIME__ 宏指令包含程序编译的时间。时间用字符串表示，其形式为：分：秒

__STDC__

//__STDC__ 宏指令的意义是编译时定义的。一般来讲，如果__STDC__已经定义，编译器将仅接受不包含任何非标准扩展的标准C/C++代码。如果实现是标准的,则宏__STDC__含有十进制常量1。如果它含有任何其它数,则实现是非标准的。
</code></pre>
<p>C++中还定义了 <code>__cplusplus</code>。__cplusplus 与标准c++一致的编译器把它定义为一个包含至少6为的数值。与标准c++不一致的编译器将使用具有5位或更少的数值。</p>
<p>如果编译器不是标准的,则可能仅支持以上宏名中的几个,或根本不支持。记住编译程序也许还提供其它预定义的宏名。</p>
<p>为了调试，我们还可以定义宏,例如:</p>
<p>当定义了_DEBUG,输出数据信息和所在文件所在行</p>
<pre><code class="language-cpp">#ifdef _DEBUG
#define DEBUGMSG(msg,date) printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_)
#else
#define DEBUGMSG(msg,date)
#endif
</code></pre>
<p>原文引用结束(看这个引用区域，像不像<code>ifdef</code>和<code>endif</code>呢?)</p>
<h2 id="6避免重复包含-重复定义">6.避免重复包含、重复定义</h2>
<p>由于头文件包含可以嵌套，那么 * / *.cpp / *.h / *.hpp 文件就有可能多次包含同一个头文件，就可能出现重复定义的错误，而且极难查出。<s>(我一个题的解题代码因为写反true和false这样极为???的问题，调了一个小时，如果我在数个文件中发生重复定义，怕是一年都调不出来……)</s></p>
<p>不过好在，有了<strong>条件编译开关</strong>，就可以避免重复包含(重复定义)啦！</p>
<p>例:</p>
<pre><code class="language-cpp">#ifndef __headerfileXXX__
#define __headerfileXXX__
//file
#endif
</code></pre>
<p>这样，我们就能保证即使头文件被多次包含，也不会导致里面的内容被多次定义啦！</p>
<h2 id="7总结">7.总结</h2>
<p>写了这么多，感觉也把<code>#define</code>这个预处理器命令整理的比较明白了吧。</p>
<p>同时，引用源也提供了大量的模板供给大家参考。感谢king110108巨佬的博客！</p>
<p>最后附上<code>#define</code>的英文原版定义，供给有兴趣的同学们参考：</p>
<pre><code>The define Directive
You can use the #define directive to give a meaningful name to a constant in your program. The two forms of the syntax are:
Syntax
define identifier token-stringopt
define identifier[( identifieropt, ... , identifieropt )] token-stringopt
</code></pre>
<p>那么，下篇博客再见咯！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 搜索 / DFS BFS ID A*]]></title>
        <id>https://malachiten.github.io/post/bi-ji-sou-suo</id>
        <link href="https://malachiten.github.io/post/bi-ji-sou-suo">
        </link>
        <updated>2019-09-27T06:08:30.000Z</updated>
        <content type="html"><![CDATA[<p>在NOIP中，搜索主要会考察模拟，考验代码能力。有一句名言：</p>
<blockquote>
<p>n方过百万，暴力压标算</p>
</blockquote>
<h2 id="dfs-深度优先搜索">DFS / 深度优先搜索</h2>
<p>这更符合人类的思考方式。(<s>人类的本质是什么鸭？</s>)</p>
<p>适合<strong>状态不容易存储</strong>的情况(每次只会存储这一次的状态并推导下一次的状态)。</p>
<p>深度优先搜索主要使用栈来实现。</p>
<p>搜索的流程：首先找到一个状态开始向下发展，直到发展到末端，向上回溯一级再次向下搜索。</p>
<h3 id="寻找最优解这是最常用的">寻找最优解(这是最常用的)</h3>
<p>这种情况下,一般会有很多种不同的状态</p>
<pre><code class="language-cpp">void dfs(int cur){
    if(!check(cur)){
        //可行性剪枝。如果预测到某个状态以下的所有答案走到底均不可行，则剪去剩余搜索子树
        return;
    }
    if(cur无法比当前最优解更优)){
        //最优性剪枝。如果预测到某个状态下所有答案不能比当前ans更优，则剪去剩余搜索子树
        return;
    }
    标记当前状态已访问;
    存储当前状态的信息或者更新答案;//这一步在答案比较简单时可放到dfs的参数里面避免手动回溯
    for(枚举当前状态所有决策){
        dfs(next(cur));
    }
    //回溯:
    消除当前状态存储的信息并将其对答案的影响消去;
    将当前状态标记为未访问;
    //因为DFS算法必须通过回溯消去影响，因此又称为回溯算法
}
</code></pre>
<h3 id="寻找可行解">寻找可行解</h3>
<pre><code class="language-cpp">bool dfs(int cur){
    if(!check(cur)){
        //可行性剪枝
        return 0;
    }
    将当前状态标记为已访问;
    if(goal(cur)){
        记录可行解;
        return 1;
    }
    for(枚举当前状态的所有决策){
        if(dfs(next(cur))){
            return 1;
        }
    }
    将当前状态标记为未访问;
    return 0;
}
</code></pre>
<h3 id="dfs例题-luogu-p3154-cqoi2009循环赛">DFS例题: Luogu P3154 [CQOI2009]循环赛</h3>
<p>解析(<strong>转载自:<a href="http://www.cnblogs.com/autsky-jadek/">AutSky_JadeK的博客</a></strong>)</p>
<p><strong>思路</strong></p>
<ul>
<li>dfs+剪枝*4</li>
<li>1.只枚举一半的比赛，另一半直接得出</li>
<li>2.处理前缀和，若大于目标得分则剪枝</li>
<li>3.前缀和加上若接下来全胜的得分 仍小于目标得分，则剪枝。</li>
<li>4.枚举到每个人的最后一场比赛时直接用目标得分-前缀和 计算出最后一场的应得分。</li>
</ul>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
const int f[]={3,1,0,0};
int n,a[9],ans,Pre[9];
void dfs(int x,int y)
{
    if(Pre[x]&gt;a[x])return;
    if(Pre[x]+(n-y+1)*3&lt;a[x])return;
    if(x==n){ans++;return;}
    if(y==n)
      {
          int tmp=a[x]-Pre[x];
          if(tmp==2)return;
          Pre[y]+=f[tmp];
        dfs(x+1,x+2);
          Pre[y]-=f[tmp];
      }else{
    Pre[x]+=3;dfs(x,y+1);Pre[x]-=3;
    Pre[y]+=3;dfs(x,y+1);Pre[y]-=3;
    Pre[x]++;Pre[y]++;dfs(x,y+1);Pre[x]--;Pre[y]--;}
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
      scanf(&quot;%d&quot;,&amp;a[i]);
    dfs(1,2);
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
</code></pre>
<h3 id="dfs-枚举子集">DFS 枚举子集</h3>
<pre><code class="language-cpp">void dfs(int cur){
    if(cur){
        将cur添加进当前集合;
    }
    对子集的处理;
    for(int i=cur+1;i&lt;=n;i++){
        dfs(i);
    }
}
</code></pre>
<p>该算法处理集合 {1,2,3,4} 的过程如下:</p>
<pre><code>1
1 2
1 2 3
1 2 3 4
2
2 3
2 3 4
3
3 4
4
</code></pre>
<p>可见，该算法是<strong>将过程全部输出</strong>的DFS。</p>
<h2 id="bfs-广度优先搜索">BFS / 广度优先搜索</h2>
<p>广度优先搜索是序列式的搜索，适合状态容易储存，并且<strong>不清楚搜索深度会有多深</strong>的情景。</p>
<p>广度优先搜索一般使用队列实现。</p>
<p>搜索的流程：找到第一个状态，一次生成其下方一层的节点并全部储存，以此向下发展。</p>
<pre><code class="language-cpp">void bfs(){
    q.push(st_start);
    vis[st_start]=true;
    while(!q.empty()){
        st U=q.front();
        for(i in next(st)){
            if(!vis[i]&amp;&amp;check(i)){
                vis[i]=true;
                i.d=st.d+1;
                if(goal(i)){
                    对最终状态的处理;
                    return;
                }
                q.push(i);
            }
        }
        q.pop();
    }
}
</code></pre>
<h2 id="id-dfs-迭代加深-深度优先搜索">ID DFS / 迭代加深 深度优先搜索</h2>
<p><strong>首先深度优先搜索k层，若没有找到可行解，再深度优先搜索k+1层，直到找到可行解为止</strong>。由于深度是从小到大逐渐增加的，所以当搜索到结果时可以保证搜索深度是最小的。这也是迭代加深搜索在一部分情况下可以代替广度优先搜索的原因。</p>
<h2 id="id-a-迭代加深-启发式搜索">ID A* / 迭代加深 启发式搜索</h2>
<pre><code class="language-cpp">void dfs(int cur){
    if(!check(cur)){
        //可行性剪枝。如果预测到某个状态以下的所有答案走到底均不可行，则剪去剩余搜索子树
        return;
    }
    if(/*估价函数*/cantBetter(cur)){
        //最优性剪枝。如果预测到某个状态下所有答案不能比当前ans更优，则剪去剩余搜索子树
        return;
    }
    标记当前状态已访问;
    存储当前状态的信息或者更新答案;//这一步在答案比较简单时可放到dfs的参数里面避免手动回溯
    for(枚举当前状态所有决策){
        dfs(next(cur));
    }
    //回溯:
    消除当前状态存储的信息并将其对答案的影响消去;
    将当前状态标记为未访问;
    //因为DFS算法必须通过回溯消去影响，因此又称为回溯算法
}
</code></pre>
<p>上面就是DFS的例子。其实ID A*就是用了启发式搜索的估价函数来改写最优性剪枝的方案。</p>
<h2 id="a-启发式搜索">A* / 启发式搜索</h2>
<ul>
<li>给广搜的状态一个估价函数，然后以估价参数为优先级使用优先队列代替队列。</li>
<li>重点是估价函数的设计。</li>
<li>估价函数h(s)是当前状态到目标状态的乐观估计最优解。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Luogu P1305 新二叉树 题解]]></title>
        <id>https://malachiten.github.io/post/p1305-xin-er-cha-shu-ti-jie</id>
        <link href="https://malachiten.github.io/post/p1305-xin-er-cha-shu-ti-jie">
        </link>
        <updated>2019-09-27T02:16:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="luogu-p1305-新二叉树-题解">Luogu P1305 新二叉树 题解</h1>
<p>很水的一道二叉树的题。其实并不需要真正利用在程序中构造二叉树进行求解的思路，而是利用二叉树的性质，找出规律，从而得出结果。</p>
<p>首先让我们看到题目：</p>
<h2 id="题目描述">题目描述</h2>
<p><strong>输入一串二叉树，用遍历前序打出。</strong></p>
<p>一看这个题目，似乎还无法得出一个规律。不过我们产生了问题：如何输入这一串二叉树？</p>
<h2 id="输入格式">输入格式</h2>
<p><strong>第一行为二叉树的节点数</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>≤</mo><mn>26</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(n≤26)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mclose">)</span></span></span></span>。</p>
<p><strong>后面n行，每一个字母为节点，后两个字母分别为其左右儿子。</strong></p>
<p><strong>空节点用星号表示。</strong></p>
<p>这样似乎就明了了：二叉树好像是通过这几种形式输入的：</p>
<ul>
<li>父亲 左儿子 右儿子</li>
<li>父亲 儿子 星号</li>
<li>父亲 星号 星号</li>
</ul>
<h2 id="输出格式">输出格式</h2>
<p><strong>前序排列的二叉树。</strong></p>
<p>既然要求这样输出，那么我们就可以寻找一下前序排列的规律：</p>
<p>在只有一个节点的情况下，这棵树长这样：</p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/08/22/mwEKi9.png" alt="1"></figure>
<p>它的前序排列自然是这样： <code>A</code></p>
<p>如果有了两个节点，则会变成这样：</p>
<figure data-type="image" tabindex="2"><img src="https://s2.ax1x.com/2019/08/22/mwEma4.png" alt="2"></figure>
<p>前序排列为： <code>AB</code></p>
<p>有了三个节点，会变成这样：</p>
<figure data-type="image" tabindex="3"><img src="https://s2.ax1x.com/2019/08/22/mwEnIJ.png" alt="3"></figure>
<p>前序排列为： <code>ABC</code></p>
<p>似乎还没有看出什么端倪。不过，让我们继续向下发展这棵二叉树：</p>
<figure data-type="image" tabindex="4"><img src="https://s2.ax1x.com/2019/08/22/mwEeZF.png" alt="4"></figure>
<p>前序排列： <code>ABDC</code></p>
<p>等等，怎么……顺序发生了一些变化？不再是依字母表顺序排列了？</p>
<p>再来！</p>
<figure data-type="image" tabindex="5"><img src="https://s2.ax1x.com/2019/08/22/mwEMGR.png" alt="5"></figure>
<p>前序排列： <code>ABDEC</code></p>
<p>原来规律是这样！</p>
<p><strong>每次第一个输入的序列（根节点及其子节点） 直接被加入前序中；</strong></p>
<p><strong>后续有两种儿子的，则忽略 “ 星号 ” 字符，将左儿子插入序列中其父亲节点后的一位，将右儿子插入序列中其左儿子节点的后一位。</strong></p>
<p><strong>仅有一种儿子的（表现形式为 父亲 儿子 星号 ），就简单将其儿子插入父亲节点的后一位即可。</strong></p>
<p><strong>找到父亲节点或左儿子的方法很简单：通过 <code>string</code> 类的这个成员函数即可完成：</strong></p>
<pre><code class="language-cpp">int find(string s);
</code></pre>
<p>这个成员函数的作用是<strong>返回子字符串s在原串中的位置</strong>。如果找不到，则返回：</p>
<pre><code class="language-cpp">string::npos
</code></pre>
<p>这个常量。（这个常量在不同的编译器中，有不同的值，虽然有些时候是 <code>static_cast&lt;size_type&gt;(-1)</code> ，但是可能其他时候会出差错(比如变成size_t的最大值,4294967295)。因此，我们在这里不写-1，而写这个常量更为保险。如果想继续深入了解这个用于标记<code>find</code>失败的常量，可以参考<a href="https://blog.csdn.net/JIEJINQUANIL/article/details/51789682">其他巨佬的博客</a>）</p>
<p>然后，我们再使用这个类里面的另一个函数 <code>insert</code> 向指定的位置插入代表子节点的字符：</p>
<pre><code class="language-cpp">void insert(int position,int length,string s);
</code></pre>
<p>它的作用是 <strong>从字符串中的第position个位置开始，插入length个字符，这些字符来源于s</strong> 。</p>
<p>这样，我们就可以得到这题的代码！</p>
<h3 id="代码如下">代码如下：</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
string t;
int n;
string s;
int main(){
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;s;
		if(t.find(s[0])==string::npos){t=s;continue;}
		if(s[1]!='*') t.insert(t.find(s[0])+1,1,s[1]);
		if(s[2]!='*') t.insert(t.find(s[1])+1,1,s[2]);
	}
	cout&lt;&lt;t&lt;&lt;endl;
}
</code></pre>
<h5 id="你觉得一次就能ac了">你觉得一次就能AC了？</h5>
<h4 id="并不是">并不是！</h4>
<h3 id="实际上">实际上！</h3>
<h2 id="这个只有20分">这个只有20分！！！</h2>
<figure data-type="image" tabindex="6"><img src="https://s2.ax1x.com/2019/08/22/mwmhAU.png" alt="x1"></figure>
<p>为什么？为什么只有20分？</p>
<p>很简单。下载数据后，你会发现这是因为这份代码没有考虑到这种数据的存在：</p>
<p><strong>“指示根节点及其子节点的第一行就含星号 ！！！”</strong></p>
<p>这种数据会带来什么影响？</p>
<p><strong>你的程序将把“ 星号 ”当作一种子节点！！！</strong></p>
<p>于是，之后的输出就完全混乱了。毕竟，由于第一行是特判全部输入，“ 星号 ”这样的鬼东西都被插进了字符串里面。</p>
<p>不过这样一来，你就找到了修改的思路：</p>
<p>使用 <code>string</code> 类的这个成员函数： <code>erase</code> ！</p>
<pre><code class="language-cpp">void erase(string::iterator start,string::iterator end);
</code></pre>
<p>直接运用它，产生的作用其实是消除<strong>一个字符串中的一段连续的长度</strong>。那么怎么达到消除<strong>全部指定字符</strong>（此处为标明了根节点及其儿子的字符串中的 “ * ” ）呢？</p>
<p>使用 <code>algorithm</code> 库中的 <code>remove</code> 函数！</p>
<pre><code class="language-cpp">iterator remove(iterator start,iterator end,auto c);
</code></pre>
<p>有了这个，我们就能够不断地清除字符串中的目标字符，并不断返回指向其未被删除元素的下一个元素的迭代器，从而使用erase函数清除它。</p>
<p>于是，我们得到了用于<strong>清除一段字符串中全部指定字符</strong>的完整代码：</p>
<pre><code class="language-cpp">erase(remove(string::iterator start,string::iterator end,char c),string::iterator end);
</code></pre>
<p>那么，新的代码也呼之欲出了！</p>
<h3 id="新代码如下">新代码如下：</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
string t;
int n;
string s;
int main(){
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;s;
		if(t.find(s[0])==string::npos){
			s.erase(remove(s.begin(),s.end(),'*'),s.end());
			t=s;
			continue;
		}
		if(s[1]!='*') t.insert(t.find(s[0])+1,1,s[1]);
		if(s[2]!='*') t.insert(t.find(s[1])+1,1,s[2]);
	}
	cout&lt;&lt;t&lt;&lt;endl;
}
</code></pre>
<h5 id="你又觉得这次就能ac了">你又觉得这次就能AC了？</h5>
<h4 id="并不是-2">并不是！</h4>
<h3 id="其实">其实！</h3>
<h2 id="这个只有30分">这个只有30分！！！</h2>
<figure data-type="image" tabindex="7"><img src="https://s2.ax1x.com/2019/08/22/mwm4NF.png" alt="x2"></figure>
<p><s>才多过了一个点啊……</s></p>
<p>这次又是为什么？？！</p>
<p>下载数据后发现，这次是栽在了一种之前<strong>从未考虑到的输入情况</strong>上。</p>
<p>这次导致出错的输入数据为：</p>
<ul>
<li>父亲 星号 儿子</li>
</ul>
<p>……</p>
<p><s>这也太坑了吧</s></p>
<p>我们为了AC此题，只能继续努力了……</p>
<p>这次更改并不需要什么新的技术，只需要添加几个判断即可绕过大坑。</p>
<h3 id="代码如下-2">代码如下：</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
string t;
int n;
string s;
int main(){
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;s;
		if(t.find(s[0])==string::npos){
			s.erase(remove(s.begin(),s.end(),'*'),s.end());
			t=s;
			continue;
		}
		if(s[1]!='*'&amp;&amp;s[2]!='*'){
			t.insert(t.find(s[0])+1,1,s[1]);
			t.insert(t.find(s[1])+1,1,s[2]);
		}
		if(s[1]=='*'&amp;&amp;s[2]!='*'){
			t.insert(t.find(s[0])+1,1,s[2]);
		}
		if(s[1]!='*'&amp;&amp;s[2]=='*'){
			t.insert(t.find(s[0])+1,1,s[1]);
		}
	}
	cout&lt;&lt;t&lt;&lt;endl;
}
</code></pre>
<p>看着屏幕上蓝色方块上转着白色的圈圈，你想到：之前（指20分变30分那次）做了那么大的修改，才多过了一个点，想必这个算法还存在很多问题吧……难不成<strong>还得再重写几次？？！</strong></p>
<p>然后……</p>
<figure data-type="image" tabindex="8"><img src="https://s2.ax1x.com/2019/08/22/mwK3hF.png" alt="v"></figure>
<p>？？？？？？</p>
<h2 id="过了就过了">过了？？！就过了？？？？？！</h2>
<p>历经千辛万苦，终于过了啊……<s>（接受现实）</s></p>
<p><s>bilibili干杯！（好像并没有什么不对）</s></p>
]]></content>
    </entry>
</feed>