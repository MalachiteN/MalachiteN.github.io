<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://malachiten.github.io</id>
    <title>Malachite</title>
    <updated>2020-02-01T14:29:41.551Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://malachiten.github.io"/>
    <link rel="self" href="https://malachiten.github.io/atom.xml"/>
    <subtitle>夕焼けの中に吸い込まれて消えてった</subtitle>
    <logo>https://malachiten.github.io/images/avatar.png</logo>
    <icon>https://malachiten.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Malachite</rights>
    <entry>
        <title type="html"><![CDATA[氧化还原反应]]></title>
        <id>https://malachiten.github.io/post/yang-hua-huan-yuan-fan-ying</id>
        <link href="https://malachiten.github.io/post/yang-hua-huan-yuan-fan-ying">
        </link>
        <updated>2020-02-01T12:59:53.000Z</updated>
        <summary type="html"><![CDATA[<p>可爱的 Malachite 回来啦！详情请见更新的关于页面。</p>
<p>并删除了具有悲观色彩的 CSP 游记和东拼西凑的 <code>#pragma</code> 教程。</p>
]]></summary>
        <content type="html"><![CDATA[<p>可爱的 Malachite 回来啦！详情请见更新的关于页面。</p>
<p>并删除了具有悲观色彩的 CSP 游记和东拼西凑的 <code>#pragma</code> 教程。</p>
<!-- more -->
<h1 id="定义">定义</h1>
<p><strong>有元素化合价升降</strong>的反应，称为氧化还原反应。</p>
<h2 id="反应类型">反应类型</h2>
<p>氧化还原反应的反应类型分为<strong>氧化反应</strong>和<strong>还原反应</strong>。</p>
<h3 id="氧化反应">氧化反应</h3>
<p>物质所含元素化合价升高的反应称为氧化反应。</p>
<h3 id="还原反应">还原反应</h3>
<p>物质所含元素化合价降低的反应称为还原反应。</p>
<h2 id="反应相关物质">反应相关物质</h2>
<p>氧化还原反应的反应物分为<strong>氧化剂</strong>和<strong>还原剂</strong>，生成物分为<strong>氧化产物</strong>和<strong>还原产物</strong>。</p>
<p>实际上，氧化还原反应就是氧化剂抢夺还原剂的电子而发生还原反应，被还原，成为还原产物，而还原剂被夺走电子而发生氧化反应，被氧化，成为氧化产物。</p>
<h3 id="反应物">反应物</h3>
<h4 id="氧化剂">氧化剂</h4>
<p>反应中<strong>得到电子</strong>或<strong>电子对偏向</strong>的物质。</p>
<h4 id="还原剂">还原剂</h4>
<p>反应中<strong>失去电子</strong>或<strong>电子对偏离</strong>的物质。</p>
<h3 id="生成物">生成物</h3>
<h4 id="氧化产物">氧化产物</h4>
<p>氧化反应得到的产物。</p>
<h4 id="还原产物">还原产物</h4>
<p>还原反应得到的产物。</p>
<h2 id="重点">重点</h2>
<ol>
<li>氧化剂发生的不是氧化反应，变成的也不是氧化产物，**它是被还原了，发生的是还原反应，变成了还原产物。**还原剂同理。</li>
<li>氧化还原反应不是基本反应类型。它也不是某个基本反应类型的子集。置换反应是氧化还原反应的子集，化合反应和分解反应与氧化还原有交集。<strong>复分解反应一定不是氧化还原反应。</strong></li>
<li><strong>有单质参与的化合反应和有单质生成的分解反应，一定是氧化还原反应。</strong></li>
</ol>
<h1 id="氧化还原反应方程式配平">氧化还原反应方程式配平</h1>
<p><s>大家跟上哦，车速有点快</s></p>
<h2 id="配平方法">配平方法</h2>
<pre><code class="language-cpp">化学反应式 氧化还原配平(化学反应式 反应式){
    反应式.find(氧化剂，还原剂，氧化产物，还原产物);
    通过双线桥标出它们反应前后的化合价和电子转移数目;
    int 最小公倍数 = __lcm(电子转移数目);
    在氧化剂、氧化产物、还原剂、还原产物前加上适当的化学计量数; //电子守恒
    if(反应式.type == 化学方程式){
        继续配平非氧化还原相关物质;
        return 反应式;
    }else if(反应式.type == 离子方程式){
        使用带电荷的非氧化还原相关物质(如H+、OH-)使两边电荷数相同;
        继续配平非氧化还原相关物质;
        return 反应式;
    }else{
        throw std::logic_error(&quot;你给的这反应式是假的叭&quot;);
    }
}
</code></pre>
<p><s>果然还是改不了写代码的习惯</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ STL容器 / bitset]]></title>
        <id>https://malachiten.github.io/post/c-stl-rong-qi-bitset</id>
        <link href="https://malachiten.github.io/post/c-stl-rong-qi-bitset">
        </link>
        <updated>2019-11-08T11:04:46.000Z</updated>
        <summary type="html"><![CDATA[<p>bitset 是 C++ STL 中的一种特殊容器。正如它的名称，它是 0 或 1 的位的集合。</p>
]]></summary>
        <content type="html"><![CDATA[<p>bitset 是 C++ STL 中的一种特殊容器。正如它的名称，它是 0 或 1 的位的集合。</p>
<!-- more -->
<h2 id="简介">简介</h2>
<p>该容器位于头文件<code>&lt;bitset&gt;</code>中。能够存储一系列的 0 和 1 的位，占据的空间比<code>bool</code>数组少，同时还能简单地转换为<code>unsigned long</code>、<code>unsigned long long</code>和<code>string</code>类型。</p>
<h2 id="成员函数">成员函数</h2>
<h3 id="声明">声明</h3>
<p>声明一个<code>bitset</code>的语句如下：</p>
<pre><code class="language-cpp">bitset&lt;length&gt; name;
</code></pre>
<p>必须注意的一点是，<code>bitset</code> 有长度限制，且这个长度限制是写在<strong>尖括号</strong>里的！不要将其写在偏移量解引用运算符(也就是数组下标<code>[]</code>)或者函数调用运算符(圆括号<code>()</code>)中。</p>
<blockquote>
<p>仅供了解：之所以有这种特殊设置，是因为<code>bitset</code>本质上是一个模板类，其模板是一个常量表达式(<code>const int</code>)而不是一个<code>typename</code>，也就产生这个尖括号中的内容与其它模板类不同的现象。</p>
</blockquote>
<h3 id="构造">构造</h3>
<p>STL 已经提供了它的赋值运算符重载。可以直接将正整数值(<code>unsigned int</code>、<code>unsigned short int</code>、<code>unsigned long int</code>、<code>unsigned long long int</code>)或赋予给它，它会自动获得表示该数值的布尔位。也能通过构造函数直接赋予它布尔数组的值。甚至可以使用一个<code>string</code>类型的 01 串对它进行构造。</p>
<p>构造方法：</p>
<pre><code class="language-cpp">bitset&lt;length&gt; name = n; // n 为`unsigned int`或`unsigned short int`或`unsigned long int`或`unsigned long long int
bitset&lt;length&gt; name(n); // n 为`unsigned int`或`unsigned short int`或`unsigned long int`或`unsigned long long int
bitset&lt;length&gt; name(s); // s 为一个 string 类型的 01 串
bitset&lt;length&gt; name(b, pos, num); // b 为一个布尔数组，pos、num 为一个整数，bitset 从 b 第  pos 位开始的 num 个中获得值。
</code></pre>
<p>需要注意的是，用于构造的类型需要匹配 bitset 的长度。超过 bitet 长度的类型将被从高位开始丢弃！</p>
<h3 id="访问">访问</h3>
<p>它提供偏移量解引用运算符，用于随机访问其中的位。<strong>值得一提的是，它自右向左访问</strong>，不同于数组和向量的偏移量解引用运算符自左向右访问。</p>
<h3 id="输出">输出</h3>
<p>可以使用输出数组的方法，通过循环和偏移量解引用运算符直接输出。</p>
<pre><code class="language-cpp">for(int i=length; i&gt;=0; i--){
    cout&lt;&lt;name[i]&lt;&lt;' ';
}
</code></pre>
<p>不过，如果<s>不要求打字带空格</s>，你也可以尝试直接输出：</p>
<pre><code class="language-cpp">cout&lt;&lt;name&lt;&lt;endl;
</code></pre>
<p>也可以将其转换成字符串输出：</p>
<pre><code class="language-cpp">cout&lt;&lt;name.to_str()&lt;&lt;endl;
</code></pre>
<p>如果想进行位操作后变成正整数，还能这么干：</p>
<pre><code class="language-cpp">cout&lt;&lt;name.to_ulong()&lt;&lt;endl;
</code></pre>
<p>输出的是一个 <code>unsigned long</code> 型的值。<s>其实就是 unsigned int</s></p>
<h3 id="其它操作">其它操作</h3>
<pre><code class="language-cpp">b.any() // 询问 b 中是否存在值为 1 的位
b.none() // 询问 b 中不存在置为 1 的位
b.count() // 返回 b 中置为 1 的位的个数
b.size() // b 中位的个数
b.test(pos) // 查询 b 中在 pos 处的位是否为 1
b.set() // 把 b 中所有位变为 1
b.set(pos) // 把 b 中第 pos 位变为 1
b.reset() // 把 b 中所有位都变为0
b.reset(pos) // 把 b 中第 pos 位的变为0
b.flip() // 把 b 中所有位取反
b.flip(pos) // 把 b 中第 pos 位取反
</code></pre>
<h2 id="例题">例题</h2>
<h3 id="题目">题目</h3>
<p>给出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个整数，将其转换成 8 位长度的 <code>bool</code> 数组并依次首尾相接，按相邻的相同位切割成长度不等的段，再照首位为自身原本的值，后 7 位为段长度的方式进行压缩，最后输出每个改造之后的 8 位 <code>bool</code> 数组对应为整数的值。</p>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;bitset&gt;
using namespace std;
int n;
struct change{
	int len;
	bool val;
	change(int y, int v){
		this-&gt;len = y; this-&gt;val = v;
	}
};
int main(){
	cin&gt;&gt;n;
	vector&lt;bool&gt; line;
	vector&lt;change&gt; changes;
	for(int i=0;i&lt;(n/8);i++){
		int t;
		bitset&lt;8&gt; tmp;
		cin&gt;&gt;t;
		tmp=t;
		for(int b=7;b&gt;=0;b--){
			line.push_back(tmp[b]);
		}
	}
	int len=0;
	if(line[line.size()-1]==0){
		line.push_back(1);
	}else{
		line.push_back(0);
	}
	for(int i=1;i&lt;line.size();i++){
		if(line[i-1]==line[i]){
			len++;
		}else{
			len++;
			change tmp(len,line.at(i-1));
			changes.push_back(tmp);
			len=0;
		}
	}
	bitset&lt;8&gt; oans;
	vector&lt;unsigned long&gt; ans;
	for(int i=0;i&lt;changes.size();i++){
		oans=changes[i].len;
		oans[7]=changes[i].val;
		ans.push_back(oans.to_ulong());
	}
	for(int i=0;i&lt;ans.size();i++){
		cout&lt;&lt;ans[i]&lt;&lt;' ';
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 语法 / Assert 断言]]></title>
        <id>https://malachiten.github.io/post/assert-duan-yan</id>
        <link href="https://malachiten.github.io/post/assert-duan-yan">
        </link>
        <updated>2019-10-31T06:04:40.000Z</updated>
        <summary type="html"><![CDATA[<p>断言广泛存在于我所了解的几乎全部语言中。</p>
<p>C，C++，Python，Haskell，Lisp，……，都有自己的断言实现，且不同语言中的断言按照各自语法解读之后的“人话”几乎没有任何歧义。</p>
<p>当然，正如标题所言：本文主要讲的是 C/C++ 的断言。</p>
]]></summary>
        <content type="html"><![CDATA[<p>断言广泛存在于我所了解的几乎全部语言中。</p>
<p>C，C++，Python，Haskell，Lisp，……，都有自己的断言实现，且不同语言中的断言按照各自语法解读之后的“人话”几乎没有任何歧义。</p>
<p>当然，正如标题所言：本文主要讲的是 C/C++ 的断言。</p>
<!-- more -->
<h2 id="引入">引入</h2>
<p>一般而言，如果我们的程序一切正常，在某些时候，会产生一些必然的结果。</p>
<p>如 Leetcode 第一题，计算两数之和，并在目标数组中找到对应值，并返回其下标。</p>
<p>那么，我们就可以<strong>断言</strong>：数组中，必定存在我们要找的两数之和。如果找不到，不是查找写错了，就是两数之和算错了。</p>
<p><s>两数之和都算错还写你🐎的程序啊</s>（在线暴躁）</p>
<p>我们通过 Assert 来告诉程序我们的 “断言” ，然后，程序会每次执行到断言处就判断一次数组中到底有没有我们要查找的数。如果找不到，就打断程序，输出错误信息然后退出。</p>
<h2 id="定义">定义</h2>
<blockquote>
<p>Evaluates an expression and, when the result is false, prints a diagnostic message and aborts the program.</p>
</blockquote>
<p>断言本身，是语言为了调试方便，实现的进行真假检定的语句。一旦断言为假，立刻终止程序执行，并输出错误信息和错误发生位置到标准错误。在在线测评平台上，断言为假引发的错误被划归到RE / 运行时错误。</p>
<h2 id="实现">实现</h2>
<p>可以通过查阅头文件得知。</p>
<p>以下是来源于 C 的头文件：</p>
<pre><code class="language-c">/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */

/* According to C99 standard (section 7.2) the assert
   macro shall be redefined each time assert.h gets
   included depending on the status of NDEBUG macro.  */
#undef assert

#ifndef __ASSERT_H_
#define __ASSERT_H_

#include &lt;crtdefs.h&gt;
#ifdef __cplusplus
#include &lt;stdlib.h&gt;
#endif

#ifdef __cplusplus
extern &quot;C&quot; {
#endif

#ifndef _CRT_TERMINATE_DEFINED
#define _CRT_TERMINATE_DEFINED
  void __cdecl __MINGW_NOTHROW exit(int _Code) __MINGW_ATTRIB_NORETURN;
  void __cdecl __MINGW_NOTHROW _exit(int _Code) __MINGW_ATTRIB_NORETURN;

#if !defined __NO_ISOCEXT /* extern stub in static libmingwex.a */
  /* C99 function name */
  void __cdecl _Exit(int) __MINGW_ATTRIB_NORETURN;
#ifndef __CRT__NO_INLINE
  __CRT_INLINE __MINGW_ATTRIB_NORETURN void  __cdecl _Exit(int status)
  {  _exit(status); }
#endif /* !__CRT__NO_INLINE */
#endif /* Not  __NO_ISOCEXT */

#pragma push_macro(&quot;abort&quot;)
#undef abort
  void __cdecl __MINGW_ATTRIB_NORETURN abort(void);
#pragma pop_macro(&quot;abort&quot;)

#endif /* _CRT_TERMINATE_DEFINED */

extern void __cdecl
_wassert(const wchar_t *_Message,const wchar_t *_File,unsigned _Line);
extern void __cdecl
_assert (const char *_Message, const char *_File, unsigned _Line);

#ifdef __cplusplus
}
#endif

#endif /* !defined (__ASSERT_H_) */

#if (defined _ISOC11_SOURCE \
     || (defined __STDC_VERSION__ &amp;&amp; __STDC_VERSION__ &gt;= 201112L)) \
    &amp;&amp; !defined (__cplusplus)
/* Static assertion.  Requires support in the compiler.  */
#undef static_assert
#define static_assert _Static_assert
#endif

#ifdef NDEBUG
#define assert(_Expression) ((void)0)
#else /* !defined (NDEBUG) */
#if defined(_UNICODE) || defined(UNICODE)
#define assert(_Expression) \
 (void) \
 ((!!(_Expression)) || \
  (_wassert(_CRT_WIDE(#_Expression),_CRT_WIDE(__FILE__),__LINE__),0))
#else /* not unicode */
#define assert(_Expression) \
 (void) \
 ((!!(_Expression)) || \
  (_assert(#_Expression,__FILE__,__LINE__),0))
#endif /* _UNICODE||UNICODE */
#endif /* !defined (NDEBUG) */

</code></pre>
<p>以下为 C++ 的头文件：</p>
<pre><code class="language-cpp">// -*- C++ -*- forwarding header.

// Copyright (C) 1997-2018 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// &lt;http://www.gnu.org/licenses/&gt;.

/** @file cassert
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c assert.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: 19.2  Assertions
//

// No include guards on this header...

#pragma GCC system_header

#include &lt;bits/c++config.h&gt;
#include &lt;assert.h&gt;
</code></pre>
<p>可见，很有趣的一点是，在 C / C++ 中，“断言” 即 assert 并不是个函数，而是个宏，定义在 assert.h 中。</p>
<p>而 C++ 中的 cassert 头文件就不作任何定义，仅 <code>#include</code> 了 assert.h 。assert.h 中通过<code>extern &quot;C&quot;</code>的方式支持了 C++ 使用 C 头文件。</p>
<p>你问我为什么这么搞？</p>
<p><s>因为C你太美</s>我咋知道。</p>
<h3 id="普通断言">普通断言</h3>
<p>对于这样的一般断言，使用的方法相当简单：</p>
<pre><code class="language-cpp">assert(bool expression);
</code></pre>
<p>断言检查表达式的值是不是 0 。如果是，触发 <code>abort</code>。</p>
<h3 id="静态断言">静态断言</h3>
<p>有一个东西叫<code>static_assert</code>，属于 C++ 的标准语法，是从 C++11 标准开始应用的，不需要任何头文件就可以使用，就像<code>__built_in_scanf</code>和<code>__built_in_printf</code>那样。</p>
<p><s>祝你早日实现头文件自由！</s></p>
<p>这个东西有一个非常特殊的能力：它在编译期判断程序有没有违反断言。如果违反，直接终止编译，然后输出编译错误信息。这个信息可以自由定义。</p>
<p>然而由于这事是编译器而不是运行时干的，静态断言具有一个限制：断言表达式本身必须是常量，如果不是常量，静态断言不符合语法。<s>你不是想编译错误🐎？让你编译错误个够。</s></p>
<h2 id="限制">限制</h2>
<p>每一次执行到断言，程序都会执行断言表达式，引起性能的大规模损耗。因此，我们在发布可用产品的时候，应该设法清除 Debug 时设置的断言带来的影响。</p>
<p><s>当然如果你想卖软件赚钱，可以试试免费版不清除断言，付费版清除断言……可别跟别人说是我教的啊！</s></p>
<h3 id="消除断言">消除断言</h3>
<p><strong>嘿，停下！没叫你一个一个删！</strong></p>
<p><strong>也没叫你注释掉！</strong></p>
<p>实际上，C / C++ 自身就提供了大量取消断言的办法。</p>
<p>只需定义宏<code>NDEBUG</code>就可以取消程序中所有的断言。</p>
<p>还有，断言只有在 Debug 版本中才有效，如果编译为 Release 版本则被忽略。</p>
<p>通过这些方式，我们就能在调试完成后，发挥出程序原本应有的性能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ STL / 迭代器相关]]></title>
        <id>https://malachiten.github.io/post/c-stl-die-dai-qi-xiang-guan</id>
        <link href="https://malachiten.github.io/post/c-stl-die-dai-qi-xiang-guan">
        </link>
        <updated>2019-10-24T08:40:08.000Z</updated>
        <summary type="html"><![CDATA[<p>C++ 中的 STL 使用 <code>&lt;iterator&gt;</code> 即迭代器处理对于容器的操作。</p>
]]></summary>
        <content type="html"><![CDATA[<p>C++ 中的 STL 使用 <code>&lt;iterator&gt;</code> 即迭代器处理对于容器的操作。</p>
<!-- more -->
<h2 id="迭代器的定义">迭代器的定义</h2>
<p>迭代器是一种指向容器中元素的特殊的指针。</p>
<h2 id="迭代器的分类">迭代器的分类</h2>
<p>目前存在这样几种迭代器：</p>
<ul>
<li>输入迭代器</li>
<li>前向迭代器</li>
<li>双向迭代器</li>
<li>随机访问迭代器</li>
<li>输出迭代器</li>
</ul>
<h2 id="迭代器的作用">迭代器的作用</h2>
<p>所有的迭代器都可执行默认构造函数、拷贝构造函数、默认析构函数，并且可递增。</p>
<p><s>不然怎么迭代</s></p>
<h3 id="输入输出迭代器">输入输出迭代器</h3>
<p>输入输出迭代器都是顺序访问迭代器。该类型迭代器指向的元素只会被它访问一次，然后迭代器就会递增。</p>
<p>所有的前向迭代器、双向迭代器、随机访问迭代器都是一种特殊的输入输出迭代器。</p>
<p>输入输出迭代器之间可以比较是否相等。其重载了 <code>==</code> 和 <code>!=</code> 运算符而使得用户无需了解其内部实现。然而，已经迭代到作用域外的迭代器之间的比较是无意义的。</p>
<p>可以向容器中写入内容，或将容器中的内容取出。单一类型的迭代器只能进行输入或输出的单一操作。所有的输入迭代器都可以使用<code>*</code>指针运算符解引用为右值，同时，对于非常量输出迭代器，还能解引用为左值。(对于左值和右值如果有不懂的，可以去康一下我的另一篇博客)。</p>
<h3 id="前向迭代器">前向迭代器</h3>
<p>非常量前向迭代器具备输入输出迭代器一样的功能。同时，它们受到迭代方向限制而只能向前迭代。它们是最基本的迭代器，所有的容器 / 容器适配器均至少支持前向迭代器。</p>
<p>输入输出迭代器都是前向迭代器的一种。</p>
<p>同时，前向迭代器可以被多次地递增、解引用，无论操作多少次，只要迭代器指向的目标还在作用域内，就不会失去引用性质。</p>
<h3 id="双向迭代器">双向迭代器</h3>
<p>双向迭代器，说白了就是正着倒着都能迭代的迭代器。</p>
<p>因此，它比起前向迭代器，只增加了对于递减运算符<code>--</code>的支持。其它部分均保持一致。</p>
<h3 id="随机访问迭代器">随机访问迭代器</h3>
<p>随机访问迭代器支持以上所有迭代器的全部特性。同时，它还具有自己的特性。</p>
<p>它能够支持<code>+</code>、<code>+=</code>和<code>-</code>、<code>-=</code>运算符，能够通过这种方式立即迭代到作用域内的随机地址。</p>
<p>不等比较<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>等也都是支持的。</p>
<p>这种迭代器甚至能被 <s>调教</s> 成数组头指针一样的存在——它能使用偏移量解引用运算符，也就是我们常说的数组下标运算符<code>[]</code>，来访问从该地址偏移随机值后抵达的地址。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 高级语法 / 引用、右值和左值]]></title>
        <id>https://malachiten.github.io/post/c-gao-ji-yu-fa-yin-yong-you-zhi-he-zuo-zhi</id>
        <link href="https://malachiten.github.io/post/c-gao-ji-yu-fa-yin-yong-you-zhi-he-zuo-zhi">
        </link>
        <updated>2019-10-23T08:42:08.000Z</updated>
        <summary type="html"><![CDATA[<p>一般而言，传统的为了竞赛的 C++ 教学中对 “引用” (使用运算符<code>&amp;</code>) 的解释和 C 一样，就是 “取得这个变量的地址”。</p>
<p>和指针一样，这是常规 OIer 无需了解的知识，为了避免浪费时间，老师一般对于这一方面的知识根本不讲或者放下 C++ 而拿出 “ C 语言从入门到入土” 简单带过。然而，在工程开发中，正确、灵活地使用引用，可以使程序简洁、高效。了解左值、右值引用，更能与最新 C++ 标准接轨，了解最近产生的特性，有助于理解他人程序、简化自己的代码。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一般而言，传统的为了竞赛的 C++ 教学中对 “引用” (使用运算符<code>&amp;</code>) 的解释和 C 一样，就是 “取得这个变量的地址”。</p>
<p>和指针一样，这是常规 OIer 无需了解的知识，为了避免浪费时间，老师一般对于这一方面的知识根本不讲或者放下 C++ 而拿出 “ C 语言从入门到入土” 简单带过。然而，在工程开发中，正确、灵活地使用引用，可以使程序简洁、高效。了解左值、右值引用，更能与最新 C++ 标准接轨，了解最近产生的特性，有助于理解他人程序、简化自己的代码。</p>
<!-- more -->
<h2 id="引用">引用</h2>
<h3 id="特性">特性</h3>
<p>之前说过，这个语言要素和<strong>指针</strong>相似。这是 C++ 相对 C 的重要扩充。为了给函数传递地址，除了可以使用指针，引用提供了一种全新的途径。这种途径，被称为 “<strong>按引用传递</strong>” 。</p>
<p>声明一个引用的方法：</p>
<pre><code class="language-cpp">typename &amp;referenceName = varName;
</code></pre>
<p>此处，<code>&amp;</code>运算符的作用不是像 C 一样获取地址，而是将<code>referenceName</code>声明为<code>varName</code>的引用。</p>
<blockquote>
<p>引用即别名。</p>
</blockquote>
<p>变量名，实际上就是一段内存的引用。程序通过变量来申请和使用连续的内存段。而引用，就是某一变量（也就是目标内存地址）的一个别名，对引用的操作所产生的结果与对变量直接操作的结果完全一样。</p>
<p>因此，我们可推导如下注意事项：</p>
<ol>
<li>类型<code>Typename</code>与目标变量类型一致。</li>
<li>声明引用时，必须同时对其进行初始化。</li>
<li>引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。而对于一个目标变量，可以存在多个引用。<s>一夫多妻</s></li>
<li>声明引用的过程，不是在新定义变量，它声明的是对应引用是目标变量的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。也就是说，当<code>&amp;</code>作取地址运算符时，<code>&amp;ra</code>与<code>&amp;a</code>得出的地址相等。</li>
<li>不能声明对数组的引用。因为数组是连续变量单元构成的大片空间，引用一次只能引一个变量的地址。</li>
<li>对 NULL 的引用是无效的。因为引用必须引用一片真实存在的内存空间。</li>
</ol>
<p>上面的描述，似乎很多地方都和指针特性重合，实际上，在编译器实现上，引用也和指针是一样的。</p>
<p>那么我们为什么要引用？</p>
<blockquote>
<p>C++主张用引用传递取代地址传递的方式，因为引用语法容易且不易出错。</p>
<p>指针地址可以修改，可以为空，而引用不行，一个未初始化的引用是不能使用的，避免了用户传递空指针野指针悬垂指针之类奇奇怪怪导致 RE 的垃圾玩意儿。</p>
<p>通过sizeof的计算，指针只能得到指针本身的大小，而引用优化为得到指向对象本身的大小，这点可以推导编译器记录对象符号的时候，指针记录指针自身地址，引用则记录引用对象自身地址。</p>
<p>从引用的使用方式上，可以推导出T&amp; == T* const,一个指向的地址不可变的指针，但指向内容非const，依然可以修改内容。在编译期即避免了对指针赋值可能引起的隐秘运行时错误。</p>
<p>如果函数做左值，那么必须返回引用。</p>
</blockquote>
<h3 id="用途">用途</h3>
<h4 id="作为函数参数">作为函数参数</h4>
<p>一般而言，对于大块参数需要输入函数时，采用指针来指向该参数区域，从而避免了大量数据进入系统栈空间引起爆栈。</p>
<p>但是，现在我们又有了一种新的传参方式：引用。</p>
<p>在程序中调用以引用为参数的函数时，在主调函数的调用点处，直接以需要操作的变量作为实参进行调用即可，不对变量有任何的特殊要求。</p>
<pre><code class="language-cpp">void swap(int &amp;a, int &amp;b){
    int t;
    t = b;
    b = a;
    a = t;
}
</code></pre>
<p>例为一个常见的三变量交换的代码，其中使用了引用来直接操作实际参数的值。其主调函数可直接这样书写：</p>
<pre><code class="language-cpp">typename functionName(int a, int b, ...){
    ...
    swap(m, n);
    ...
}
</code></pre>
<h4 id="常引用">常引用</h4>
<p>如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。</p>
<p>一个常量引用应该这样声明：</p>
<pre><code class="language-cpp">const typename &amp;referenceName = varName;
</code></pre>
<p>之前我们已经了解，常量的地址在运行初始化过程即确定，操作速度比变量快。这是常引用高效的基础。</p>
<p>同时，常量可以避免修改。同样，常引用可以绑定一个常量值，而不一定是一个对象，这样作为参数的时候，常引用可以使用临时对象和常量值作为参数，而如果将一般的引用作为参数，就只能使用一个引用对象作为参数。因此，应用常引用的工程代码的健壮性提升。</p>
<h4 id="引用作为返回值">引用作为返回值</h4>
<p>要想使用引用作为返回值，则函数定义时要按以下格式：</p>
<pre><code class="language-cpp">typename &amp;funcName(typename a, typename b, ...){
    //do something
}
</code></pre>
<p>显而易见，以引用返回函数值，定义函数时需要在函数名前加<code>&amp;</code>。</p>
<p>用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。</p>
<h4 id="多态的引用实现方式">多态的引用实现方式</h4>
<p>引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。</p>
<pre><code class="language-cpp">class A{
    ...
};

class B:public A{
    ...
};

B b;
A &amp;referenceName = b;
</code></pre>
<p>这样实现的<code>referenceName</code>只能访问派生类中从基类继承下来的成员。如果 A 中存在被 B 继承的虚函数，同时 B 将这些虚函数进行了重写，那么就可以使用这个 <code>referenceName</code> 来实现多态。</p>
<h2 id="右值和左值">右值和左值</h2>
<p>先要有一个认识：</p>
<blockquote>
<p>在C++11中所有的值必属于左值、临时对象、纯右值三者之一。</p>
</blockquote>
<h3 id="区别">区别</h3>
<blockquote>
<p>右值和左值的区别在于能否获取地址。</p>
</blockquote>
<p>可以通过&amp;运算符获取地址的，就是左值；若否就是右值。既然可以取得某个变量的地址，就可以将其放置在赋值运算符的<strong>左端</strong>进行直接操作，同时可以支持<code>++</code>/<code>--</code>/<code>+=</code>等直接改变变量自身值的操作。因此，这种最传统的引用方式被称为<code>左值引用</code>。</p>
<p>在 C++11 标准中，产生了函数对象、lambda 表达式等特殊的对象，而且还产生了对常量的值进行修改、延长临时对象的生命周期等特殊的需求。这些对象无法作为左值进行引用，因此它们被称为右值。当需要更改它们的值、延长它们的生命周期时，需进行<strong>右值引用</strong>。为了与传统引用区别，专门将传统引用重定义为 “左值引用”。</p>
<h3 id="右值">右值</h3>
<p>右值，也就是匿名量，是无法获取地址的值。右值分为纯右值和临时对象。</p>
<p>实际上，常量值就是纯右值。比如程序中使用的：</p>
<pre><code class="language-cpp">'c'

&quot;Hello, World!&quot;

2

const int a = 1;

true
</code></pre>
<p>如此等等。</p>
<p>而这样的，则是临时对象：</p>
<pre><code class="language-cpp">a++;//变量自增减返回值是临时对象

a + 10;//运算符返回值是临时对象

getvalue();//函数返回值是临时对象
</code></pre>
<p>甚至</p>
<pre><code class="language-cpp">[](int n, int m){
    return n &gt; m ? n : m;
};
</code></pre>
<p><s>断头学姐</s> lambda表达式本身和返回值也都是临时对象</p>
<p>如果一个临时对象的值赋予给一个左值，这个临时对象会<s>当 场 去 世</s>（指立即被析构）。因此，临时对象还有一个名字，叫做 “将亡值” 。非常贴切。</p>
<h3 id="右值引用">右值引用</h3>
<blockquote>
<p>可以绑定右值的引用称为右值引用。</p>
</blockquote>
<h4 id="声明">声明</h4>
<p>为了声明一个右值引用，我们使用双引用运算符(<code>&amp;&amp;</code>)。</p>
<pre><code class="language-cpp">int &amp;&amp;i = 0;
</code></pre>
<p>这里，我们清晰可见，0 必定是个右值(是个常量)。而 i 是个右值引用。<strong>右值引用的第一个特点就是使其绑定的右值的生命周期与右值引用声明的生命周期一样长</strong>。只要引用还活着，该右值将会一直存活下去。</p>
<pre><code class="language-cpp">int x = 0;
int &amp;&amp;y = 0;
int &amp;&amp;z = x;
</code></pre>
<p>可以看出，这里的 x 是一个变量，而 0 是右值。 y 是对于右值的引用，这也毋庸置疑。那么问题来了，z 是个什么玩意儿？</p>
<p>实际上， z 也是右值引用。右值引用不一定非得引用一个右值，左值也能引用……这是右值引用的第二一个特点。</p>
<p>我们知道，在 C++11 中，出现了一个全新的关键字： <code>auto</code> 。这意味着，从支持这一标准开始，新的编译器具备了自动类型推导的功能。</p>
<p>除了使用<code>auto</code>标识符之外，还有一种隐式使用自动类型推导的方法：当一个未经详细定义的标识符出现在程序中时， C++11 之前的编译器会直接放弃编译然后报错 <s>真绝情</s> ，而从这一标准开始，编译器会分析你的程序如何初始化该变量，并自动推导该变量可能的类型，然后帮你加上定义。 <s>小朋友们，请联系上下文，分析作者的思想感情</s> 如果死活推不出来，才报错。(会不会有警告呢？我没试过……)</p>
<p>那么，当一个右值引用引用一个将被自动推导类型的变量，或右值引用自身的声明即需要自动类型推导时，会发生什么？</p>
<p>实际上，这并无需担心。右值引用可能是左值也可能是右值，依赖于初始化。可以说，右值引用本身就跟自动类型推导有点关系。因此，当<code>typename &amp;&amp;t</code>在发生自动类型推断的时候，它是未定的引用类型。如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。</p>
<p>设有程序如下：</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
void f(T &amp;&amp;arg); 

template&lt;typename T&gt;
class b{
    b(b &amp;&amp;c){...}; 
};
</code></pre>
<p>在这种情况下，模板函数发生了类型推导，会自动推导 arg 的类型，而模板类 b 的构造函数中的右值引用 c 因为已经有了确定的对象类型 b ，所以不会发生推导。</p>
<p>那么，当多重引用叠加时……</p>
<p>C++ 提供了这一规则：</p>
<blockquote>
<p>所有的右值引用叠加到右值引用上仍然还是一个右值引用；</p>
<p>所有的其他引用类型之间的叠加都将变成左值引用。</p>
</blockquote>
<p>这就是著名的引用折叠。</p>
<h2 id="这篇博客的引用声明">这篇博客的引用声明</h2>
<p><strong>不是 C++ 的引用！是写作中的引用！</strong></p>
<blockquote>
<p>这篇博客能够创作，离不开这几位巨佬的博客：</p>
<p><a href="https://www.cnblogs.com/mmc9527/p/10429601.html">c++引用（reference）</a></p>
<p><a href="https://www.cnblogs.com/mlgjb/p/8821340.html">C++中引用（&amp;）的用法和应用实例</a></p>
<p><a href="https://www.cnblogs.com/KaiMing-Prince/p/9741393.html">C++引用详解</a></p>
<p><a href="https://www.cnblogs.com/likaiming/p/9045642.html">c++右值引用以及使用</a></p>
<p><a href="https://www.cnblogs.com/qicosmos/p/4283455.html">从4行代码看右值引用</a></p>
<p><s>抄得可真多啊</s></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Screeps 教程]]></title>
        <id>https://malachiten.github.io/post/screeps-jiao-cheng</id>
        <link href="https://malachiten.github.io/post/screeps-jiao-cheng">
        </link>
        <updated>2019-10-22T01:12:35.000Z</updated>
        <summary type="html"><![CDATA[<p>不了解的人可以前往<a href="https://screeps.com/">Screeps官网</a>了解一下，也许我们能成为同一个<code>Shard</code>的邻居。</p>
]]></summary>
        <content type="html"><![CDATA[<p>不了解的人可以前往<a href="https://screeps.com/">Screeps官网</a>了解一下，也许我们能成为同一个<code>Shard</code>的邻居。</p>
<!-- more -->
<p>不过，看完简介也不要贸然在Steam购买，我打教程都打了不止一整天，肯定是退不了款的。在真正接触到本身之前，也不会知道它到底怎样玩。不过，在官网上有它的 Live DEMO 可供试玩，建议尝试。</p>
<h2 id="让我们开始吧界面简介">让我们开始吧：界面简介</h2>
<blockquote>
<p>Let's begin. This is a playing field called a &quot;room&quot;. In the real game, rooms are connected to each other with exits, but in the simulation mode only one room is available to you.</p>
</blockquote>
<p>屏幕中间的一大片叫做<code>room</code>，在实际游戏中，它与其他房间相连，但是在教程这里，它仅对你开放。</p>
<blockquote>
<p>The object in the center of the screen is your first spawn, your colony center.</p>
</blockquote>
<p>屏幕中间的物体是你的<code>creep</code>们的生成器。</p>
<blockquote>
<p>You play by writing code in the panel in the bottom of the screen.</p>
</blockquote>
<p>你要操作这个游戏，就得在屏幕下方的黑框框里面打代码，嘿嘿嘿。</p>
<blockquote>
<p>You can see all the characteristics of your creep (or other objects) by utilizing the &quot;View&quot; action.</p>
</blockquote>
<p>你要想看到你的所有物体的信息，需要切换到<code>View</code>视图。具体一点，点击屏幕上方的眼睛<br>
图标就可以了。</p>
<blockquote>
<p>Hide the editor panel with Alt+Enter and select your creep with the help of the &quot;View&quot; action.</p>
</blockquote>
<p>当你需要查看信息时，按下<code>Alt+Enter</code>隐藏编辑器，然后点击目标。</p>
<blockquote>
<p>Here you can see the characteristics of the object you are now looking at. Values of each characteristic and functions of body parts are described in the documentation.</p>
</blockquote>
<p>这样，在屏幕右侧工具栏中，你就能看见所选目标的全部属性。</p>
<h2 id="第一个要接触的东西控制台">第一个要接触的东西：控制台</h2>
<p><code>Console</code> 控制台 其实是一个<code>JavaScript</code>的 <strong>REPL</strong> (读入 - 执行 - 打印 - 循环) 。</p>
<p>输入一行或一块<code>JavaScript</code>语句，然后按下<code>Enter</code>执行。</p>
<blockquote>
<p>Your command returns a response <s>or execution error</s> in the console below. All output is duplicated into your browser console (Ctrl+Shift+J) where you can expand objects for debugging purposes. You can open and close the bottom panel by pressing Alt+Enter.</p>
</blockquote>
<p>你的命令返回一个结果或一个错误，将立即显示在控制台。</p>
<blockquote>
<p>It is time to put the creep to work! This yellow square is an energy source — a valuable game resource. It can be harvested by creeps with one or more <code>WORK</code> body parts and transported to the spawn by creeps with <code>CARRY</code> parts.</p>
</blockquote>
<p>下面测试下控制台，在控制台中生成一个具有<code>WORK</code>,<code>CARRY</code>,<code>MOVE</code> 的身体部件的 Creep 。</p>
<p>其实这使用了 API ：</p>
<blockquote>
<p>Game.spawns<br>
StructureSpawn.spawnCreep</p>
</blockquote>
<pre><code class="language-javascript">Game.spawns['Spawn1'].spawnCreep( [WORK, CARRY, MOVE], 'Harvester1' );
</code></pre>
<p>这就是我们的第一个<code>Creep</code>，可见，它是由名为<code>Spawn1</code>的生成器生成的，，且名为<code>Harvester1</code>。</p>
<blockquote>
<p>You can address your spawn by its name the following way: Game.spawns['Spawn1'].</p>
</blockquote>
<p>这就是生成器的路径：<code>Game.spawns['Spawn1']</code>。</p>
<blockquote>
<p>Great! You now have a creep with the name &quot;Harvester1&quot; that you can control.</p>
</blockquote>
<h2 id="然后就是最重要的脚本中的-main-模块">然后就是最重要的，脚本中的 Main 模块</h2>
<blockquote>
<p>To give your creep a permanently working command, the console is not enough, since we want the creep to work all the time. So we'll be using the Script tab rather than the console.</p>
</blockquote>
<p>控制台不能满足我们给<code>creep</code>编写工作脚本的需求。我们需要使用脚本编辑器来编写这些脚本。</p>
<blockquote>
<p>Here you can write scripts that will run on a permanent basis, each game tick in a loop. It allows writing constantly working programs to control behaviour of your creeps which will work even while you are offline (in the real game only, not the Simulation Room mode).</p>
</blockquote>
<p>只要你写了脚本，它就会一直循环执行，每<code>Tick</code>一次，即使你离线，也是如此，除非你的<strong>所有</strong>据点都被人炸没了。值得一提，<code>Tick</code>是游戏的时间单位，具体长度由服务器性能及建立据点的玩家数目决定。Screeps一共包含四个服务器，越老的服务器运行速度越慢。最老的服务器<code>shard0</code>的平均ticks时长甚至达到了惊人的5.9秒。也就是说，每过5.9秒。你的代码才会被运行一次。玩家越来越不满缓慢的游戏速度，甚至决定到其他服务器从头开始。</p>
<blockquote>
<p>To commit a script to the game so it can run, use this button or Ctrl+Enter.</p>
</blockquote>
<p>按下<code>Ctrl + Enter</code>提交你的代码。跟发个 QQ 消息一样简单。</p>
<blockquote>
<p>To send a creep to harvest energy, you need to use the methods described in the documentation section below. Commands will be passed each game tick. The harvest method requires that the energy source is adjacent to the creep.</p>
</blockquote>
<p>为了让一个<code>creep</code>收集能量，你需要学习官方 API 文档中定义的方法。执行这些方法，以让它们工作。</p>
<blockquote>
<p>You give orders to a creep by its name this way: Game.creeps['Harvester1']. Use the FIND_SOURCES constant as an argument to the Room.find method.</p>
</blockquote>
<p>具体来说，在收集资源时，需要用到<code>Game.creeps[]</code>数组、将常数<code>FIND_SOURCES</code>作为参数的方法<code>Room.find()</code>。</p>
<p>这次使用的 API 如下，可以在官方文档中查到：</p>
<blockquote>
<p>Game.creeps<br>
RoomObject.room<br>
Room.find<br>
Creep.moveTo<br>
Creep.harvest</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">module.exports.loop = function () {
    var creep = Game.creeps['Harvester1'];
    var sources = creep.room.find(FIND_SOURCES);
    if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
        creep.moveTo(sources[0]);
    }
}
</code></pre>
<p>这时你的唯一一个<code>Creep</code>会向地图上最近的黄点移动，然后开始工作。这个黄点称为<code>Source</code>，即能量源。</p>
<blockquote>
<p>A bubbling yellow spot inside the creep means that it has started collecting energy from the source.</p>
</blockquote>
<p>如果一个<code>Creep</code>内部的颜色变成亮黄色，则说明它正在收集能量源中的能量。</p>
<p><strong>It works!</strong></p>
<p>可是，当其收集满自身容量之后，就需要返回出生点 (即<code>Creep</code>的生成器，<code>Spawn</code>) 。</p>
<blockquote>
<p>To make the creep transfer energy back to the spawn, you need to use the method <code>Creep.transfer</code>. However, remember that it should be done when the creep is next to the spawn, so the creep needs to walk back.</p>
</blockquote>
<p>使用 API 提供的方法<code>Creep.transfer</code>来达成这个任务。</p>
<blockquote>
<p>If you modify the code by adding the check <code>.carry.energy</code> &lt; <code>.carryCapacity</code>to the creep, it will be able to go back and forth on its own, giving energy to the spawn and returning to the source.</p>
</blockquote>
<p>这是算法的实现方法：简单判断目标<code>Creep</code>的携带能量是否小于其最大容量。如果小于，则一直让它收集。否则，令其返回<code>Spawn</code>，将能量注入其中。</p>
<p>要实现这些，可参见 API 文档：</p>
<blockquote>
<p>Creep.transfer<br>
Creep.carry<br>
Creep.carryCapacity</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">module.exports.loop = function () {
    var creep = Game.creeps['Harvester1'];

    if(creep.carry.energy &lt; creep.carryCapacity) {
        var sources = creep.room.find(FIND_SOURCES);
        if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
            creep.moveTo(sources[0]);
        }
    }
    else {
        if( creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE ) {
            creep.moveTo(Game.spawns['Spawn1']);
        }
    }
}
</code></pre>
<blockquote>
<p>Great! This creep will now work as a harvester until it dies. Remember that almost any creep has a life cycle of 1500 game ticks, then it &quot;ages&quot; and dies (this behavior is disabled in the Tutorial).</p>
</blockquote>
<p>这样就完成了让它一直收集能量直到死亡的规划。</p>
<p>值得一提的是，每个<code>Creep</code>在出生时均具备 1500 个<code>Ticks</code>的生命时长，之后逐步减少。不过，这个行为在教程中被禁用了，目前你的<code>Creep</code>具有无限寿命。</p>
<blockquote>
<p>Let's create another worker creep to help the first one. It will cost another 200 energy units, so you may need to wait until your harvester collects enough energy. The spawnCreep method will return an error code <code>ERR_NOT_ENOUGH_ENERGY</code> (-6) until then.</p>
</blockquote>
<p>我们马上就要建造另一个工人<code>Creep</code>来帮助减轻第一个的负担了。这会消耗 200 个之前的工人收集来的能量单位，所以你需要等待你的收集者收集足够的能量。在 API 中提供的<code>spawnCreep</code>方法在没有足够能量的时候，不会生成<code>Creep</code>，而是返回一个错误常量<code>ERR_NOT_ENOUGH_ENERGY</code>。值得一提的是，它的值为 -6 。</p>
<blockquote>
<p>Remember: to execute code once just type it in the &quot;Console&quot; tab.</p>
</blockquote>
<p>像这种只需要执行一次的命令，可以只用将其输入到控制台。</p>
<p>那么具体的指令就很简单了：</p>
<pre><code class="language-javascript">Game.spawns['Spawn1'].spawnCreep( [WORK, CARRY, MOVE], 'Harvester2' );
</code></pre>
<blockquote>
<p>The second creep is ready, but it won't move until we include it into the program.</p>
</blockquote>
<p>由于我们根本没写它的脚本，所以它暂时还不会动。</p>
<blockquote>
<p>To set the behavior of both creeps we could just duplicate the entire script for the second one, but it's much better to use the for loop against all the screeps in <code>Game.creeps</code>.</p>
</blockquote>
<p>我们可以单独为它编写脚本，但是我们注意到它的脚本和第一个几乎没有差别。为了<s>偷懒</s>提高代码复用率，我们可以使用循环来解决这个问题。</p>
<p>Code:</p>
<pre><code class="language-javascript">module.exports.loop = function () {
    for(var name in Game.creeps) {
        var creep = Game.creeps[name];

        if(creep.carry.energy &lt; creep.carryCapacity) {
            var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0]);
            }
        }
        else {
            if(creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                creep.moveTo(Game.spawns['Spawn1']);
            }
        }
    }
}
</code></pre>
<h2 id="为了更加极致的脱发体验我们还可以编写其他模块达成目的">为了更加极致的脱发体验，我们还可以编写其他模块达成目的。</h2>
<blockquote>
<p>Now let's improve our code by taking the workers' behavior out into a separate module. Create a module called role.harvester with the help of the Modules section on the left of the script editor and define a run function inside the <code>module.exports</code> object, containing the creep behavior.</p>
</blockquote>
<p>除了<code>Main</code>之外的模块就像 C / C++ 中的头文件，供给<code>Main</code>调用。我们可以使用这个特性，编写一个专们描述收集能量的工人<code>Creep</code>的行为的模块。</p>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = {

    /** @param {Creep} creep **/
    run: function(creep) {
	    if(creep.carry.energy &lt; creep.carryCapacity) {
            var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0]);
            }
        }
        else {
            if(creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                creep.moveTo(Game.spawns['Spawn1']);
            }
        }
	}
};

module.exports = roleHarvester;
</code></pre>
<p>这份脚本描述了所有具有<code>Harvester</code>性质的<code>Creep</code>的工作流程，此处不再赘述。</p>
<p>那么现在，我们如何编写我们的<code>Main</code>来调用刚刚写的这些呢？</p>
<blockquote>
<p>Now you can rewrite the main module code, leaving only the loop and a call to your new module by the method <code>require('role.harvester')</code>.</p>
</blockquote>
<p>明显，只需要使用<code>require('role.harvester')</code>的语句，就可以达成与 C / C++ 中<code>#include &quot;role_harvester.hpp&quot;</code>一样的效果了。</p>
<blockquote>
<p>It's much better now!</p>
</blockquote>
<p>头发少多了！</p>
<blockquote>
<p>By adding new roles and modules to your creeps this way, you can control and manage the work of many creeps. In the next Tutorial section, we’ll develop a new creep role.</p>
</blockquote>
<p>通过给你的<code>creep</code>们添加新的角色和模块，你能控制并管理大量的<code>creeps</code>。下一步，我们要开发一个新的角色。</p>
<h2 id="升级房间控制器roomcontroller">升级房间控制器RoomController</h2>
<blockquote>
<p>In this Tutorial section we’ll talk about a key strategic object in your room: <code>Room Controller</code>. By controlling this invincible structure you can build facilities in the room. The higher the controller level, the more structures available to build.</p>
</blockquote>
<p>在设计这个新的角色之前，我们需要认识一个新东西，叫<code>Room Controller</code>。这个东西的等级决定了你能在你房间里面建造哪些结构。</p>
<blockquote>
<p>You will need a new worker creep to upgrade your controller level. Let's call it &quot;Upgrader1&quot;. In following sections we'll discuss how to create creeps automatically, but for now let's send a command manually to the console.</p>
</blockquote>
<p>为了给它升级，我们要造一个名为“Upgrader1”的新工人。</p>
<p>在以后的教程中我们会认识到如何自动生成<code>creeps</code>，不过这次，我们还是使用控制台吧。</p>
<p>Code:</p>
<pre><code class="language-javascript">Game.spawns['Spawn1'].spawnCreep( [WORK, CARRY, MOVE], 'Upgrader1' );
</code></pre>
<p>它具体生成了什么，想必不用多说了。</p>
<blockquote>
<p>Creep &quot;Upgrader1&quot; went to perform the same task as the harvester, but we don't want it to. We need to differentiate creep roles.</p>
</blockquote>
<p>目前它暂时还只能像<code>harvester</code>一样工作。不过，我们得干点什么让它与老前辈不一样。</p>
<blockquote>
<p>To do that, we need to utilize the memory property of each creep that allows writing custom information into the creep's &quot;memory&quot;. Let's do this to assign different roles to our creeps.</p>
<p>All your stored memory is accessible via the global Memory object. You can use it any way you like.</p>
</blockquote>
<p>我们使用<code>memory</code>来区分不同<code>creeps</code>各自的角色。实际上，我们可以往一个<code>creep</code>的“记忆”里面写任何东西来达成我们的任意目的。</p>
<p>Code:</p>
<pre><code class="language-javascript"> Game.creeps['Harvester1'].memory.role = 'harvester';
 Game.creeps['Upgrader1'].memory.role = 'upgrader';
</code></pre>
<blockquote>
<p>You can check your creeps' memory in either the creep information panel on the left or on the <code>Memory</code> tab.</p>
</blockquote>
<p>通过检查<code>Memory</code>面板，你可以确认“你的<code>Creeps</code>有没有深入贯彻你的思想”。</p>
<blockquote>
<p>Now let's define the behavior of the new creep. Both creeps should harvest energy, but the creep with the role harvester should bring it to the spawn, while the creep with the role upgrader should go to the Controller and apply the function <code>upgradeController</code> to it (you can get the Controller object with the help of the <code>Creep.room.controller</code> property).</p>
</blockquote>
<p>现在开工了，去设计新<code>creep</code>的行为。每一个<code>creep</code>都应当收集能量，但是<code>harvester</code>应该把能量送到<code>spawn</code>，而<code>upgrader</code>应该把能量送去<code>Room Controller</code>。</p>
<blockquote>
<p>In order to do this, we’ll create a new module called <code>role.upgrader</code>.</p>
</blockquote>
<p>为此，我们应当创建一个名为<code>role.upgrader</code>的<code>module</code>。</p>
<p>这用到了这些 API ：</p>
<blockquote>
<p>RoomObject.room<br>
Room.controller<br>
Creep.upgradeController</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleUpgrader = {

    /** @param {Creep} creep **/
    run: function(creep) {
	    if(creep.carry.energy == 0) {
            var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0]);
            }
        }
        else {
            if(creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {
                creep.moveTo(creep.room.controller);
            }
        }
	}
};

module.exports = roleUpgrader;
</code></pre>
<blockquote>
<p>In our main module, all creeps run the same role. We need to divide their behavior depending on the previously defined property <code>Creep.memory.role</code> by connecting the new module.</p>
</blockquote>
<p>目前我们的<code>main</code>模块中，所有<code>creeps</code>还被当作同一种角色处理。这是不行的：如果<code>main</code>说是一样的就是一样的，那我多没面子。所以</p>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleUpgrader = require('role.upgrader');

module.exports.loop = function () {

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
    }
}
</code></pre>
<p>听我的！听我的！听我的！</p>
<p>所以——</p>
<blockquote>
<p>Perfect, you have upgraded your Controller level!</p>
</blockquote>
<p><code>WA</code>，你的头发又少了几根！</p>
<blockquote>
<p><strong>Important</strong>: If you don’t upgrade your Controller within 20,000 game ticks, it loses one level. On reaching level 0, you will lose control over the room, and another player will be able to capture it freely. Make sure that at least one of your creeps regularly performs the function upgradeController.</p>
</blockquote>
<p>很重要的一点：如果你连续两万个<code>tick</code>不升级你的<code>Room Controller</code>，它就会降级。当它降到 0 级时，你就失去了这个房间的控制权。</p>
<h2 id="建造新结构">建造新结构</h2>
<blockquote>
<p>The Controller upgrade gives access to some new structures: walls, ramparts, and extensions. We’ll discuss walls and ramparts in the next Tutorial section, for now let’s talk about extensions.</p>
</blockquote>
<p>控制器一旦被升级，你就可以获取建造新结构的权限。这些结构主要有：地形墙、防御壁垒，以及扩展。我们教程的下一步会讲到地形墙和城墙，这次只会讲到扩展。</p>
<blockquote>
<p><strong>Extensions</strong> are required to build larger creeps. A creep with only one body part of one type works poorly. Giving it several <strong>WORKs</strong> will make him work proportionally faster.</p>
</blockquote>
<p>当你觉得你的<code>creeps</code>工作能力不行的时候，你想要往你的<code>creeps</code>身上插更多的身体部件。给他更强的工作能力。</p>
<blockquote>
<p>However, such a creep will be costly and a lone spawn can only contain 300 energy units. To build creeps costing over 300 energy units you need spawn extensions.</p>
</blockquote>
<p>可是，这样的<code>creeps</code>势必造成建造花费的提高。你的<code>spawn</code>只能容纳 300 单位的能量，是远远不够的。建造花费高于 300 单位能量的 <code>creeps</code>，就需要使用扩展。</p>
<blockquote>
<p>The second Controller level has 5 extensions available for you to build.This number increases with each new level.</p>
</blockquote>
<p>控制器等级 2 允许你建造 5 个扩展。而且这个数量还会随<code>Room Controller</code>等级不断提升。</p>
<blockquote>
<p>You can place extensions at any spot in your room, and a spawn can use them regardless of the distance. In this Tutorial we have already placed corresponding construction sites for your convenience.</p>
</blockquote>
<p>你可以将扩展放在房间的任何位置，而且一个<code>spawn</code>可以在任何距离使用它们。在教程中，我们已经将其放置在构造好的位置上。</p>
<blockquote>
<p>Let’s create a new creep whose purpose is to build structures. This process will be similar to the previous Tutorial sections. But this time let’s set <code>memory</code> for the new creep right in the method <code>Spawn.spawnCreep</code> by passing it in the third argument.</p>
</blockquote>
<p>我们建造一种新类型的<code>creep</code>来干这事。这种事情非常简单，我们之前都做得多了。不过，这次我们试试新的写法：使用第三个参数来传递内存值，免去重新设置内存的麻烦。</p>
<p>Code:</p>
<pre><code class="language-javascript">Game.spawns['Spawn1'].spawnCreep( [WORK, CARRY, MOVE], 'Builder1',
    { memory: { role: 'builder' } } );
</code></pre>
<p>在<code>builder</code>的定义未声明时，它将不会移动。</p>
<blockquote>
<p>As before, let’s move this role into a separate module role.builder. The building is carried out by applying the method <code>Creep.build</code> to the construction sites searchable by <code>Room.find(FIND_CONSTRUCTION_SITES)</code>. The structure requires energy which your creep can harvest on its own.</p>
</blockquote>
<p>像之前一样，我们需要设计一个新<code>module</code>。</p>
<p><code>Creep.build</code>和<code>Room.find(FIND_CONSTRUCTION_SITES)</code>两个方法可以帮到我们。</p>
<blockquote>
<p>To avoid having the creep run back and forth too often but make it deplete the cargo, let’s complicate our logic by creating a new Boolean variable <code>creep.memory.building</code> which will tell the creep when to switch tasks. We'll also add new <code>creep.say</code> call and <code>visualizePathStyle</code> option to the moveTo method to visualize the creep's intentions.</p>
</blockquote>
<p>为了避免它来回频繁运行耗尽计算资源，我们设计一个布尔值<code>creep.memory.building</code>来控制它究竟是挖矿还是建造。同时，我们打开可视化其移动路径的选项，并使用<code>creep.say</code>方法，来使它所处的模式可视化。</p>
<p>这次用到了这些 API :</p>
<blockquote>
<p>RoomObject.room<br>
Room.find<br>
Creep.build<br>
Creep.say</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleBuilder = {

    /** @param {Creep} creep **/
    run: function(creep) {

	    if(creep.memory.building &amp;&amp; creep.carry.energy == 0) {
            creep.memory.building = false;
            creep.say('🔄 harvest');
	    }
	    if(!creep.memory.building &amp;&amp; creep.carry.energy == creep.carryCapacity) {
	        creep.memory.building = true;
	        creep.say('🚧 build');
	    }

	    if(creep.memory.building) {
	        var targets = creep.room.find(FIND_CONSTRUCTION_SITES);
            if(targets.length) {
                if(creep.build(targets[0]) == ERR_NOT_IN_RANGE) {
                    creep.moveTo(targets[0], {visualizePathStyle: {stroke: '#ffffff'}});
                }
            }
	    }
	    else {
	        var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0], {visualizePathStyle: {stroke: '#ffaa00'}});
            }
	    }
	}
};

module.exports = roleBuilder;
</code></pre>
<blockquote>
<p>Let’s create a call of the new role in the main module and wait for the result.</p>
</blockquote>
<p>这样就可以了。不过我们还得改改主模块<code>Main</code></p>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleBuilder = require('role.builder');

module.exports.loop = function () {

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'builder') {
            roleBuilder.run(creep);
        }
    }
}
</code></pre>
<blockquote>
<p>Your extensions have been built. Now let’s learn to work with them.</p>
</blockquote>
<p>这样一来，扩展就修建好了。那么现在怎么让它们工作呢？</p>
<blockquote>
<p>Maintaining extensions requires you to teach your harvesters to carry energy not just to a spawn but also to extensions. To do this, you can either use the <code>Game.structures</code> object or search within the room with the help of <code>Room.find(FIND_STRUCTURES)</code>. In both cases, you will need to filter the list of items on the condition structure.<code>structureType == STRUCTURE_EXTENSION</code> (or, alternatively, <code>structure instanceof StructureExtension</code>) and also check them for energy load, as before.</p>
</blockquote>
<p>先要教会<code>havester</code>将收集的资源注入扩展。否则这些扩展用处不大。</p>
<p>所用 API：</p>
<blockquote>
<p>Game.structures<br>
Room.find<br>
StructureExtension</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = {

    /** @param {Creep} creep **/
    run: function(creep) {
	    if(creep.carry.energy &lt; creep.carryCapacity) {
            var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0], {visualizePathStyle: {stroke: '#ffaa00'}});
            }
        }
        else {
            var targets = creep.room.find(FIND_STRUCTURES, {
                    filter: (structure) =&gt; {
                        return (structure.structureType == STRUCTURE_EXTENSION || structure.structureType == STRUCTURE_SPAWN) &amp;&amp;
                            structure.energy &lt; structure.energyCapacity;
                    }
            });
            if(targets.length &gt; 0) {
                if(creep.transfer(targets[0], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                    creep.moveTo(targets[0], {visualizePathStyle: {stroke: '#ffffff'}});
                }
            }
        }
	}
};

module.exports = roleHarvester;
</code></pre>
<blockquote>
<p>To know the total amount of energy in the room, you can use the property <code>Room.energyAvailable</code>. Let’s add the output of this property into the console in order to track it during the filling of extensions.</p>
</blockquote>
<p>同时，为了得知房间能源总数，我们需要使用方法<code>Room.energyAvailable</code>，在<code>Main</code>中添加一个输出，让系统输出总能源信息到控制台。</p>
<p>可能用到的 API 文档是：</p>
<blockquote>
<p>Room.energyAvailable</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleBuilder = require('role.builder');

module.exports.loop = function () {

    for(var name in Game.rooms) {
        console.log('Room &quot;'+name+'&quot; has '+Game.rooms[name].energyAvailable+' energy');
    }

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'builder') {
            roleBuilder.run(creep);
        }
    }
}
</code></pre>
<blockquote>
<p>In total, we have 550 energy units in our spawn and extensions. It is enough to build a creep with the body [WORK,WORK,WORK,WORK,CARRY,MOVE,MOVE]. This creep will work 4 times faster than a regular worker creep. Its body is heavier, so we’ll add another MOVE to it. However, two parts are still not enough to move it at the speed of a small fast creep which would require 4xMOVEs or building a road.</p>
</blockquote>
<p>准备好造个大家伙了吗？具体有多大，见英文部分。（笑）</p>
<blockquote>
<p>Building this creep took energy from all storages and completely drained them.</p>
</blockquote>
<p>为了侍候这个大家伙，我们的所有能量存储器都耗尽了。</p>
<blockquote>
<p>As you can see on the right panel, this powerful creep harvests 8 energy units per tick. A few such creeps can completely drain an energy source before it refills thus giving your colony a maximum energy boost.</p>
</blockquote>
<p>不过当你看到它的面板时，你会觉得这是非常值得的。它能够在 1 <code>Tick</code> 中采集 8 单位能量，给予你极大的能源支持。</p>
<blockquote>
<p>Hence, by upgrading your Controller, constructing new extensions and more powerful creeps, you considerably improve the effectiveness of your colony work. Also, by replacing a lot of small creeps with fewer large ones, you save CPU resources on controlling them which is an important prerequisite to play in the online mode.</p>
</blockquote>
<p>可见，升级控制器，建造新扩展和更多强大的<code>Creeps</code>，能够提高工作效率，节省下CPU时间。值得一提，为了避免有玩家使用死循环卡系统，对于每一个玩家的代码，系统都有一个CPU时间限制，如果你的程序运行超出了CPU时间，则会被强制打断，<code>continue</code>到下一次循环中。当然，购买订阅甚至终身无限CPU时间的巨佬可以无视CPU时间限制。</p>
<h2 id="全自动生产新creeps">全自动生产新Creeps</h2>
<blockquote>
<p>Until now, we have created new creeps directly in the console. It’s not a good idea to do it constantly since the very idea of Screeps is making your colony control itself. You will do well if you teach your spawn to produce creeps in the room on its own.</p>
</blockquote>
<p>直到现在，我们都在使用控制台新建<code>creep</code>。由于真实游戏中所有<code>creeps</code>有 1500 <code>ticks</code>的生命限制，你必须要这并不是一个能让你一直挂着机摸鱼的好办法。我们需要找出让机器给我们自动创建<code>creep</code>的办法。</p>
<blockquote>
<p>This is a rather complicated topic and many players spend months perfecting and refining their auto-spawning code. But let’s try at least something simple and master some basic principles to start with.</p>
</blockquote>
<p>为了改进自己的自动创建器，很多玩家花费了几个月的时间。不过我们用不着那么麻烦——这只是个教程，搞个够用的就行了。</p>
<blockquote>
<p>You will have to create new creeps when old ones die from age or some other reasons. Since there are no events in the game to report death of a particular creep, the easiest way is to just count the number of required creeps, and if it becomes less than a defined value, to start spawning.</p>
</blockquote>
<p>由于游戏不提供<code>creeps</code>死亡时的全局广播，最简单的确认是否需要新建<code>creeps</code>的方法就是……emmm，数数。没错，数现在你自己有了多少<code>creeps</code>，而实际上需要多少。如果不够，就造。</p>
<blockquote>
<p>There are several ways to count the number of creeps of the required type. One of them is filtering <code>Game.creeps</code> with the help of the <code>_.filter</code> function and using the role in their memory. Let’s try to do that and bring the number of creeps into the console.</p>
</blockquote>
<p>有很多种方式让你数你需要的类型的<code>creeps</code>有多少个。最好用的就是在过滤器成员函数<code>filter</code>协助下的<code>Game.creeps</code>对象。在主模块中，我们通过过滤它们的<code>memory</code>来判断它们是否是适合的类型，同时，唔，数数。</p>
<p>可能用到的 API ：</p>
<blockquote>
<p>Game.creeps<br>
lodash.filter</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleUpgrader = require('role.upgrader');

module.exports.loop = function () {

    var harvesters = _.filter(Game.creeps, (creep) =&gt; creep.memory.role == 'harvester');
    console.log('Harvesters: ' + harvesters.length);

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
    }
}
</code></pre>
<blockquote>
<p>Let’s say we want to have at least two harvesters at any time. The easiest way to achieve this is to run <code>StructureSpawn.spawnCreep</code> each time we discover it’s less than this number. You may not define its name (it will be given automatically in this case), but don’t forget to define the needed role.</p>
</blockquote>
<p>我们现在同时需要两个<code>harvester</code>。最方便来保持这个状态的方式就是让主模块在每次发现<code>harvester</code>数量不够的时候执行<code>StructureSpawn.spawnCreep</code>。在这个方法的帮助下，我们甚至不需要给它们命名（我们能写出自动命名用的方法），只要别忘记定义角色行为就行。</p>
<blockquote>
<p>We may also add some new <code>RoomVisual</code> call in order to visualize what creep is being spawned.</p>
</blockquote>
<p>我们还能添加一些新的<code>RoomVisual</code>调用来可视化哪一种<code>creep</code>正在被生产出来。</p>
<p>这里可能帮到忙的 API :</p>
<blockquote>
<p>StructureSpawn.spawnCreep<br>
RoomVisual</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleUpgrader = require('role.upgrader');

module.exports.loop = function () {

    var harvesters = _.filter(Game.creeps, (creep) =&gt; creep.memory.role == 'harvester');
    console.log('Harvesters: ' + harvesters.length);

    if(harvesters.length &lt; 2) {
        var newName = 'Harvester' + Game.time;
        console.log('Spawning new harvester: ' + newName);
        Game.spawns['Spawn1'].spawnCreep([WORK,CARRY,MOVE], newName, 
            {memory: {role: 'harvester'}});        
    }
    
    if(Game.spawns['Spawn1'].spawning) { 
        var spawningCreep = Game.creeps[Game.spawns['Spawn1'].spawning.name];
        Game.spawns['Spawn1'].room.visual.text(
            '🛠️' + spawningCreep.memory.role,
            Game.spawns['Spawn1'].pos.x + 1, 
            Game.spawns['Spawn1'].pos.y, 
            {align: 'left', opacity: 0.8});
    }

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
    }
}
</code></pre>
<blockquote>
<p>Now let’s try to emulate a situation when one of our harvesters dies. You can now give the command suicide to the creep via the console or its properties panel on the right.</p>
</blockquote>
<p>我们现在模拟一下当我们的<code>harvesters</code>中的一位永远地离开我们的情况……嗯，用某个方法让它当场挂掉就行。</p>
<p>可能用到的 API ：</p>
<blockquote>
<p>Creep.suicide</p>
</blockquote>
<p>（有没有感到一种深深的恶意）</p>
<pre><code class="language-javascript">Game.creeps['Harvester1'].suicide()
</code></pre>
<blockquote>
<p>As you can see from the console, after we lacked one harvester, the spawn instantly started building a new one with a new name.</p>
</blockquote>
<p>从控制台中可以看到，每当我们缺乏<code>harvester</code>时，我们的<code>spawn</code>就会自动地造一个具备新名字的<code>harvester</code>出来。</p>
<blockquote>
<p>An important point here is that the memory of dead creeps is not erased but kept for later reuse. If you create creeps with random names each time it may lead to memory overflow, so you should clear it in the beginning of each tick (prior to the creep creation code).</p>
</blockquote>
<p>另外的一个重点，就是你的<code>creeps</code>凉的时候不会清空它所占用的内存空间。一个随机名字的<code>creep</code>挂了之后，可能会导致内存泄漏。为了应对这个情况，你需要修改主模块，在每个<code>tick</code>的开始时进行内存垃圾回收，它的优先级甚至高于生产建造新<code>creep</code>的指令。</p>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleUpgrader = require('role.upgrader');

module.exports.loop = function () {

    for(var name in Memory.creeps) {
        if(!Game.creeps[name]) {
            delete Memory.creeps[name];
            console.log('Clearing non-existing creep memory:', name);
        }
    }

    var harvesters = _.filter(Game.creeps, (creep) =&gt; creep.memory.role == 'harvester');
    console.log('Harvesters: ' + harvesters.length);

    if(harvesters.length &lt; 2) {
        var newName = 'Harvester' + Game.time;
        console.log('Spawning new harvester: ' + newName);
        Game.spawns['Spawn1'].spawnCreep([WORK,CARRY,MOVE], newName, 
            {memory: {role: 'harvester'}});
    }
    
    if(Game.spawns['Spawn1'].spawning) { 
        var spawningCreep = Game.creeps[Game.spawns['Spawn1'].spawning.name];
        Game.spawns['Spawn1'].room.visual.text(
            '🛠️' + spawningCreep.memory.role,
            Game.spawns['Spawn1'].pos.x + 1, 
            Game.spawns['Spawn1'].pos.y, 
            {align: 'left', opacity: 0.8});
    }

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
    }
}
</code></pre>
<blockquote>
<p>Now the memory of the deceased is relegated to oblivion which saves us resources.</p>
</blockquote>
<p>我很高兴你节省下了一点内存。<s>一直节省内存，你就能存下钱来买生发剂。</s></p>
<blockquote>
<p>Apart from creating new creeps after the death of old ones, there is another way to maintain the needed number of creeps: the method <code>StructureSpawn.renewCreep</code>. Creep aging is disabled in the Tutorial, so we recommend that you familiarize yourself with it on your own.</p>
</blockquote>
<p>实际上，除了让旧的<code>creep</code>老化死掉时创建新的<code>creep</code>，你还能使用<code>StructureSpawn.renewCreep</code>方法解决问题。老化在教程中被禁用，所以建议自行熟悉。</p>
<p>与之相关的 API：</p>
<blockquote>
<p>StructureSpawn.renewCreep</p>
</blockquote>
<h2 id="守卫你的房间">守卫你的房间</h2>
<blockquote>
<p>The world of Screeps is not the safest place. Other players may have claims on your territory. Besides, your room may be raided by neutral NPC creeps occasionally. So you ought to think about your colony defense in order to develop it successfully.</p>
</blockquote>
<p>Screeps中，玩家可以互相攻击，还会产生敌对NPC。所以，我们需要开发防御脚本。</p>
<blockquote>
<p>This hostile creep has come from the left entry and attacked your colony. It’s good that we have walls to restrain it temporarily. But they will fall sooner or later, so we need to deal with the problem.</p>
</blockquote>
<p>入侵者已经从左侧入口进入并已经在攻击你的领地。我们有墙可以防御，但是这些墙迟早会倒下。所以，我们应该积极应对这一问题。</p>
<blockquote>
<p>The surest way to fend off an attack is using the room Safe Mode. In safe mode, no other creep will be able to use any harmful methods in the room (but you’ll still be able to defend against strangers).</p>
</blockquote>
<p>目前最可靠的防御方式，是使用房间安全模式<code>room Safe Mode</code>。在安全模式时限内，敌人的所有有害方法都会被锁死。这是对于陌生来访者最好的防御方式。</p>
<blockquote>
<p>The safe mode is activated via the room controller which should have activations available to use. Let’s spend one activation to turn it on in our room.</p>
</blockquote>
<p>我们需要通过房间控制器才能打开房间安全模式。让我们试试。<s>(试试就逝世)</s></p>
<p>这个操作所用的方法涉及 API：</p>
<blockquote>
<p>StructureController.activateSafeMode</p>
</blockquote>
<p>这种即时性强的代码使用控制台来执行：</p>
<p>Code:</p>
<pre><code class="language-javascript">Game.spawns['Spawn1'].room.controller.activateSafeMode();
</code></pre>
<blockquote>
<p>As you can see, the enemy creep stopped attacking the wall – its harmful methods are blocked. We recommend that you activate safe mode when your defenses fail.</p>
</blockquote>
<p>可见，该敌对<code>Creep</code>停止攻击墙壁，一切有害行为均已锁定。我们建议你在防守失败时激活房间安全模式。</p>
<blockquote>
<p>Now let’s cleanse the room from unwanted guests.</p>
</blockquote>
<p>那么现在，让我们清除不受欢迎的入侵者。</p>
<blockquote>
<p>Towers are the easiest way to actively defend a room. They use energy and can be targeted at any creep in a room to attack or heal it. The effect depends on the distance between the tower and the target.</p>
</blockquote>
<p>塔是积极活跃防御房间的优秀方式。它们消耗能量，并以<code>Creep</code>为目标进行维护或攻击。效果取决于塔离目标的距离</p>
<blockquote>
<p>To start with, let’s lay a foundation for our new tower. You can set any place you wish inside the walls and place the construction site there with the help of the button “Construct” on the upper panel.</p>
</blockquote>
<p>首先，我们为建造新塔打好基础。你能够使用<code>Construct</code>视图在墙内任意位置建造一座塔。</p>
<p>API 调用如下：</p>
<blockquote>
<p>StructureTower<br>
Room.createConstructionSite</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">Game.spawns['Spawn1'].room.createConstructionSite( 23, 22, STRUCTURE_TOWER );
</code></pre>
<blockquote>
<p>A tower uses energy, so let’s set the harvester role to bring energy to the tower along with other structures. To do this, you need to add the constant STRUCTURE_TOWER to the filter of structures your harvester is aimed at.</p>
</blockquote>
<p>塔消耗能源。所以，我们需要更改<code>Harvester</code>的模块，使该角色将能源带给塔及其他结构。</p>
<pre><code class="language-javascript">var roleHarvester = {

    /** @param {Creep} creep **/
    run: function(creep) {
	    if(creep.carry.energy &lt; creep.carryCapacity) {
            var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0], {visualizePathStyle: {stroke: '#ffaa00'}});
            }
        }
        else {
            var targets = creep.room.find(FIND_STRUCTURES, {
                    filter: (structure) =&gt; {
                        return (structure.structureType == STRUCTURE_EXTENSION ||
                                structure.structureType == STRUCTURE_SPAWN ||
                                structure.structureType == STRUCTURE_TOWER) &amp;&amp; structure.energy &lt; structure.energyCapacity;
                    }
            });
            if(targets.length &gt; 0) {
                if(creep.transfer(targets[0], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                    creep.moveTo(targets[0], {visualizePathStyle: {stroke: '#ffffff'}});
                }
            }
        }
	}
};

module.exports = roleHarvester;
</code></pre>
<blockquote>
<p>Excellent, your tower is ready to use!</p>
</blockquote>
<p>众所周知，塔消耗头发而产生某种效果……嗯。</p>
<blockquote>
<p>Like a creep, a tower has several similar methods: attack, heal, and repair. Each action spends 10 energy units. We need to use attack on the closest enemy creep upon its discovery. Remember that distance is vital: the effect can be several times stronger with the same energy cost!</p>
</blockquote>
<p>就像一个<code>Creep</code>，塔可以攻击、给<code>Creep</code>回复生命、维修建筑物。每一项方法的执行均消耗10单位能量。我们现在对它进行设定，使它攻击最近的敌人。记住，它的效果取决于离目标的距离！</p>
<blockquote>
<p>To get the tower object directly you can use its ID from the right panel and the method <code>Game.getObjectById</code>.</p>
</blockquote>
<p>我们可以通过右边的面板以及 API 方法<code>Game.getObjectById</code>来操作直接获取塔对象。</p>
<p>这回用到的 API 不少：</p>
<blockquote>
<p>Game.getObjectById<br>
RoomObject.pos<br>
RoomPosition.findClosestByRange<br>
StructureTower.attack</p>
</blockquote>
<p>这样修改主模块：</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleUpgrader = require('role.upgrader');
var roleBuilder = require('role.builder');

module.exports.loop = function () {

    var tower = Game.getObjectById('d629245dccf490c645352fb6');
    if(tower) {
        var closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
        if(closestHostile) {
            tower.attack(closestHostile);
        }
    }

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
        if(creep.memory.role == 'builder') {
            roleBuilder.run(creep);
        }
    }
}
</code></pre>
<p>可见，这次塔的 ID 为：<code>d629245dccf490c645352fb6</code>。</p>
<blockquote>
<p>The enemy creep is eliminated and our colony can breathe easy. However, the invader has damaged some walls during the brief attack. You’d better set up auto-repair.</p>
</blockquote>
<p>敌人已经被消灭，但是它留下的伤害还没有被磨灭。敌对目标攻击了你的墙，因此你需要维护它，以应对下一次入侵。实际上，实现一个自动修复是很好的解决方案。</p>
<blockquote>
<p>Damaged structures can be repaired by both creeps and towers. Let’s try to use a tower for that. We’ll need the method <code>repair</code>. You will also need the method <code>Room.find</code> and a filter to locate the damaged walls.</p>
</blockquote>
<p>受伤的结构，能够被<code>creeps</code>和<code>towers</code>修复。让我们试试我们这座塔的<code>repair</code>方法。在实际的实现过程中，我们使用<code>Room.find</code>方法配合过滤器找到墙上受到损伤的位置。</p>
<p>API：</p>
<blockquote>
<p>Room.find<br>
StructureTower.repair</p>
</blockquote>
<p>主模块代码：</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleUpgrader = require('role.upgrader');
var roleBuilder = require('role.builder');

module.exports.loop = function () {

    var tower = Game.getObjectById('d629245dccf490c645352fb6');
    if(tower) {
        var closestDamagedStructure = tower.pos.findClosestByRange(FIND_STRUCTURES, {
            filter: (structure) =&gt; structure.hits &lt; structure.hitsMax
        });
        if(closestDamagedStructure) {
            tower.repair(closestDamagedStructure);
        }

        var closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
        if(closestHostile) {
            tower.attack(closestHostile);
        }
    }

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
        if(creep.memory.role == 'builder') {
            roleBuilder.run(creep);
        }
    }
}
</code></pre>
<blockquote>
<p>All the damage from the attack has been repaired</p>
</blockquote>
<p>我们注意到了你发量见底了。</p>
<blockquote>
<p>Congratulations, you have completed the Tutorial! Now you have enough knowledge and code to start playing in the online mode. Choose your room, found a colony, and set out on your own quest for domination in the world of Screeps!</p>
</blockquote>
<p>所以教程结束了。恭喜你，你已经练成了进入秃头服务器的能力。选择你的房间，建立你的领地，跟我们一起脱发叭！</p>
<p>在这些地方，你能继续找到你们需要的东西：</p>
<blockquote>
<p>Documentation<br>
Community forums<br>
Slack chat</p>
</blockquote>
<blockquote>
<p>Have fun scripting!</p>
</blockquote>
<p>在脱发中寻找快乐！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 最小生成树 / Kruskal算法]]></title>
        <id>https://malachiten.github.io/post/bi-ji-zui-xiao-sheng-cheng-shu-kruskal-suan-fa</id>
        <link href="https://malachiten.github.io/post/bi-ji-zui-xiao-sheng-cheng-shu-kruskal-suan-fa">
        </link>
        <updated>2019-10-08T07:10:37.000Z</updated>
        <summary type="html"><![CDATA[<p>OI常用算法，最小生成树。</p>
]]></summary>
        <content type="html"><![CDATA[<p>OI常用算法，最小生成树。</p>
<!-- more -->
<h2 id="最小生成树是什么">最小生成树是什么</h2>
<p>对于一个这样的连通图：</p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/10/08/ufgOiR.png" alt="graphFull.png"></figure>
<p>表格形式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">起点</th>
<th style="text-align:center">终点</th>
<th style="text-align:center">权值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">9</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">10</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">11</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">7</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
<p>它的极小连通子图，可以表现为一棵树的形式，即为最小生成树(如下图所示)。</p>
<figure data-type="image" tabindex="2"><img src="https://s2.ax1x.com/2019/10/08/uf2tyT.png" alt="graphMini.png"></figure>
<p>看不出这是一棵树？看这个。</p>
<figure data-type="image" tabindex="3"><img src="https://s2.ax1x.com/2019/10/08/ufRjKK.png" alt="trueTree.png"></figure>
<p>表格形式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">起点</th>
<th style="text-align:center">终点</th>
<th style="text-align:center">权值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">9</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<p><s>看，是不是特别小？</s></p>
<p><s>你说是，就是吧</s></p>
<h2 id="我们怎么生成一个最小生成树呢">我们怎么生成一个最小生成树呢？</h2>
<p>此时，我们可以采用多种算法。</p>
<p>其中较好理解的是 <em>Kruskal</em> 算法。</p>
<h3 id="kruskal算法">Kruskal算法</h3>
<p>这种算法的核心是，先建立一个结构体<code>Edge</code>用来描述边：</p>
<pre><code class="language-cpp">struct Edge{
    int u,v,w;
    Edge(){}//数组用默认构造函数
    Edge(int t1,int t2,int t3){
        u=t1;
        v=t2;
        w=t3;
    }
    bool operator &lt; (const Edge &amp;other) const{
        return w&lt;other.w;
    }
}edges[10005];
</code></pre>
<p>其中的<code>u</code>代表了这条边的起点，<code>v</code>代表了这条边的终点，<code>w</code>代表的则是这条边的边权。<strong>重载构造函数是为了以后存边方便</strong>，而<strong>重载运算符则是为了边权排序方便</strong>。数组就是边的<strong>实例</strong>，用来进行存储。</p>
<p>我们通过<strong>并查集连边</strong>的方式，将所有的顶点<strong>依权值次序</strong>相连。所以，我们需要实现一个并查集：</p>
<pre><code class="language-cpp">int fa[10005];//集
int find(int x){//查
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
bool merge(int x,int y){//并
    int a=find(x),b=find(y);
    if(a!=b){
        fa[a]=b;
        return 1;//成功，记录
    }else{
        return 0;//失败，放弃
    }
}
</code></pre>
<p>这里可能产生疑问：并查集实现中的<code>merge</code>函数不应该只是个像这样的<code>void</code>类型的“存储过程”吗？</p>
<pre><code class="language-cpp">void merge(int x,int y){
    fa[find(x)]=find(y);
}
</code></pre>
<p>为什么要给一个<code>bool</code>类型的返回值呢？</p>
<p>原因就在于之后的处理当中，纯粹贪心地连接<strong>权值最小</strong>的边，会发生“连接出<strong>环</strong>”的情况。明显可以看出：</p>
<blockquote>
<p>出现有环的图不成为树。</p>
</blockquote>
<p>为了避免这种情况的发生，我们需要检查即将连接的这一条边的两个顶点<strong>是否已经被连接在一个并查集中</strong>。此处<code>merge</code>函数的这种写法，就实现了<strong>判断是否已经连接</strong>和<strong>告知程序主体部分连接状况</strong>的功能。显而易见，返回0代表<strong>已经连过了</strong>，本次连接失败，需要跳下一条边；返回1表示<strong>之前没有连接过</strong>，现在连边成功。</p>
<p>那么我们可以得出我们的主函数:</p>
<pre><code class="language-cpp">int main(){
    int n/*边数*/,m/*点数*/;
    cin&gt;&gt;n&gt;&gt;m;//初始化
    //存边
    for(int i=1;i&lt;=n;i++){
        int t1,t2,t3;
        cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;
        edges[i]=Edge(t1,t2,t3);
    }
    //排序
    sort(edges+1,edges+n+1);
    //生成树
    for(int i=1;i&lt;=m-1;i++){
        if(!merge(edges[i].u,edges[i].v)){
            m++;
        }
    }
}
</code></pre>
<p>对于“生成树”这一环节中的循环退出条件<code>i&lt;=m-1</code>，可能也会产生一些疑惑。这里用到了一个定理：</p>
<blockquote>
<p>将一个图生成树，则其总边数为总点数-1。</p>
</blockquote>
<p>同时，我们发现，每次遇到连接中出现环的情况，<code>merge</code>都不会进行连接，而是报告<code>main</code>将变量<code>m</code>的值增加1。这是因为，我们跳过了这条边，就<strong>一定要从后方加一条边来补偿</strong>。否则最终边数每次跳边都减少1，无法生成完整的树。</p>
<p>这就是算法的基础实现了。它没有输出，但是它能够承接多数的最小生成树任务：设置一个变量<code>ans</code>用来作为最终的输出结果。如果要输出边数，则只需每次连接成功时<code>ans++</code>;如果要输出总权值，则在连接成功时<code>ans+=edges[i].w</code>即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++面向对象 / 封装 继承 多态]]></title>
        <id>https://malachiten.github.io/post/cmian-xiang-dui-xiang-feng-zhuang-ji-cheng-duo-tai</id>
        <link href="https://malachiten.github.io/post/cmian-xiang-dui-xiang-feng-zhuang-ji-cheng-duo-tai">
        </link>
        <updated>2019-10-07T12:27:41.000Z</updated>
        <summary type="html"><![CDATA[<p>有一说，称 C++ 即为 C with STL。还有一说，C++ 为 C with OOP。OOP 的核心，就是封装，继承，与多态。</p>
]]></summary>
        <content type="html"><![CDATA[<p>有一说，称 C++ 即为 C with STL。还有一说，C++ 为 C with OOP。OOP 的核心，就是封装，继承，与多态。</p>
<!-- more -->
<h2 id="引入">引入</h2>
<p>我们以一个形象的例子来介绍这几个特性。</p>
<h3 id="一-显而易见的故事">一 显而易见的故事</h3>
<p>作为一个<s>沉迷学习的好孩子</s>，你对于<s>如何藏匿你的手机</s>得心应手。</p>
<p>在你的房间中，有一张<strong>床</strong>、一张<strong>书桌</strong>一个<strong>大大的衣柜</strong>，还有一个<strong>书柜</strong>。</p>
<p><strong>你的学习用品均储存在书柜中</strong>。</p>
<p><strong>生活用品均储存在衣柜中</strong>。</p>
<p>你的_家长_为了检查你的学习，会经常<strong>翻你的书柜和书桌</strong>。</p>
<p>而我们现在假设他们完全不管你的日常生活，因而<strong>几乎</strong>不管你的衣柜和床板底下。</p>
<p>同时，你的_家长_还自诩于重视你的隐私，因此他们还将<strong>从来不翻你自己身上的包</strong>“引以为傲”，作为与其他家长的谈资。</p>
<p>那么我们必定可以得出一个结论</p>
<blockquote>
<p>你的手机<strong>必定放在你的衣柜、床板底下或者自己的身上</strong>。这能够保证你的手机一直安全。</p>
</blockquote>
<p>这是一个显而易见的结论。然而让我们将情况变得更复杂一点：</p>
<p>你的同学们中，有一些_好朋友_会到你的家中玩。一得到难得的关上自己房间门的机会，你就拿出手机跟_朋友_一起玩。_朋友_临走时，他<strong>询问你藏匿手机的技巧</strong>，于是你<strong>告诉了他你的大部分技巧</strong>。</p>
<p>不过，因为朋友的不同，你告诉不同的朋友不同的技巧。你把手机放在身上的事，却因为你不保证_朋友A_的家长是否对他搜身，而提示他不要藏在身上。_朋友B_家更注重孩子隐私，因此从不进他的房间，则可以告诉他全部的技巧。而他也不必提心吊胆地藏在身上。</p>
<p>于是，你的_朋友A_具有了这样的藏匿手机技巧：</p>
<blockquote>
<p>把手机放在衣柜里面或者床板下面。</p>
</blockquote>
<p>_朋友B_变成这样：</p>
<blockquote>
<p>把手机放在书桌、书柜、衣柜或者床上。</p>
</blockquote>
<p>同时我们还发现，你需要悄悄玩手机，但是对于手机的频繁转移，并没有什么需求。不过你还是告诉了他们几个技巧供他们选择。</p>
<p>后来你的手机被发现了，不过你的朋友们将你的技能发扬光大，<s>代代相传</s>。(大雾)</p>
<h3 id="二-抽象这个故事">二 抽象这个故事</h3>
<p>之前也说过：经过抽象,就能研究事物的本质与规律。</p>
<p>抽象的一般方法：</p>
<blockquote>
<ol>
<li>忽略事物中与当前问题或目标无关的特点,集中考虑有关。</li>
<li>忽略非本质的特征,抽取本质性特征</li>
<li>从个体把握一般,从事物把握本质</li>
</ol>
</blockquote>
<p>由此，这个典例事件，我们可以这样抽象：</p>
<p>将你的房间看做一个<strong>类</strong>( <em>class</em> )。这个类有如下的特性：</p>
<ul>
<li>其中的“书柜”和“书桌”是<strong>任由外部访问</strong>的成员。这样的成员，称为<code>public</code>成员。</li>
<li>“床”和“衣柜”禁止<strong>除了你的朋友以外的人访问</strong>。这样的称为<code>protected</code>成员。</li>
<li>“自己身上”禁止<strong>一切外部访问</strong>。这样的则称为<code>private</code>成员。</li>
</ul>
<p>通过严格的将这些容器给<strong>封装</strong>起来，你严格地控制了外部对于你的成员的访问，保证了你的手机的安全。同时，你的朋友们只需要知道找你(接口)就可以跟你一起玩手机，而并不需要亲自翻箱倒柜(了解接口内部的实现)。</p>
<p>而你的朋友们回家之后就在他的房间上<strong>继承</strong>了你房间的特性。这时，可以将你自己的房间称为他们继承的“基类”。相对而言，他们的房间就变成了“派生类”。</p>
<p>_A_的房间具有了<strong>除了跟你身上以外的一切特性</strong>。他也具有了你的<code>public</code>和<code>protected</code>属性，只有<code>private</code>属性不能被继承下来。这样的继承方式，被称为<code>public</code>继承。</p>
<p>_B_的房间中，手机则也可以放在相同的地方。不过，显然，他的书柜和书桌禁止<strong>除了他的朋友以外的人访问</strong>。因而，你的<code>public</code>成员变成了他的<code>protected</code>成员。这样的继承方式，则称为<code>protected</code>继承。这种继承方式中，基类除了<code>private</code>之外的成员都会变成派生类的<code>protected</code>成员。</p>
<p>除此之外，还有<code>private</code>继承，用于<s>跟Vim一起帮助乌干达的可怜儿童</s>。所幸你没有这样的一个朋友。<s>不然我就打不完代码了</s>显然可见，对于这样的人而言，他家的空间都是他不为他人访问的的<code>private</code>成员。他也没有必要去继承你的<code>private</code>。</p>
<p>与此同时，他们继承了你的转移手机方法。你的转移手机方法因为没有必要而并不能执行(因此是一个虚拟函数)，而你的朋友们将其重载而发展开来。这就是由基类提供纯粹的接口而派生类通过重载赋予其实际作用的<strong>多态</strong>特性。</p>
<h2 id="语法">语法</h2>
<p>对于刚刚的例子，我们可以将其写成一个例程来体现封装和继承的语法。</p>
<pre><code class="language-cpp">class your_home{
    private:
        void play_phone(){}//玩手机
        int body;
    protected:
        virtual void transfer_phone()=0;//不需要的转移
        int bed,wardrobe;
    public:
        int desk,bookcase;
};
//其实这个描述不太形象——你的类并不能实例化，因为其包含了一个纯虚函数transfer_phone()，是一个纯虚类/抽象类。
class A_home:public your_home{
    private:
        void play_phone(){};//玩手机
    protected:
        void transfer_phone(){}//实际的转移手机
};
class B_home:protected your_home{
    private:
        void play_phone(){};//玩手机
        void transfer_phone(){}//转移手机
};
class C_home:private your_home{
    private:
        void play_phone(){};//玩手机
        //没有必要转移手机了。
};
</code></pre>
<h2 id="总结">总结</h2>
<p>通过这个形象地例子，我们了解到了类的运用。</p>
<ul>
<li>“封装”——将成员封装在对象<code>public</code>、<code>protected</code>、<code>private</code>属性之中。这些对象的开发者和使用者分离，使用者只需要接入对象提供的<code>public</code>接口，而不用了解到它们的内部实现。这样也实现了对于它们的保护。</li>
<li>“继承”——派生类可以继承基类的属性。在<code>public</code>继承中，派生类会将基类的<code>public</code>属性作为自己的<code>public</code>属性，也可以用使用派生类<code>public</code>成员函数的方式来引用基类中的成员。而在<code>protected</code>继承中，派生类将基类的<code>public</code>属性降级为<code>protected</code>属性，<code>protected</code>保持不变，并废弃<code>private</code>类型属性。<code>private</code>继承只能将基类的<code>public</code>属性变成自己的<code>private</code>属性，将<code>protected</code>和<code>private</code>全部废弃。</li>
<li>“多态”——基类能够定义一个空的接口，下放到派生类来通过重载的方式实现。这对于抽象有极大的益处。不过要注意的是，如果要实现彻底抽象，就需要明确通过定义一个纯虚函数<code>virtual typename functionName()=0</code>。这样会使这个基类变成一个不能被实例化的抽象类(纯虚类)，只有基类将其重载然后实例化基类才能得到体现。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 编译原理 / 引论(1) [Ongoing]]]></title>
        <id>https://malachiten.github.io/post/bi-ji-bian-yi-yuan-li-yin-lun</id>
        <link href="https://malachiten.github.io/post/bi-ji-bian-yi-yuan-li-yin-lun">
        </link>
        <updated>2019-10-06T03:05:29.000Z</updated>
        <summary type="html"><![CDATA[<p>毕竟是神书，不容易懂。<s>所以咕了</s></p>
]]></summary>
        <content type="html"><![CDATA[<p>毕竟是神书，不容易懂。<s>所以咕了</s></p>
<!-- more -->
<h2 id="编译程序">编译程序</h2>
<p>编译程序特指<strong>将高级语言源程序翻译成低级语言目标程序</strong>的翻译程序.</p>
<h3 id="翻译程序">&quot;翻译程序&quot;</h3>
<p>将一种语言的程序(源语言程序)翻译成另一种语言的程序(目标语言程序).</p>
<h3 id="解释程序">&quot;解释程序&quot;</h3>
<p>不产生目标程序,将源语言程序逐条取出语句并立即执行的程序.这是和编译程序不一样的.</p>
<h3 id="编译程序的种类">编译程序的种类</h3>
<ol>
<li>帮助找出错误的 诊断编译程序</li>
<li>提供优化编译开关的 优化编译程序</li>
<li>交叉编译程序 编译程序</li>
</ol>
<h3 id="宿主机与目标机">宿主机与目标机</h3>
<p>宿主机:编译程序运行的平台.</p>
<p>目标机:目标代码程序运行的平台.</p>
<h3 id="可变目标的编译程序">可变目标的编译程序</h3>
<p>能够通过不同编译开关产生不同的目标代码而运行于不同的目标机上的编译程序,称为可变目标的编译程序.</p>
<h3 id="设计语言的流程">设计语言的流程</h3>
<p>设计程序设计语言</p>
<ol>
<li>设计程序设计语言的规范</li>
<li>设计其编译程序</li>
</ol>
<h2 id="抽象的思维">抽象的思维</h2>
<p>经过抽象,就能研究事物的本质与规律.</p>
<h3 id="引入">引入</h3>
<ol>
<li>忽略与当前问题或目标无关的,集中考虑有关的</li>
<li>忽略非本质的特征,抽取本质性特征</li>
<li>从个体把握一般,从事物把握本质</li>
</ol>
<blockquote>
<p>毕加索的《牛》的变化.<br>
伦敦的地铁图的变化.(各个城市的地铁地图)</p>
</blockquote>
<h3 id="图灵机">图灵机</h3>
<p>通过一条无限长的<strong>纸带</strong>,一个<strong>读写头</strong>,一个控制读写头的<strong>规则</strong>,和一个<strong>状态寄存器</strong>,来完成各项的计算.有了这个模型,就可以研究计算的过程的本质.</p>
<blockquote>
<p>对&quot;可计算&quot;和&quot;算法&quot;的定义:&quot;如果一个过程<strong>能被图灵机执行</strong>,则其可计算/为一个算法&quot;</p>
</blockquote>
<h3 id="编译程序设计中的抽象">编译程序设计中的抽象</h3>
<p>抽象在编译程序设计中是普遍的.如:形式文法,有限自动机......</p>
<h4 id="自动化的思维">自动化的思维</h4>
<p>把事物抽象之后,把抽象的事物在计算机上实现.是将计算思维物化的过程.</p>
<p>程序的本质是用自动化的思维解决问题.</p>
<p>自动化的思想,可以指导编译程序设计,并提高开发的效率.(词法分析,语法分析,有限自动机)</p>
<h2 id="分解的思维">分解的思维</h2>
<p>即模块化的思想.</p>
<p>先将问题模块化,分解为各个子问题,如果子问题足够小能够解决则解决,能继续分解则继续分解(将编译过程分解为不同的阶段,先生成中间代码,再生成目标代码)</p>
<p>实际上,递归就是这样的问题.实际上,递归求解的子问题的结构与父问题相同.只是规模减小了.在编译的过程中,广泛的运用了递归.(应用:递归下降分析,语法制导翻译,基于树的遍历的属性计算)</p>
<h2 id="权衡-折中">权衡 / 折中</h2>
<p>对于理论上的设计,由于实际限制条件的存在,实际设计会与理论设计有差别,即需要这种折中的思维.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 欧拉路 [Ongoing]]]></title>
        <id>https://malachiten.github.io/post/bi-ji-ou-la-lu</id>
        <link href="https://malachiten.github.io/post/bi-ji-ou-la-lu">
        </link>
        <updated>2019-10-04T09:06:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是欧拉路">什么是欧拉路</h2>
<p>欧拉路是指从图中任意一个点开始到图中任意一个点结束的路径，并且图中每条边通过的且只通过一次。</p>
<h2 id="怎样判断有欧拉路存在">怎样判断有欧拉路存在</h2>
<h3 id="无向图">无向图</h3>
<p>图一定要联通，且:</p>
<p>所有顶点度数均为偶数，则存在欧拉回路</p>
<p>两个点度数为奇数，其余的为偶数，则存在欧拉通路</p>
<h3 id="有向图">有向图</h3>
<p>图联通依然是一个必要条件。且:</p>
<p>每个点的入度等于出度，则存在欧拉回路(任意一点有度的点都可以作为起点)</p>
<p>除某两点外，所有入度等于出度。这两点中一点的出度比入度大，另一点的出度比入度小，则存在欧拉通路。出度大者是起点，入度大者是终点。</p>
<h2 id="怎样找到欧拉路">怎样找到欧拉路</h2>
<p>之前的内容大致只是用于<strong>发现该题目应该使用欧拉回路的方法求解</strong>。</p>
<p>以下寻找方法均建立在假设图中存在欧拉回路的基础上，其自身并不能判断图是否满足条件。</p>
<p>从一个非孤立的点开始<em>DFS</em>，点可以重复经过，每次任意走一条边，并将这条边从邻接表中删去。走到目标终点(找到欧拉通路)，或者走回起点(找到欧拉回路)。</p>
]]></content>
    </entry>
</feed>