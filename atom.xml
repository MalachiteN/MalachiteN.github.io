<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://malachiten.github.io</id>
    <title>Malachite</title>
    <updated>2019-10-01T09:03:51.288Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://malachiten.github.io"/>
    <link rel="self" href="https://malachiten.github.io/atom.xml"/>
    <subtitle>夕焼けの中に吸い込まれて消えてった</subtitle>
    <logo>https://malachiten.github.io/images/avatar.png</logo>
    <icon>https://malachiten.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Malachite</rights>
    <entry>
        <title type="html"><![CDATA[笔记 : 图的存储 / 邻接表-链式前向星]]></title>
        <id>https://malachiten.github.io/post/bi-ji-lin-jie-biao-lian-shi-qian-xiang-xing</id>
        <link href="https://malachiten.github.io/post/bi-ji-lin-jie-biao-lian-shi-qian-xiang-xing">
        </link>
        <updated>2019-10-01T00:52:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="引入">引入</h2>
<p>一般而言采用这种朴素的存储方式( <strong>邻接矩阵</strong> )，读写图时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，存图空间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-cpp">int graph[maxn][maxn],n;
cin&gt;&gt;n;
for(int i=1;i&lt;=n;i++){
    cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;
    graph[t1][t2]=t3;
}
</code></pre>
<p>但是当图特别大的时候，这种操作会直接爆掉内存然后<code>Memory Limit Execeed</code></p>
<p>所以，需要进行优化</p>
<p>于是，巨佬就搞出了链式前向星( <strong>时间空间均最优的存图数据结构</strong> )</p>
<p>Talk is cheap,show me the code:</p>
<pre><code class="language-cpp">int head[maxn],esize;
struct edge{
    int target,value,next;
    edge(){}
    edge(int x,int y,int z){
        target=x;
        value=y;
        next=z;
    }
}edges[maxn];
void clear(){
    memset(head,-1,sizeof head);
    esize=0;
}
</code></pre>
<h2 id="解析">解析</h2>
<h3 id="结构体-edge">结构体 edge</h3>
<p>显然这个结构体描述的是图中的<strong>边</strong>。它具有三个成员变量: <code>target</code>,<code>value</code>,<code>next</code></p>
<ul>
<li><code>target</code>表示了这条边的终点。</li>
<li><code>value</code>表示了这条边的边权。</li>
<li><code>next</code>表示了与这条边起点相同的上一条边的编号。</li>
</ul>
<h3 id="数组-edges">数组 edges</h3>
<p>显然，这个数组用于存储边，然而其中的边是按照读入顺序存储，对于有序遍历图是乱序的。要想顺序读取则需要由一定的规范进行。</p>
<p>描述这个规范的，就是用于中途遍历的<code>edge</code>型对象的<code>next</code>成员，以及用于查找遍历起点的<code>head</code>数组。</p>
<h3 id="数组-head">数组 head</h3>
<p>这个数组描述了“以点<code>n</code>为起点，那么应该在找到<code>edge[head[n]]</code>，从这个<strong>真实起点</strong>开始遍历”。换句话说，这个数组就是用于描述起点的。</p>
<p>而实际上，它存储的是“从点<code>n</code>出发的存入链式前向星的最后一条边”在<code>edge[]</code>中的位置。</p>
<h2 id="实例">实例</h2>
<p>考虑这样一张图:</p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/10/01/uNB6AO.png" alt="graph"></figure>
<p>可以文字表示为:</p>
<pre><code>1 3 2
1 2 4
2 3 1
2 4 5
</code></pre>
<p>这样一来，</p>
<p><code>head[1]</code>中的数据是2，<code>head[2]</code>的数据是4</p>
<p><code>edges[1]</code>中<code>target</code>的值是3，<code>value</code>存的是2，<code>next</code> 中存的是-1(表示没有前驱了)</p>
<p><code>edges[2]</code>中<code>target</code>值是2，<code>value</code>存的是4，<code>next</code>值是1(表示前驱是<code>edges[1]</code>)</p>
<p><code>edges[3]</code>中<code>target</code>值就是3，<code>value</code>存的是1，<code>next</code>则是-1(无前驱)</p>
<p><code>edges[4]</code>中<code>target</code>是4，<code>value</code>存的是5，<code>next</code>是3(前驱为<code>edges[3]</code>)</p>
<h2 id="存储过程">存储过程</h2>
<p>一共n条边，具体到每一步读入，应该是这样的:</p>
<pre><code class="language-cpp">for(int i=1;i&lt;=n;++i){
	int t1,t2,t3;
	cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;
    edges[i]=edge(t2,t3,head[t1]);
	head[t1]=i;
}
</code></pre>
<p>通过一直更新<code>head[i]</code>的值，来达到链式的作用。实际上，邻接表就是个链表。</p>
<h2 id="遍历过程">遍历过程</h2>
<p>这个例程目的为预计将读入的原封不动输出。实际操作时应当在遍历到目标之后进行某种操作，比如跑最短路</p>
<pre><code class="language-cpp">for(int i=1;i&lt;=m;++i){
	for(int j=head[i];~j.next;j=edges[j].next){
		cout&lt;&lt;i&lt;&lt;' '&lt;&lt;edges[k].target&lt;&lt;' '&lt;&lt;edges[k].value&lt;&lt;endl;
	}
}
</code></pre>
<p>因为我们以<code>j.next==-1</code>为链表上一条链的终止点标记，所以使用<code>~j.next</code>来作为循环终止条件。</p>
<h2 id="总结">总结</h2>
<p>一个整体的代码:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

int head[maxn],esize;

struct edge{
    int target,value,next;
    edge(){}
    edge(int x,int y,int z){
        target=x;
        value=y;
        next=z;
    }
}edges[maxn];

void clear(){
    memset(head,-1,sizeof head);
    esize=0;
}

int main(){
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i){
	    int t1,t2,t3;
	    cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;
        edges[i]=edge(t2,t3,head[t1]);
	    head[t1]=i;
    }
    for(int i=1;i&lt;=m;++i){
	    for(int j=head[i];~j.next;j=edges[j].next){
		    cout&lt;&lt;i&lt;&lt;' '&lt;&lt;edges[k].target&lt;&lt;' '&lt;&lt;edges[k].value&lt;&lt;endl;
	    }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[预处理器命令 #define / 宏定义 实用性说明]]></title>
        <id>https://malachiten.github.io/post/yu-chu-li-qi-ming-ling-define-hong-ding-yi-shi-yong-xing-shuo-ming</id>
        <link href="https://malachiten.github.io/post/yu-chu-li-qi-ming-ling-define-hong-ding-yi-shi-yong-xing-shuo-ming">
        </link>
        <updated>2019-09-27T09:04:09.000Z</updated>
        <content type="html"><![CDATA[<p>注明:本文大量引用、摘抄、改编自 <a href="https://blog.csdn.net/king110108/article/details/80728010">king110108的CSDN博客</a>。若重复引用本文，请别忘了添加对以上博客的引用。</p>
<p>正如引用源标题(《#define用法集锦(非常全)》)所言，该文对<code>#define</code>的用法总结的极为全面，但是对于每种用法的详细介绍较少。因此，本文主要进行的是对该文章内容的总结和重排。</p>
<h2 id="0宏定义是什么">0.宏定义是什么</h2>
<p>define，顾名思义，表示的是进行某些定义。这种定义被称为宏(marco)。</p>
<p>宏定义是一种传递给预处理器的命令。通过提前告诉预处理器本文件中定义的宏，能够使预处理器按照定义的方式自动替换文本中的字符串(这种过程一般称为“宏展开”)，从而大大<strong>简化</strong>代码。</p>
<h2 id="1如何定义宏-取消宏">1.如何定义宏、取消宏</h2>
<p>定义一个宏:</p>
<pre><code class="language-cpp">#define [MacroName)] [MacroValue]
</code></pre>
<p>定义之后，除非存在取消指令，否则对于文件中所有出现该MacroName的地方，就替换为对应的MacroValue。</p>
<p>取消一个宏:</p>
<pre><code class="language-cpp">#undef [MacroName]
</code></pre>
<p>取消之后，除非再次定义，否则对于该MacroName不再进行替换。<s>(形象地理解就是这个MarcoName被预处理器甩了)</s></p>
<h2 id="2定义常量">2.定义常量</h2>
<p>例1:</p>
<pre><code class="language-cpp">#define MAXN 2147483647
</code></pre>
<p>本例将当前文件中所有字符串&quot;MAXN&quot;全部替换成了<code>INT_MAX</code>的值<code>2147483647</code>。这就是简单的使用#define定义常量的方式。<strong>(依然建议使用const关键字来声明常量，以免引起不可预知的问题。)</strong></p>
<h2 id="3定义数据类型">3.定义数据类型</h2>
<p>很多时候，很像定义常量时，我们想<s>少打几个字而实现相同的效果</s>咳咳，使数据修改方便，我们也想使较长的数据类型名称被一个自定义的关键字代表。这时我们可以自定义一个宏来简化数据类型。</p>
<p>例:</p>
<pre><code class="language-cpp">#define ull unsigned long long
</code></pre>
<p>本例将当前文件中所有字符串&quot;ull&quot;全部替换成了<code>unsigned long long</code>。这可以使一个较长的类型名称变得非常短，从而简化代码。<strong>(跟上面一样，通常情况下依然建议使用专门的关键字typedef来简化指定类型的名称，如果发生了不可预知的问题可别怪我啊)</strong></p>
<p>所谓“不可预知的问题”就像下面这个：</p>
<pre><code class="language-cpp">#define pin (int*);
pin a,b;
</code></pre>
<p>a是<code>int</code>型指针类型，而b是<code>int</code>型常规变量。而我们期望的其实是使a和b均为<code>int</code>型指针(<code>int*</code>)。</p>
<p>要使a和b就都是<code>int</code>型指针，我们只能使用<code>typedef</code>了。这也使我们注意到一点：我们在定义的时候，一定要养成一个良好的习惯，建议所有的层次都要加括号。</p>
<p>不过，在某些特殊情形下，比如开发机与目标机的操作系统及硬件存在巨大差异~~(比如你硬要用Core i9的机子给上世纪的80486写程序)~~的时候，由于编译器、操作系统对代码中数据类型的理解大不相同，<code>typedef</code>完全无法满足我们的需求(如果强行通过<code>typedef</code>改变编译器数据类型的定义，似乎会直接报出重复定义的错误)。这时，我们反而建议使用<code>#define</code>。</p>
<p>例:</p>
<pre><code class="language-cpp">typedef  unsigned char      boolean;     /* Boolean value type. */
typedef  unsigned long int  uint32;      /* Unsigned 32 bit value */
typedef  unsigned short     uint16;      /* Unsigned 16 bit value */
typedef  unsigned char      uint8;       /* Unsigned 8  bit value */
typedef  signed long int    int32;       /* Signed 32 bit value */
typedef  signed short       int16;       /* Signed 16 bit value */
typedef  signed char        int8;        /* Signed 8  bit value */
</code></pre>
<p>对于另外一些数据类型，即使是非常情况下，依然不建议使用哦……</p>
<p>就是这些啦</p>
<pre><code class="language-cpp">typedef  unsigned char     byte;         /* Unsigned 8  bit value type. */
typedef  unsigned short    word;         /* Unsinged 16 bit value type. */
typedef  unsigned long     dword;        /* Unsigned 32 bit value type. */
typedef  unsigned char     uint1;        /* Unsigned 8  bit value type. */
typedef  unsigned short    uint2;        /* Unsigned 16 bit value type. */
typedef  unsigned long     uint4;        /* Unsigned 32 bit value type. */
typedef  signed char       int1;         /* Signed 8  bit value type. */
typedef  signed short      int2;         /* Signed 16 bit value type. */
typedef  long int          int4;         /* Signed 32 bit value type. */
typedef  signed long       sint31;       /* Signed 32 bit value */
typedef  signed short      sint15;       /* Signed 16 bit value */
typedef  signed char       sint7;        /* Signed 8  bit value */
</code></pre>
<h2 id="4条件编译">4.条件编译</h2>
<p>例:</p>
<pre><code class="language-cpp">#define debug
#ifdef debug
//do something
#else
//do something
#endif
#ifndef debug
//do something 
#else
//do something
#endif
</code></pre>
<p>本例中，提到了这几种预处理器命令:本文主要介绍的<code>#define</code>,以及依附于它而存在的命令<code>#ifdef</code>、<code>ifndef</code>、<code>else</code>、<code>endif</code>。这些命令，一般被称为“<strong>条件编译开关</strong>”。<s>(虽然我觉得叫预处理器条件分歧之类的更好听……)</s></p>
<p><code>ifdef</code>,展开缩写为：if define，表示<strong>如果定义了</strong>某个宏，则编译从此处开始直到一个<code>endif</code>标记的位置的代码。如果没有定义，则这一部分的代码不会被编译。<s>(就像被注释掉了一样)</s></p>
<p><code>ifndef</code>,展开缩写为：if not define，表示<strong>若未定义</strong>某个宏，则编译从此处开始直到一个<code>endif</code>标记的位置的代码。如果没有定义，则不会编译这些代码。</p>
<p><code>else</code>,表示否则，用于对上述两个预处理器条件命令的“条件表达式”(有没有定义)进行“取反”，只能用于这两个命令作为开头、<code>endif</code>命令作为结尾的区间内。换言之，现有一个区间，从<code>#ifdef test</code>到<code>#endif</code>，其中具备了一个<code>else</code>。那么，如果本程序在该区间开始前定义了宏<code>test</code>，那么，它将编译从<code>#ifdef test</code>后到<code>#else</code>前的部分。如果没有定义该宏，则将编译从<code>else</code>后到<code>endif</code>前的部分。</p>
<p><code>endif</code>,则是表示对于<code>ifdef</code>、<code>ifndef</code>的界限的命令。<code>endif</code>标记之后的所有代码，<strong>不受</strong>之前标记的<code>ifdef</code>、<code>else</code>和<code>ifndef</code>影响。</p>
<p>在大规模的开发过程中，特别是跨平台和系统的软件里，define最重要的功能是条件编译。就像这样，define可以用于跨平台:</p>
<pre><code class="language-cpp">#ifdef WINDOWS
//do something
#endif
#ifdef LINUX
//do something
#endif
</code></pre>
<p>这样就能通过在文件开始时写上<code>#define WINDOWS</code>、<code>#define LINUX</code>而简单地在Windows和Linux中编译不同的代码，而不需要麻烦地寻找哪些需要在Windows下编译，哪些需要在Linux下编译，然后在需要编译出对应平台的程序时注释掉另一部分……<s>(人生苦短，C++可能真比不上Python)</s></p>
<h2 id="5函数式的宏定义">5.函数式的宏定义</h2>
<p>这是一个<strong>宏定义的说明文章不可或缺的部分</strong>哦！敲黑板看重点啦！</p>
<p>~~众所周知，宏定义的知识博大精深。~~它甚至可以当做一个类似函数的东西来用！</p>
<p>例：</p>
<pre><code class="language-cpp">#define Add(a,b) (a)+(b);
</code></pre>
<p>这<strong>看起来似乎</strong>是一个实现将形式参数a与b相加并返回其值的函数。</p>
<p>我们观察这个宏定义，发现其中的结构其实是这样的：</p>
<pre><code class="language-cpp">#define [FunctionalMarcoName]([Argument1],[Argument2],...) [FunctionalMarcoValue]
</code></pre>
<p>同时要注意，FunctionalMarcoValue中对于形式参数的引用，应该使用小括号“()”将它们括起来，否则这些参数变成替换上去的字符串之后是否产生歧义将无法保证！</p>
<p>正因为如此上面这样写，与下面这个函数的效果其实也有差别哦！这些歧义也使函数式宏定义在某些意义下不安全。</p>
<pre><code class="language-cpp">int Add(int a,int b){
    return a+b;
}
</code></pre>
<p>我们考虑这样一个情况：<code>c*Add(a,b)*d</code>。</p>
<p>我们将会发现，正常来说，这行程序的逻辑是：先将a与b相加，将它们的和与c、d连乘。</p>
<p>可是很<s>不</s>明显的是，预处理器将会<s>像个憨憨一样</s>忠实地按照宏定义的定义，将程序文本中的<code>Add(a,b)</code>全给换成<code>a+b</code>！这样一来……它将会计算<code>c*a+b*d</code>的值！它的逻辑将会变成，分别将a与c、b与d相乘，然后将两个乘积相加！这是我们不期望的。一定要警惕！因此，我们应该使用这样写法才能保证安全：</p>
<pre><code class="language-cpp">#define Add(a,b) ((a)+(b))
</code></pre>
<p>宏定义为了防止错误而使用小括号的例子：</p>
<pre><code class="language-cpp">#define DUMP_WRITE(addr,nr) {memcpy(bufp,addr,nr); bufp += nr;}//BUG
#define DO(a,b) do{a+b;a++;}while(0)//应该使用的定义
</code></pre>
<p>当这样使用时：</p>
<pre><code class="language-cpp">if(addr)DUMP_WRITE(addr,nr);
else do_somethong_else();
</code></pre>
<p>宏将展开，程序变为：</p>
<pre><code class="language-cpp">if(addr){memcpy(bufp,addr,nr); bufp += nr;};
else do_something_else();
</code></pre>
<p>gcc在碰到else前面的“;”时就认为if语句已经结束，因而后面的else不在if语句中。而**采用do{} while(0)的定义，在任何情况下都没有问题。**而改为 <code>#define DO(a,b) do{a+b;a++;}while(0)</code> 的定义则在任何情况下都不会出错。</p>
<p>在<strong>避免危险情况出现的前提下</strong>，某些宏定义能够在极短的空间内完成极为复杂的操作！</p>
<p>比如，我们已经知道，宏是用来<strong>在原文本中替换字符串</strong>的。</p>
<p>因此，宏定义为我们提供了这几种操作：<code>#</code>、<code>@#</code>和<code>##</code>。先看一个例子：</p>
<pre><code class="language-cpp">#define paster(n) printf(&quot;token&quot;#n&quot;=%d\n&quot;,token##n)
</code></pre>
<p>我们了解：</p>
<p><code>#</code>用来将宏定义的形式参数转换为“作为字符串(string/char数组)数据类型存在的”字符串，并用于替换。</p>
<p><code>##</code>则用于将转换成“程序文本意义上的”字符串与其他程序文本相连接。</p>
<p>于是我们可以知道：</p>
<p><strong>设token1=1,token2=2,……,tokenn=n</strong></p>
<ul>
<li><code>paster(1)</code>等效于<code>printf(&quot;token1=%d\n&quot;,token1);</code>，输出&quot;token1=1&quot;,</li>
<li><code>paster(2)</code>等效于<code>printf(&quot;token2=%d\n&quot;,token2);</code>，输出&quot;token2=2&quot;;</li>
<li>……</li>
<li><code>paster(n)</code>等效于<code>printf(&quot;tokenn=%d\n&quot;,tokenn);</code>，输出&quot;tokenn=n&quot;。</li>
</ul>
<p>不过我们必须知道，这些处理是在预处理器中完成的！不要希望使用预处理器命令在程序运行过程中临时声明常规变量！不过这种写法不受影响：</p>
<pre><code class="language-cpp">#define newInt(n) int* (n)=new int(##n))
</code></pre>
<p>上例没有提到的写法是<code>@#</code>。它用于将后面的参数变为<strong>单字符(char)字符数据类型意义上的</strong>字符串。</p>
<p>原文作者通过引用另一个作者hustli的文章，提供了几个少见的例子用来阐明这些操作之间的差别,不过日常开发中几乎不会出现，看看就好吧：</p>
<pre><code class="language-cpp">#define A(x) T_##x
#define B（x) #@x
#define C（x) #x
</code></pre>
<p>我们假设：x=1，则有：</p>
<ul>
<li>A(1)等效于程序文本T_1</li>
<li>B(1)等效于字符'1'</li>
<li>C(1)等效于字符串&quot;1&quot;</li>
</ul>
<p><code>#define</code>的特殊操作就这些，很简单吧~</p>
<p>下一个知识点！就像一般函数都包含换行，写成函数形式的宏定义也能包含换行哦。</p>
<p>很出名的MFC官方例：</p>
<pre><code class="language-cpp">#define MACRO(arg1, arg2) do { /
/* declarations */ /
stmt1; /
stmt2; /
/* ... */ /
} while(0) /* (no trailing ; ) */
</code></pre>
<p>可见，要在每一个换行的时候加上一个&quot;/&quot;。这种写法其实非常麻烦，已经违背了实用性说明的原则，因此我其实不建议使用这种写法。<s>(同时希望大家都学着压行)</s></p>
<p>引用源的作者也这样认为。他在原文中对这个例子的评价是：&quot;非常的经典，虽然让人看了恶心&quot;。</p>
<p>对于函数式的宏定义，就说到这里了。下面是几个常用的方便例子：</p>
<ul>
<li>得到指定地址上的一个字节或字</li>
</ul>
<pre><code class="language-cpp">#define  MEM_B(x) (*((byte*)(x)))
#define  MEM_W(x) (*((word*)(x)))
</code></pre>
<ul>
<li>求最大值和最小值</li>
</ul>
<pre><code class="language-cpp">#define  MAX( x, y ) ( ((x) &gt; (y)) ? (x) : (y) )
#define  MIN( x, y ) ( ((x) &lt; (y)) ? (x) : (y) )
</code></pre>
<ul>
<li>得到一个field在结构体(struct)中的偏移量</li>
</ul>
<pre><code class="language-cpp">#define FPOS( type, field ) /
/*lint -e545 */ ( (dword) &amp;(( type *) 0)-&gt; field ) /*lint +e545 */
</code></pre>
<ul>
<li>得到一个结构体中field所占用的字节数</li>
</ul>
<pre><code class="language-cpp">#define FSIZ( type, field ) sizeof( ((type *) 0)-&gt;field )
</code></pre>
<ul>
<li>按照LSB格式把两个字节转化为一个Word</li>
</ul>
<pre><code class="language-cpp">#define  FLIPW( ray ) ( (((word) (ray)[0]) * 256) + (ray)[1] )
</code></pre>
<ul>
<li>按照LSB格式把一个Word转化为两个字节</li>
</ul>
<pre><code class="language-cpp">#define  FLOPW( ray, val ) /
  (ray)[0] = ((val) / 256); /
  (ray)[1] = ((val) &amp; 0xFF)
</code></pre>
<ul>
<li>得到一个变量的地址（word宽度）</li>
</ul>
<pre><code class="language-cpp">#define  B_PTR( var )  ( (byte *) (void *) &amp;(var) )
#define  W_PTR( var )  ( (word *) (void *) &amp;(var) )
</code></pre>
<ul>
<li>得到一个字的高位和低位字节</li>
</ul>
<pre><code class="language-cpp">#define  WORD_LO(xxx)  ((byte) ((word)(xxx) &amp; 255))
#define  WORD_HI(xxx)  ((byte) ((word)(xxx) &gt;&gt; 8))
</code></pre>
<ul>
<li>返回一个比X大的最接近的8的倍数</li>
</ul>
<pre><code class="language-cpp">#define RND8( x )    ((((x) + 7) / 8 ) * 8 )
</code></pre>
<ul>
<li>将一个字母转换为大写</li>
</ul>
<pre><code class="language-cpp">#define  UPCASE( c ) ( ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') ? ((c) - 0x20) : (c) )
</code></pre>
<ul>
<li>判断字符是不是10进值的数字</li>
</ul>
<pre><code class="language-cpp">#define  DECCHK( c ) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')
</code></pre>
<ul>
<li>判断字符是不是16进值的数字</li>
</ul>
<pre><code class="language-cpp">#define  HEXCHK( c ) (  ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9') ||/
                        ((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'F') ||/
                        ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'f') )
</code></pre>
<ul>
<li>防止溢出的一个方法</li>
</ul>
<pre><code class="language-cpp">#define  INC_SAT( val )  (val = ((val)+1 &gt; (val)) ? (val)+1 : (val))
</code></pre>
<ul>
<li>返回数组元素的个数</li>
</ul>
<pre><code class="language-cpp">#define  ARR_SIZE( a )  ( sizeof( (a) ) / sizeof( (a[0]) ) )
</code></pre>
<ul>
<li>返回一个无符号数n尾的值</li>
</ul>
<pre><code class="language-cpp">#define MOD_BY_POWER_OF_TWO( val, mod_by ) /
                           ( (dword)(val) &amp; (dword)((mod_by)-1) )
</code></pre>
<ul>
<li>对于IO空间映射在存储空间的结构，输入输出处理</li>
</ul>
<pre><code class="language-cpp">#define inp(port)         (*((volatile byte *) (port)))
#define inpw(port)        (*((volatile word *) (port)))
#define inpdw(port)       (*((volatile dword *)(port)))
#define outp(port, val)   (*((volatile byte *) (port)) = ((byte) (val)))
#define outpw(port, val)  (*((volatile word *) (port)) = ((word) (val)))
#define outpdw(port, val) (*((volatile dword *) (port)) = ((dword) (val)))
</code></pre>
<ul>
<li>使用一些宏跟踪调试</li>
</ul>
<p>这一部分原文说明得相当清晰，因此直接引用原文。</p>
<p>ANSI标准说明了五个预定义的宏名。它们是：</p>
<pre><code class="language-cpp">__LINE__
__FILE__

//__LINE__ 及 __FILE__ 宏指示，#line指令可以改变它的值，简单的讲，编译时，它们包含程序的当前行数和文件名。

__DATE__

//__DATE__ 宏指令含有形式为月/日/年的串,表示源文件被翻译到代码时的日期。

__TIME__

//__TIME__ 宏指令包含程序编译的时间。时间用字符串表示，其形式为：分：秒

__STDC__

//__STDC__ 宏指令的意义是编译时定义的。一般来讲，如果__STDC__已经定义，编译器将仅接受不包含任何非标准扩展的标准C/C++代码。如果实现是标准的,则宏__STDC__含有十进制常量1。如果它含有任何其它数,则实现是非标准的。
</code></pre>
<p>C++中还定义了 <code>__cplusplus</code>。__cplusplus 与标准c++一致的编译器把它定义为一个包含至少6为的数值。与标准c++不一致的编译器将使用具有5位或更少的数值。</p>
<p>如果编译器不是标准的,则可能仅支持以上宏名中的几个,或根本不支持。记住编译程序也许还提供其它预定义的宏名。</p>
<p>为了调试，我们还可以定义宏,例如:</p>
<p>当定义了_DEBUG,输出数据信息和所在文件所在行</p>
<pre><code class="language-cpp">#ifdef _DEBUG
#define DEBUGMSG(msg,date) printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_)
#else
#define DEBUGMSG(msg,date)
#endif
</code></pre>
<p>原文引用结束(看这个引用区域，像不像<code>ifdef</code>和<code>endif</code>呢?)</p>
<h2 id="6避免重复包含-重复定义">6.避免重复包含、重复定义</h2>
<p>由于头文件包含可以嵌套，那么 * / *.cpp / *.h / *.hpp 文件就有可能多次包含同一个头文件，就可能出现重复定义的错误，而且极难查出。<s>(我一个题的解题代码因为写反true和false这样极为???的问题，调了一个小时，如果我在数个文件中发生重复定义，怕是一年都调不出来……)</s></p>
<p>不过好在，有了<strong>条件编译开关</strong>，就可以避免重复包含(重复定义)啦！</p>
<p>例:</p>
<pre><code class="language-cpp">#ifndef __headerfileXXX__
#define __headerfileXXX__
//file
#endif
</code></pre>
<p>这样，我们就能保证即使头文件被多次包含，也不会导致里面的内容被多次定义啦！</p>
<h2 id="7总结">7.总结</h2>
<p>写了这么多，感觉也把<code>#define</code>这个预处理器命令整理的比较明白了吧。</p>
<p>同时，引用源也提供了大量的模板供给大家参考。感谢king110108巨佬的博客！</p>
<p>最后附上<code>#define</code>的英文原版定义，供给有兴趣的同学们参考：</p>
<pre><code>The define Directive
You can use the #define directive to give a meaningful name to a constant in your program. The two forms of the syntax are:
Syntax
define identifier token-stringopt
define identifier[( identifieropt, ... , identifieropt )] token-stringopt
</code></pre>
<p>那么，下篇博客再见咯！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 搜索 / DFS BFS ID A*]]></title>
        <id>https://malachiten.github.io/post/bi-ji-sou-suo</id>
        <link href="https://malachiten.github.io/post/bi-ji-sou-suo">
        </link>
        <updated>2019-09-27T06:08:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dfs-深度优先搜索">DFS / 深度优先搜索</h2>
<h3 id="寻找最优解这是最常用的方法">寻找最优解(这是最常用的方法)</h3>
<p>这种情况下,一般会有很多种不同的状态</p>
<pre><code class="language-cpp">void dfs(int cur){
    if(!check(cur)){
        //可行性剪枝。如果预测到某个状态以下的所有答案走到底均不可行，则剪去剩余搜索子树
        return;
    }
    if(cur无法比当前最优解更优)){
        //最优性剪枝。如果预测到某个状态下所有答案不能比当前ans更优，则剪去剩余搜索子树
        return;
    }
    标记当前状态已访问;
    存储当前状态的信息或者更新答案;//这一步在答案比较简单时可放到dfs的参数里面避免手动回溯
    for(枚举当前状态所有决策){
        dfs(next(cur));
    }
    //回溯:
    消除当前状态存储的信息并将其对答案的影响消去;
    将当前状态标记为未访问;
    //因为DFS算法必须通过回溯消去影响，因此又称为回溯算法
}
</code></pre>
<h3 id="寻找可行解">寻找可行解</h3>
<pre><code class="language-cpp">bool dfs(int cur){
    if(!check(cur)){
        //可行性剪枝
        return 0;
    }
    将当前状态标记为已访问;
    if(goal(cur)){
        记录可行解;
        return 1;
    }
    for(枚举当前状态的所有决策){
        if(dfs(next(cur))){
            return 1;
        }
    }
    将当前状态标记为未访问;
    return 0;
}
</code></pre>
<h3 id="dfs例题-luogu-p3154-cqoi2009循环赛">DFS例题: Luogu P3154 [CQOI2009]循环赛</h3>
<p>解析(<strong>转载自:<a href="http://www.cnblogs.com/autsky-jadek/">AutSky_JadeK的博客</a></strong>)</p>
<p><strong>思路</strong></p>
<ul>
<li>dfs+剪枝*4</li>
<li>1.只枚举一半的比赛，另一半直接得出</li>
<li>2.处理前缀和，若大于目标得分则剪枝</li>
<li>3.前缀和加上若接下来全胜的得分 仍小于目标得分，则剪枝。</li>
<li>4.枚举到每个人的最后一场比赛时直接用目标得分-前缀和 计算出最后一场的应得分。</li>
</ul>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
const int f[]={3,1,0,0};
int n,a[9],ans,Pre[9];
void dfs(int x,int y)
{
    if(Pre[x]&gt;a[x])return;
    if(Pre[x]+(n-y+1)*3&lt;a[x])return;
    if(x==n){ans++;return;}
    if(y==n)
      {
          int tmp=a[x]-Pre[x];
          if(tmp==2)return;
          Pre[y]+=f[tmp];
        dfs(x+1,x+2);
          Pre[y]-=f[tmp];
      }else{
    Pre[x]+=3;dfs(x,y+1);Pre[x]-=3;
    Pre[y]+=3;dfs(x,y+1);Pre[y]-=3;
    Pre[x]++;Pre[y]++;dfs(x,y+1);Pre[x]--;Pre[y]--;}
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
      scanf(&quot;%d&quot;,&amp;a[i]);
    dfs(1,2);
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
</code></pre>
<h3 id="dfs-枚举子集">DFS 枚举子集</h3>
<pre><code class="language-cpp">void dfs(int cur){
    if(cur){
        将cur添加进当前集合;
    }
    对子集的处理;
    for(int i=cur+1;i&lt;=n;i++){
        dfs(i);
    }
}
</code></pre>
<p>该算法处理集合 {1,2,3,4} 的过程如下:</p>
<pre><code>1
1 2
1 2 3
1 2 3 4
2
2 3
2 3 4
3
3 4
4
</code></pre>
<p>可见，该算法是<strong>将过程全部输出</strong>的DFS。</p>
<h2 id="bfs-广度优先搜索">BFS / 广度优先搜索</h2>
<pre><code class="language-cpp">void bfs(){
    q.push(st_start);
    vis[st_start]=true;
    while(!q.empty()){
        st U=q.front();
        for(i in next(st)){
            if(!vis[i]&amp;&amp;check(i)){
                vis[i]=true;
                i.d=st.d+1;
                if(goal(i)){
                    对最终状态的处理;
                    return;
                }
                q.push(i);
            }
        }
        q.pop();
    }
}
</code></pre>
<h2 id="id-dfs-迭代加深-深度优先搜索">ID DFS / 迭代加深 深度优先搜索</h2>
<p><strong>首先深度优先搜索k层，若没有找到可行解，再深度优先搜索k+1层，直到找到可行解为止</strong>。由于深度是从小到大逐渐增加的，所以当搜索到结果时可以保证搜索深度是最小的。这也是迭代加深搜索在一部分情况下可以代替广度优先搜索的原因。</p>
<h2 id="id-a-迭代加深-启发式搜索">ID A* / 迭代加深 启发式搜索</h2>
<pre><code class="language-cpp">void dfs(int cur){
    if(!check(cur)){
        //可行性剪枝。如果预测到某个状态以下的所有答案走到底均不可行，则剪去剩余搜索子树
        return;
    }
    if(/*估价函数*/cantBetter(cur)){
        //最优性剪枝。如果预测到某个状态下所有答案不能比当前ans更优，则剪去剩余搜索子树
        return;
    }
    标记当前状态已访问;
    存储当前状态的信息或者更新答案;//这一步在答案比较简单时可放到dfs的参数里面避免手动回溯
    for(枚举当前状态所有决策){
        dfs(next(cur));
    }
    //回溯:
    消除当前状态存储的信息并将其对答案的影响消去;
    将当前状态标记为未访问;
    //因为DFS算法必须通过回溯消去影响，因此又称为回溯算法
}
</code></pre>
<p>上面就是DFS的例子。其实ID A*就是用了启发式搜索的估价函数来改写最优性剪枝的方案。</p>
<h2 id="a-启发式搜索">A* / 启发式搜索</h2>
<ul>
<li>给广搜的状态一个估价函数，然后以估价参数为优先级使用优先队列代替队列。</li>
<li>重点是估价函数的设计。</li>
<li>估价函数h(s)是当前状态到目标状态的乐观估计最优解。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Luogu P1305 新二叉树 题解]]></title>
        <id>https://malachiten.github.io/post/p1305-xin-er-cha-shu-ti-jie</id>
        <link href="https://malachiten.github.io/post/p1305-xin-er-cha-shu-ti-jie">
        </link>
        <updated>2019-09-27T02:16:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="luogu-p1305-新二叉树-题解">Luogu P1305 新二叉树 题解</h1>
<p>很水的一道二叉树的题。其实并不需要真正利用在程序中构造二叉树进行求解的思路，而是利用二叉树的性质，找出规律，从而得出结果。</p>
<p>首先让我们看到题目：</p>
<h2 id="题目描述">题目描述</h2>
<p><strong>输入一串二叉树，用遍历前序打出。</strong></p>
<p>一看这个题目，似乎还无法得出一个规律。不过我们产生了问题：如何输入这一串二叉树？</p>
<h2 id="输入格式">输入格式</h2>
<p><strong>第一行为二叉树的节点数</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>≤</mo><mn>26</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(n≤26)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mclose">)</span></span></span></span>。</p>
<p><strong>后面n行，每一个字母为节点，后两个字母分别为其左右儿子。</strong></p>
<p><strong>空节点用星号表示。</strong></p>
<p>这样似乎就明了了：二叉树好像是通过这几种形式输入的：</p>
<ul>
<li>父亲 左儿子 右儿子</li>
<li>父亲 儿子 星号</li>
<li>父亲 星号 星号</li>
</ul>
<h2 id="输出格式">输出格式</h2>
<p><strong>前序排列的二叉树。</strong></p>
<p>既然要求这样输出，那么我们就可以寻找一下前序排列的规律：</p>
<p>在只有一个节点的情况下，这棵树长这样：</p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/08/22/mwEKi9.png" alt="1"></figure>
<p>它的前序排列自然是这样： <code>A</code></p>
<p>如果有了两个节点，则会变成这样：</p>
<figure data-type="image" tabindex="2"><img src="https://s2.ax1x.com/2019/08/22/mwEma4.png" alt="2"></figure>
<p>前序排列为： <code>AB</code></p>
<p>有了三个节点，会变成这样：</p>
<figure data-type="image" tabindex="3"><img src="https://s2.ax1x.com/2019/08/22/mwEnIJ.png" alt="3"></figure>
<p>前序排列为： <code>ABC</code></p>
<p>似乎还没有看出什么端倪。不过，让我们继续向下发展这棵二叉树：</p>
<figure data-type="image" tabindex="4"><img src="https://s2.ax1x.com/2019/08/22/mwEeZF.png" alt="4"></figure>
<p>前序排列： <code>ABDC</code></p>
<p>等等，怎么……顺序发生了一些变化？不再是依字母表顺序排列了？</p>
<p>再来！</p>
<figure data-type="image" tabindex="5"><img src="https://s2.ax1x.com/2019/08/22/mwEMGR.png" alt="5"></figure>
<p>前序排列： <code>ABDEC</code></p>
<p>原来规律是这样！</p>
<p><strong>每次第一个输入的序列（根节点及其子节点） 直接被加入前序中；</strong></p>
<p><strong>后续有两种儿子的，则忽略 “ 星号 ” 字符，将左儿子插入序列中其父亲节点后的一位，将右儿子插入序列中其左儿子节点的后一位。</strong></p>
<p><strong>仅有一种儿子的（表现形式为 父亲 儿子 星号 ），就简单将其儿子插入父亲节点的后一位即可。</strong></p>
<p><strong>找到父亲节点或左儿子的方法很简单：通过 <code>string</code> 类的这个成员函数即可完成：</strong></p>
<pre><code class="language-cpp">int find(string s);
</code></pre>
<p>这个成员函数的作用是<strong>返回子字符串s在原串中的位置</strong>。如果找不到，则返回：</p>
<pre><code class="language-cpp">string::npos
</code></pre>
<p>这个常量。（这个常量在不同的编译器中，有不同的值，虽然有些时候是 <code>static_cast&lt;size_type&gt;(-1)</code> ，但是可能其他时候会出差错(比如变成size_t的最大值,4294967295)。因此，我们在这里不写-1，而写这个常量更为保险。如果想继续深入了解这个用于标记<code>find</code>失败的常量，可以参考<a href="https://blog.csdn.net/JIEJINQUANIL/article/details/51789682">其他巨佬的博客</a>）</p>
<p>然后，我们再使用这个类里面的另一个函数 <code>insert</code> 向指定的位置插入代表子节点的字符：</p>
<pre><code class="language-cpp">void insert(int position,int length,string s);
</code></pre>
<p>它的作用是 <strong>从字符串中的第position个位置开始，插入length个字符，这些字符来源于s</strong> 。</p>
<p>这样，我们就可以得到这题的代码！</p>
<h3 id="代码如下">代码如下：</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
string t;
int n;
string s;
int main(){
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;s;
		if(t.find(s[0])==string::npos){t=s;continue;}
		if(s[1]!='*') t.insert(t.find(s[0])+1,1,s[1]);
		if(s[2]!='*') t.insert(t.find(s[1])+1,1,s[2]);
	}
	cout&lt;&lt;t&lt;&lt;endl;
}
</code></pre>
<h5 id="你觉得一次就能ac了">你觉得一次就能AC了？</h5>
<h4 id="并不是">并不是！</h4>
<h3 id="实际上">实际上！</h3>
<h2 id="这个只有20分">这个只有20分！！！</h2>
<figure data-type="image" tabindex="6"><img src="https://s2.ax1x.com/2019/08/22/mwmhAU.png" alt="x1"></figure>
<p>为什么？为什么只有20分？</p>
<p>很简单。下载数据后，你会发现这是因为这份代码没有考虑到这种数据的存在：</p>
<p><strong>“指示根节点及其子节点的第一行就含星号 ！！！”</strong></p>
<p>这种数据会带来什么影响？</p>
<p><strong>你的程序将把“ 星号 ”当作一种子节点！！！</strong></p>
<p>于是，之后的输出就完全混乱了。毕竟，由于第一行是特判全部输入，“ 星号 ”这样的鬼东西都被插进了字符串里面。</p>
<p>不过这样一来，你就找到了修改的思路：</p>
<p>使用 <code>string</code> 类的这个成员函数： <code>erase</code> ！</p>
<pre><code class="language-cpp">void erase(string::iterator start,string::iterator end);
</code></pre>
<p>直接运用它，产生的作用其实是消除<strong>一个字符串中的一段连续的长度</strong>。那么怎么达到消除<strong>全部指定字符</strong>（此处为标明了根节点及其儿子的字符串中的 “ * ” ）呢？</p>
<p>使用 <code>algorithm</code> 库中的 <code>remove</code> 函数！</p>
<pre><code class="language-cpp">iterator remove(iterator start,iterator end,auto c);
</code></pre>
<p>有了这个，我们就能够不断地清除字符串中的目标字符，并不断返回指向其未被删除元素的下一个元素的迭代器，从而使用erase函数清除它。</p>
<p>于是，我们得到了用于<strong>清除一段字符串中全部指定字符</strong>的完整代码：</p>
<pre><code class="language-cpp">erase(remove(string::iterator start,string::iterator end,char c),string::iterator end);
</code></pre>
<p>那么，新的代码也呼之欲出了！</p>
<h3 id="新代码如下">新代码如下：</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
string t;
int n;
string s;
int main(){
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;s;
		if(t.find(s[0])==string::npos){
			s.erase(remove(s.begin(),s.end(),'*'),s.end());
			t=s;
			continue;
		}
		if(s[1]!='*') t.insert(t.find(s[0])+1,1,s[1]);
		if(s[2]!='*') t.insert(t.find(s[1])+1,1,s[2]);
	}
	cout&lt;&lt;t&lt;&lt;endl;
}
</code></pre>
<h5 id="你又觉得这次就能ac了">你又觉得这次就能AC了？</h5>
<h4 id="并不是-2">并不是！</h4>
<h3 id="其实">其实！</h3>
<h2 id="这个只有30分">这个只有30分！！！</h2>
<figure data-type="image" tabindex="7"><img src="https://s2.ax1x.com/2019/08/22/mwm4NF.png" alt="x2"></figure>
<p><s>才多过了一个点啊……</s></p>
<p>这次又是为什么？？！</p>
<p>下载数据后发现，这次是栽在了一种之前<strong>从未考虑到的输入情况</strong>上。</p>
<p>这次导致出错的输入数据为：</p>
<ul>
<li>父亲 星号 儿子</li>
</ul>
<p>……</p>
<p><s>这也太坑了吧</s></p>
<p>我们为了AC此题，只能继续努力了……</p>
<p>这次更改并不需要什么新的技术，只需要添加几个判断即可绕过大坑。</p>
<h3 id="代码如下-2">代码如下：</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
string t;
int n;
string s;
int main(){
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;s;
		if(t.find(s[0])==string::npos){
			s.erase(remove(s.begin(),s.end(),'*'),s.end());
			t=s;
			continue;
		}
		if(s[1]!='*'&amp;&amp;s[2]!='*'){
			t.insert(t.find(s[0])+1,1,s[1]);
			t.insert(t.find(s[1])+1,1,s[2]);
		}
		if(s[1]=='*'&amp;&amp;s[2]!='*'){
			t.insert(t.find(s[0])+1,1,s[2]);
		}
		if(s[1]!='*'&amp;&amp;s[2]=='*'){
			t.insert(t.find(s[0])+1,1,s[1]);
		}
	}
	cout&lt;&lt;t&lt;&lt;endl;
}
</code></pre>
<p>看着屏幕上蓝色方块上转着白色的圈圈，你想到：之前（指20分变30分那次）做了那么大的修改，才多过了一个点，想必这个算法还存在很多问题吧……难不成<strong>还得再重写几次？？！</strong></p>
<p>然后……</p>
<figure data-type="image" tabindex="8"><img src="https://s2.ax1x.com/2019/08/22/mwK3hF.png" alt="v"></figure>
<p>？？？？？？</p>
<h2 id="过了就过了">过了？？！就过了？？？？？！</h2>
<p>历经千辛万苦，终于过了啊……<s>（接受现实）</s></p>
<p><s>bilibili干杯！（好像并没有什么不对）</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[终极压行技巧]]></title>
        <id>https://malachiten.github.io/post/zhong-ji-ya-xing-ji-qiao</id>
        <link href="https://malachiten.github.io/post/zhong-ji-ya-xing-ji-qiao">
        </link>
        <updated>2019-09-27T02:07:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="终极压行技巧">终极压行技巧</h1>
<p>看我做Luogu P1914 小书童——密码的可能是最短的AC代码！</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
int main(){
	int n; std::string str;
	std::cin&gt;&gt;n&gt;&gt;str;
	for(int i=0;i&lt;str.length();i++) std::cout&lt;&lt;(char)(str[i]+n&gt;122?str[i]+n-26:str[i]+n);
}
</code></pre>
<p>其实是采用了这些方法来缩减长度：</p>
<p>1.采用**略去using namespace std;**的方法减去一行长度。代价是使用名称空间<code>std</code>中的函数或对象时必须添加<code>std::</code>前缀。不过本方法的用处在压行，对于在一行中增加长度的代价，可以忽略不计。</p>
<p>2.使用<strong>三目运算符</strong>在一行中实现</p>
<pre><code class="language-cpp">if(/*the value of the expression isn't False(0)*/){
    //do something
}else{
    //do something
}
</code></pre>
<p>的效果，从而将三行压成一行。</p>
<p>3.从C++0x(C++11)标准开始，主函数末尾即可略去<code>return 0;</code>。采用这一特性，可以省掉一行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL容器 set 实用性说明]]></title>
        <id>https://malachiten.github.io/post/stl-rong-qi-set-shi-yong-xing-shuo-ming</id>
        <link href="https://malachiten.github.io/post/stl-rong-qi-set-shi-yong-xing-shuo-ming">
        </link>
        <updated>2019-09-27T02:06:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="stl容器-set-实用性说明">STL容器 set 实用性说明</h1>
<p><strong>set</strong>是一种 <em>STL</em> 中的容器，采用<strong>set&lt;type_of_set&gt; name_of_set</strong>的方式进行声明。可以使用迭代器( <em>iterator</em> )对其中的元素进行指示，并使用其成员函数进行操作。<strong>set</strong>的性质是： <em>自动排序</em> 、 <em>自动去重</em> 。<strong>set</strong>的本质是“<strong>集合</strong>”，而集合具有确定性和互异性。</p>
<p>据各类资料描述，<strong>set</strong>的底层实现是一种名为红黑树的二叉搜索树，但是其实现原理及各项操作之复杂度不处于本文描述范围内，此处只是顺带一提。</p>
<p><strong>set</strong>可以采用这些函数进行操作（只是我觉得很实用的函数，并不是全部）：</p>
<pre><code class="language-cpp">set&lt;type_of_set&gt;::iterator begin()
</code></pre>
<p>返回一个指向<strong>set</strong>开头的迭代器</p>
<pre><code class="language-cpp">set&lt;type_of_set&gt;::iterator end()
</code></pre>
<p>返回一个指向<strong>set</strong>结尾的迭代器</p>
<pre><code class="language-cpp">void clear()
</code></pre>
<p>清除<strong>set</strong>中的所有元素</p>
<pre><code class="language-cpp">int size()
</code></pre>
<p>返回<strong>set</strong>中元素的个数。</p>
<pre><code class="language-cpp">int max_size()
</code></pre>
<p>返回该<strong>set</strong>能够容纳的最大元素总数。</p>
<pre><code class="language-cpp">void insert(type_of_set element)
</code></pre>
<p>将 <em>element</em> 插入<strong>set</strong>中适合的位置</p>
<pre><code class="language-cpp">bool empty()
</code></pre>
<p>取该<strong>set</strong>是否为空。</p>
<p>比较特殊的是</p>
<pre><code class="language-cpp">void erase()
</code></pre>
<p>这个函数。</p>
<p>这个函数被重载了三次：</p>
<pre><code class="language-cpp">void erase(set&lt;type_of_set&gt;::iterator it)
void erase(set&lt;type_of_set&gt;::iterator first,set&lt;type_of_set&gt;::iterator second)
void erase(type_of_set key_value)
</code></pre>
<p>第一种用法：删除<strong>set</strong>中迭代器 it 指向的元素</p>
<p>第二种用法：删除<strong>set</strong>中迭代器 first 到 end 之间的全部元素。</p>
<p>第三种用法：删除<strong>set</strong>中的键值 key_value。</p>
<p>有时，我们也需要访问<strong>set</strong>中的某些元素。然而，<strong>set</strong>并没有重载[]运算符，导致了我们无法进行随机访问。这带来了极大的困扰。不过我们还是可以进行顺序访问。</p>
<p>访问时采用这种方式：</p>
<p>先声明三个迭代器。一个名为 <em>it_begin</em> 指向开头，一个名为 <em>it_end</em> 指向结尾，一个名为 <em>it</em> 备用。<br>
我们使用一个for循环进行访问。循环这样写：</p>
<pre><code class="language-cpp">for(it=it_begin;it!=it_end;it++){
    type_of_set temp=*it;
    //do something
}
</code></pre>
<p>就像这样，你就可以完成对<strong>set</strong>中每个元素的访问了。是不是敲简单嘤嘤嘤</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PB_DS容器 trie 实用性说明]]></title>
        <id>https://malachiten.github.io/post/pb_ds-rong-qi-trie-shi-yong-xing-shuo-ming</id>
        <link href="https://malachiten.github.io/post/pb_ds-rong-qi-trie-shi-yong-xing-shuo-ming">
        </link>
        <updated>2019-09-27T02:05:13.000Z</updated>
        <content type="html"><![CDATA[<h1 id="pb_ds容器-trie-实用性说明">PB_DS容器 trie 实用性说明</h1>
<p>众所周知，C++提供的 <em>STL</em> (标准模板库)具有大量的预制模板，非常优秀。 PB_DS 可能了解的人比较少，但是其也是一个模板库，而且具有更加强大深入的功能。其中，<strong>trie树</strong>这种平时背诵手打模板才能打出来的高级数据结构，也被包括在其中。</p>
<p>让我们切入正题。首先，要使用 PB_DS 的容器，需要先加上这一行预处理器命令：</p>
<pre><code class="language-cpp">#include &lt;ext/pb_ds/assoc_container.hpp&gt;
</code></pre>
<p>然后包含<strong>trie树</strong>模板：</p>
<pre><code class="language-cpp">#include&lt;ext/pb_ds/trie_policy.hpp&gt;
</code></pre>
<p>而且别忘了使用PB_DS的名称空间！</p>
<pre><code class="language-cpp">using namespace __gnu_pbds;
</code></pre>
<p>这样，就能够使用这个模板了。</p>
<p>不过，让我们看到一般我们使用的直接声明一棵<strong>trie树</strong>的方式：</p>
<pre><code class="language-cpp">trie&lt;string,null_type,trie_string_access_traits&lt;&gt;,pat_trie_tag,trie_prefix_search_node_update&gt; tre;
</code></pre>
<p>每声明一棵<strong>trie树</strong>都要进行如此复杂的操作！这是令人望而生畏的。<br>
可是，我们又想到，以前曾经写过这一句来缩减使用 <em>long long</em> 带来的代码长度：</p>
<pre><code class="language-cpp">typedef long long ll;
</code></pre>
<p>于是，我们想出了这种操作：</p>
<pre><code class="language-cpp">typedef trie&lt;string,null_type,trie_string_access_traits&lt;&gt;,pat_trie_tag,trie_prefix_search_node_update&gt; tr;
tr tre;
</code></pre>
<p>通过将复杂的声明定义缩减为一个自定义类型，我们成功地缩减了代码的长度及书写的复杂度。</p>
<p>既然已经定义了<strong>trie树</strong>类型的<strong>tre</strong>，那么我们能对它进行什么实用的操作呢？</p>
<p>答案是：<strong>insert</strong>，<strong>erase</strong>，<strong>join</strong>，以及<strong>pair</strong>。</p>
<pre><code class="language-cpp"> void insert(string t);
</code></pre>
<p>这个操作用于向一棵<strong>trie树</strong>中插入一个字符串 <em>t</em> 。</p>
<pre><code class="language-cpp">void erase(string t);
</code></pre>
<p>这个操作用于从一棵<strong>trie树</strong>中删去一个字符串 <em>t</em> 。</p>
<pre><code class="language-cpp">void join(tr b);
</code></pre>
<p>这个操作用于将一棵<strong>trie树</strong> <em>b</em> 并入当前<strong>trie树</strong>。</p>
<p>而<strong>pair</strong>的使用就较为复杂。</p>
<p>要使用一个<strong>pair</strong>，首先我们需要声明一个迭代器（ <em>iterator</em> ）：</p>
<pre><code class="language-cpp">pair&lt;tr::iterator,tr::iterator&gt; area=tre.prefix_range(string x);
</code></pre>
<p>这意味着定义了一个将要<strong>依次</strong>指向<strong>每个</strong>以字符串 <em>x</em> 为前缀的字符串的迭代器。</p>
<p>然后，我们就可以利用这个迭代器读取字典树中以字符串 <em>x</em> 作为前缀的<strong>所有</strong>字符串：</p>
<pre><code class="language-cpp">for(tr::iterator it=area.first;it!=area.second;it++){
	cout&lt;&lt;*it&lt;&lt;' '&lt;&lt;endl;
} 
</code></pre>
<p>这就是关于 PB_DS 容器<strong>trie树</strong>的实用操作了。是否感觉有些许不足？是的。<strong>系统</strong>容器的<strong>trie树</strong>虽然<strong>看上去</strong>完成了一个强大的高级数据结构，但是其<strong>本身并不强大</strong>。由于只支持这些模板操作，它难以作为解决问题的利器。不过，由于模板书写的便捷性，只要是它能够出场的时刻，它一定不会辜负众望。</p>
<p>最后附一个支持PB_DS中trie树容器的所有操作的DEMO代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#include &lt;ext/pb_ds/assoc_container.hpp&gt;
#include&lt;ext/pb_ds/trie_policy.hpp&gt;
using namespace std;
using namespace __gnu_pbds;
int n,m;
string s;
typedef trie&lt;string,null_type,trie_string_access_traits&lt;&gt;,pat_trie_tag,trie_prefix_search_node_update&gt; tr;
tr tre;
int main(){
	int a;
	cout&lt;&lt;&quot;1:INSERT A STRING TO THE TRIE TREE\n2:PRINT ALL STRINGS WITH A PREFIX IN THE TRIE TREE\n3:DELETE A STRING IN THE TRIE TREE\n4:EXIT&quot;&lt;&lt;endl;
	while(1){
		cin&gt;&gt;a;
		switch(a){
			case 1:{
				cout&lt;&lt;&quot;INSERT THIS STRING TO THE TRIE TREE:&quot;;
				cin&gt;&gt;s;
				tre.insert(s);
				break;
			}
			case 2:{
				cout&lt;&lt;&quot;PRINT ALL STRINGS WITH THE PREFIX IN THE TRIE TREE:&quot;;
				cin&gt;&gt;s;
				pair&lt;tr::iterator,tr::iterator&gt; range=tre.prefix_range(s);
				for(tr::iterator it=range.first;it!=range.second;it++){
					cout&lt;&lt;*it&lt;&lt;' '&lt;&lt;endl;
				}
				break;
			}
			case 3:{
				cout&lt;&lt;&quot;DELETE THE STRING IN THE TRIE TREE:&quot;; 
				cin&gt;&gt;s;
				tre.erase(s);
				break;
			}
			case 4:{
				cout&lt;&lt;&quot;EXIT&quot;;
				goto end;
				break;
			}
		}
	}
	end:
	return 0;
}
</code></pre>
<p>运行结果如图：<br>
<img src="https://s2.ax1x.com/2019/08/22/mdNk36.png" alt="运行截图"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++STL二分查找函数实用性说明]]></title>
        <id>https://malachiten.github.io/post/cer-fen-cha-zhao-han-shu-shi-yong-xing-shuo-ming</id>
        <link href="https://malachiten.github.io/post/cer-fen-cha-zhao-han-shu-shi-yong-xing-shuo-ming">
        </link>
        <updated>2019-09-27T02:04:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cstl二分查找函数实用性说明">C++STL二分查找函数实用性说明</h1>
<p>平时我们需要“快速查找”的值，我们一般会采用二分查找来找到。二分查找的代码一般如下：</p>
<pre><code class="language-cpp">while(l&lt;=r){
    mid=(l+r)/2;
    if(b[mid]&lt;=a[i]){
        l=mid+1;
        continue;
    }
    r=mid-1;
}
</code></pre>
<p>这导致我们必须背模板，不但难背而且用着还容易出错。</p>
<p>那么是否存在简单易行，不容易出错而且等效于手写的二分查找的工具呢？</p>
<p>这样的工具是存在的。而且我们可以确切地指出，它们存在于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>T</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">STL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">L</span></span></span></span>算法库 <code>&lt;algorithm&gt;</code> 中。</p>
<p>切入正题。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>T</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">STL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">L</span></span></span></span>为我们提供了三种不同的二分查找函数，它们分别是：</p>
<ul>
<li>
<p>返回要查找的值<strong>是否存在</strong>的函数<strong>binary_search</strong>。</p>
</li>
<li>
<p>返回第一个<strong>大于或等于</strong>要查找的值的<strong>位置</strong>的函数<strong>lower_bound</strong>。</p>
</li>
<li>
<p>返回第一个<strong>大于</strong>要查找的值的<strong>位置</strong>的函数<strong>upper_bound</strong>。</p>
</li>
</ul>
<p>那么我们应该怎么使用它们呢？</p>
<pre><code class="language-cpp">bool binary_search(Type[]+int pos_of_begin,Type[]+int pos_of_end,val);
</code></pre>
<p>这是<strong>binary_search</strong>的使用方法——传入三个参数：任意类型数组名称加上查找起始位置 <em>pos of begin</em> ，该数组名称加查找结束位置 <em>pos of end</em> ，以及待查找的值 <em>val</em> 。<strong>它将返回一个布尔值，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>代表 <em>val</em> 存在于数组之中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>则代表其不存在。</strong></p>
<pre><code class="language-cpp">ADDR lower_bound(Type[]+int pos_of_begin,Type[]+int pos_of_end,val);
</code></pre>
<p>这就是<strong>lower_bound</strong>的使用方法了——把三个参数：任意类型数组名称加上查找起始位置 <em>pos of begin</em> ，该数组名称加查找结束位置 <em>pos of end</em> ，以及待查找的值 <em>val</em> ，全部传进去！它将返回一个内存地址，代表着该数组中的值 <em>val</em> 存在在内存中的位置。若找不到这个值，就会返回这个数组的末尾 <em>last</em> 在内存中位置增加1个该数据类型长度的地址！<strong>小心，如果不特判一下就直接调用的话，你就要越界了!</strong></p>
<pre><code class="language-cpp">ADDR upper_bound(Type[]+int pos_of_begin,Type[]+int pos_of_end,val);
</code></pre>
<p>这是<strong>lower_bound</strong>的使用方法——跟之前那个完全一样地传入三个参数：任意类型数组名称加上查找起始位置 <em>pos of begin</em> ，该数组名称加查找结束位置 <em>pos of end</em> ，以及待查找的值 <em>val</em> 。它返回一个内存地址，还是数组中值 <em>val</em> 存在于内存中的位置。若找不到这个值，这个函数还是会返回这个数组的末尾 <em>last</em> 的值+1单位长度的地址！<strong>跟之前一样，如果你不特判这个情况，也会越界的啊!一定要注意！</strong></p>
<p>跟往常一样……由于这个是实用性说明，所以……这些函数的复杂度证明就不存在了哦<sub>（</sub><sub>其实我也没有证过，不过……**既然是$STL$操作的话……暂且认为它们的复杂度全都是$O(\log_2n)$的吧**</sub>溜啦！~~）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GCC 全部编译器优化开关启动命令]]></title>
        <id>https://malachiten.github.io/post/gcc-quan-bu-bian-yi-qi-you-hua-kai-guan-qi-dong-ming-ling</id>
        <link href="https://malachiten.github.io/post/gcc-quan-bu-bian-yi-qi-you-hua-kai-guan-qi-dong-ming-ling">
        </link>
        <updated>2019-09-27T02:03:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="gcc-全部编译器优化开关启动命令">GCC 全部编译器优化开关启动命令</h1>
<p>有时，洛谷上的一些题，我们的算法并不能满分通过。一些优化之差，就导致一道题迟迟无法AC。对此，可以在我们的程序前面加上这些预处理器命令：</p>
<pre><code class="language-cpp">#define fastcall __attribute__((optimize(&quot;-O3&quot;)))
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize(&quot;Ofast&quot;)
#pragma GCC optimize(&quot;inline&quot;)
#pragma GCC optimize(&quot;-fgcse&quot;)
#pragma GCC optimize(&quot;-fgcse-lm&quot;)
#pragma GCC optimize(&quot;-fipa-sra&quot;)
#pragma GCC optimize(&quot;-ftree-pre&quot;)
#pragma GCC optimize(&quot;-ftree-vrp&quot;)
#pragma GCC optimize(&quot;-fpeephole2&quot;)
#pragma GCC optimize(&quot;-ffast-math&quot;)
#pragma GCC optimize(&quot;-fsched-spec&quot;)
#pragma GCC optimize(&quot;unroll-loops&quot;)
#pragma GCC optimize(&quot;-falign-jumps&quot;)
#pragma GCC optimize(&quot;-falign-loops&quot;)
#pragma GCC optimize(&quot;-falign-labels&quot;)
#pragma GCC optimize(&quot;-fdevirtualize&quot;)
#pragma GCC optimize(&quot;-fcaller-saves&quot;)
#pragma GCC optimize(&quot;-fcrossjumping&quot;)
#pragma GCC optimize(&quot;-fthread-jumps&quot;)
#pragma GCC optimize(&quot;-funroll-loops&quot;)
#pragma GCC optimize(&quot;-freorder-blocks&quot;)
#pragma GCC optimize(&quot;-fschedule-insns&quot;)
#pragma GCC optimize(&quot;inline-functions&quot;)
#pragma GCC optimize(&quot;-ftree-tail-merge&quot;)
#pragma GCC optimize(&quot;-fschedule-insns2&quot;)
#pragma GCC optimize(&quot;-fstrict-aliasing&quot;)
#pragma GCC optimize(&quot;-falign-functions&quot;)
#pragma GCC optimize(&quot;-fcse-follow-jumps&quot;)
#pragma GCC optimize(&quot;-fsched-interblock&quot;)
#pragma GCC optimize(&quot;-fpartial-inlining&quot;)
#pragma GCC optimize(&quot;no-stack-protector&quot;)
#pragma GCC optimize(&quot;-freorder-functions&quot;)
#pragma GCC optimize(&quot;-findirect-inlining&quot;)
#pragma GCC optimize(&quot;-fhoist-adjacent-loads&quot;)
#pragma GCC optimize(&quot;-frerun-cse-after-loop&quot;)
#pragma GCC optimize(&quot;inline-small-functions&quot;)
#pragma GCC optimize(&quot;-finline-small-functions&quot;)
#pragma GCC optimize(&quot;-ftree-switch-conversion&quot;)
#pragma GCC optimize(&quot;-foptimize-sibling-calls&quot;)
#pragma GCC optimize(&quot;-fexpensive-optimizations&quot;)
#pragma GCC optimize(&quot;inline-functions-called-once&quot;)
#pragma GCC optimize(&quot;-fdelete-null-pointer-checks&quot;)
</code></pre>
<p>从而开启全部优化开关，亲测将50分TLE变成了100分AC。</p>
<p>不过……</p>
<h2 id="警告在noip竞赛中使用任何编译命令可能导致complie-error并且无法申诉因此不要尝试在正式竞赛中使用这些编译命令本技巧仅限平时使用">警告：在NOIp竞赛中使用任何编译命令可能导致Complie Error，并且无法申诉！因此，不要尝试在正式竞赛中使用这些编译命令！本技巧仅限平时使用！！！</h2>
]]></content>
    </entry>
</feed>