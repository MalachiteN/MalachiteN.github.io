<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://malachiten.github.io</id>
    <title>Malachite</title>
    <updated>2019-10-09T13:48:37.533Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://malachiten.github.io"/>
    <link rel="self" href="https://malachiten.github.io/atom.xml"/>
    <subtitle>夕焼けの中に吸い込まれて消えてった</subtitle>
    <logo>https://malachiten.github.io/images/avatar.png</logo>
    <icon>https://malachiten.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Malachite</rights>
    <entry>
        <title type="html"><![CDATA[笔记 : 最小生成树 / Kruskal算法]]></title>
        <id>https://malachiten.github.io/post/bi-ji-zui-xiao-sheng-cheng-shu-kruskal-suan-fa</id>
        <link href="https://malachiten.github.io/post/bi-ji-zui-xiao-sheng-cheng-shu-kruskal-suan-fa">
        </link>
        <updated>2019-10-08T07:10:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="最小生成树是什么">最小生成树是什么</h2>
<p>对于一个这样的连通图：</p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/10/08/ufgOiR.png" alt="graphFull.png"></figure>
<p>表格形式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">起点</th>
<th style="text-align:center">终点</th>
<th style="text-align:center">权值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">9</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">10</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">11</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">7</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
<p>它的极小连通子图，可以表现为一棵树的形式，即为最小生成树(如下图所示)。</p>
<figure data-type="image" tabindex="2"><img src="https://s2.ax1x.com/2019/10/08/uf2tyT.png" alt="graphMini.png"></figure>
<p>看不出这是一棵树？看这个。</p>
<figure data-type="image" tabindex="3"><img src="https://s2.ax1x.com/2019/10/08/ufRjKK.png" alt="trueTree.png"></figure>
<p>表格形式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">起点</th>
<th style="text-align:center">终点</th>
<th style="text-align:center">权值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">9</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<p><s>看，是不是特别小？</s></p>
<p><s>你说是，就是吧</s></p>
<h2 id="我们怎么生成一个最小生成树呢">我们怎么生成一个最小生成树呢？</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++面向对象 / 封装 继承 多态]]></title>
        <id>https://malachiten.github.io/post/cmian-xiang-dui-xiang-feng-zhuang-ji-cheng-duo-tai</id>
        <link href="https://malachiten.github.io/post/cmian-xiang-dui-xiang-feng-zhuang-ji-cheng-duo-tai">
        </link>
        <updated>2019-10-07T12:27:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="引入">引入</h2>
<p>我们以一个形象的例子来介绍这几个特性。</p>
<h3 id="一-显而易见的故事">一 显而易见的故事</h3>
<p>作为一个<s>沉迷学习的好孩子</s>，你对于<s>如何藏匿你的手机</s>得心应手。</p>
<p>在你的房间中，有一张<strong>床</strong>、一张<strong>书桌</strong>一个<strong>大大的衣柜</strong>，还有一个<strong>书柜</strong>。</p>
<p><strong>你的学习用品均储存在书柜中</strong>。</p>
<p><strong>生活用品均储存在衣柜中</strong>。</p>
<p>你的_家长_为了检查你的学习，会经常<strong>翻你的书柜和书桌</strong>。</p>
<p>而我们现在假设他们完全不管你的日常生活，因而<strong>几乎</strong>不管你的衣柜和床板底下。</p>
<p>同时，你的_家长_还自诩于重视你的隐私，因此他们还将<strong>从来不翻你自己身上的包</strong>“引以为傲”，作为与其他家长的谈资。</p>
<p>那么我们必定可以得出一个结论</p>
<blockquote>
<p>你的手机<strong>必定放在你的衣柜、床板底下或者自己的身上</strong>。这能够保证你的手机一直安全。</p>
</blockquote>
<p>这是一个显而易见的结论。然而让我们将情况变得更复杂一点：</p>
<p>你的同学们中，有一些_好朋友_会到你的家中玩。一得到难得的关上自己房间门的机会，你就拿出手机跟_朋友_一起玩。_朋友_临走时，他<strong>询问你藏匿手机的技巧</strong>，于是你<strong>告诉了他你的大部分技巧</strong>。</p>
<p>不过，因为朋友的不同，你告诉不同的朋友不同的技巧。你把手机放在身上的事，却因为你不保证_朋友A_的家长是否对他搜身，而提示他不要藏在身上。_朋友B_家更注重孩子隐私，因此从不进他的房间，则可以告诉他全部的技巧。而他也不必提心吊胆地藏在身上。</p>
<p>于是，你的_朋友A_具有了这样的藏匿手机技巧：</p>
<blockquote>
<p>把手机放在衣柜里面或者床板下面。</p>
</blockquote>
<p>_朋友B_变成这样：</p>
<blockquote>
<p>把手机放在书桌、书柜、衣柜或者床上。</p>
</blockquote>
<p>同时我们还发现，你需要悄悄玩手机，但是对于手机的频繁转移，并没有什么需求。不过你还是告诉了他们几个技巧供他们选择。</p>
<p>后来你的手机被发现了，不过你的朋友们将你的技能发扬光大，<s>代代相传</s>。(大雾)</p>
<h3 id="二-抽象这个故事">二 抽象这个故事</h3>
<p>之前也说过：经过抽象,就能研究事物的本质与规律。</p>
<p>抽象的一般方法：</p>
<blockquote>
<ol>
<li>忽略事物中与当前问题或目标无关的特点,集中考虑有关。</li>
<li>忽略非本质的特征,抽取本质性特征</li>
<li>从个体把握一般,从事物把握本质</li>
</ol>
</blockquote>
<p>由此，这个典例事件，我们可以这样抽象：</p>
<p>将你的房间看做一个<strong>类</strong>( <em>class</em> )。这个类有如下的特性：</p>
<ul>
<li>其中的“书柜”和“书桌”是<strong>任由外部访问</strong>的成员。这样的成员，称为<code>public</code>成员。</li>
<li>“床”和“衣柜”禁止<strong>除了你的朋友以外的人访问</strong>。这样的称为<code>protected</code>成员。</li>
<li>“自己身上”禁止<strong>一切外部访问</strong>。这样的则称为<code>private</code>成员。</li>
</ul>
<p>通过严格的将这些容器给<strong>封装</strong>起来，你严格地控制了外部对于你的成员的访问，保证了你的手机的安全。同时，你的朋友们只需要知道找你(接口)就可以跟你一起玩手机，而并不需要亲自翻箱倒柜(了解接口内部的实现)。</p>
<p>而你的朋友们回家之后就在他的房间上<strong>继承</strong>了你房间的特性。这时，可以将你自己的房间称为他们继承的“基类”。相对而言，他们的房间就变成了“派生类”。</p>
<p>_A_的房间具有了<strong>除了跟你身上以外的一切特性</strong>。他也具有了你的<code>public</code>和<code>protected</code>属性，只有<code>private</code>属性不能被继承下来。这样的继承方式，被称为<code>public</code>继承。</p>
<p>_B_的房间中，手机则也可以放在相同的地方。不过，显然，他的书柜和书桌禁止<strong>除了他的朋友以外的人访问</strong>。因而，你的<code>public</code>成员变成了他的<code>protected</code>成员。这样的继承方式，则称为<code>protected</code>继承。这种继承方式中，基类除了<code>private</code>之外的成员都会变成派生类的<code>protected</code>成员。</p>
<p>除此之外，还有<code>private</code>继承，用于<s>跟Vim一起帮助乌干达的可怜儿童</s>。所幸你没有这样的一个朋友。<s>不然我就打不完代码了</s>显然可见，对于这样的人而言，他家的空间都是他不为他人访问的的<code>private</code>成员。他也没有必要去继承你的<code>private</code>。</p>
<p>与此同时，他们继承了你的转移手机方法。你的转移手机方法因为没有必要而并不能执行(因此是一个虚拟函数)，而你的朋友们将其重载而发展开来。这就是由基类提供纯粹的接口而派生类通过重载赋予其实际作用的<strong>多态</strong>特性。</p>
<h2 id="语法">语法</h2>
<p>对于刚刚的例子，我们可以将其写成一个例程来体现封装和继承的语法。</p>
<pre><code class="language-cpp">class your_home{
    private:
        void play_phone(){}//玩手机
        int body;
    protected:
        virtual void transfer_phone()=0;//不需要的转移
        int bed,wardrobe;
    public:
        int desk,bookcase;
};
//其实这个描述不太形象——你的类并不能实例化，因为其包含了一个纯虚函数transfer_phone()，是一个纯虚类/抽象类。
class A_home:public your_home{
    private:
        void play_phone(){};//玩手机
    protected:
        void transfer_phone(){}//实际的转移手机
};
class B_home:protected your_home{
    private:
        void play_phone(){};//玩手机
        void transfer_phone(){}//转移手机
};
class C_home:private your_home{
    private:
        void play_phone(){};//玩手机
        //没有必要转移手机了。
};
</code></pre>
<h2 id="总结">总结</h2>
<p>通过这个形象地例子，我们了解到了类的运用。</p>
<ul>
<li>“封装”——将成员封装在对象<code>public</code>、<code>protected</code>、<code>private</code>属性之中。这些对象的开发者和使用者分离，使用者只需要接入对象提供的<code>public</code>接口，而不用了解到它们的内部实现。这样也实现了对于它们的保护。</li>
<li>“继承”——派生类可以继承基类的属性。在<code>public</code>继承中，派生类会将基类的<code>public</code>属性作为自己的<code>public</code>属性，也可以用使用派生类<code>public</code>成员函数的方式来引用基类中的成员。而在<code>protected</code>继承中，派生类将基类的<code>public</code>属性降级为<code>protected</code>属性，<code>protected</code>保持不变，并废弃<code>private</code>类型属性。<code>private</code>继承只能将基类的<code>public</code>属性变成自己的<code>private</code>属性，将<code>protected</code>和<code>private</code>全部废弃。</li>
<li>“多态”——基类能够定义一个空的接口，下放到派生类来通过重载的方式实现。这对于抽象有极大的益处。不过要注意的是，如果要实现彻底抽象，就需要明确通过定义一个纯虚函数<code>virtual typename functionName()=0</code>。这样会使这个基类变成一个不能被实例化的抽象类(纯虚类)，只有基类将其重载然后实例化基类才能得到体现。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 编译原理 / 引论(1) [Ongoing]]]></title>
        <id>https://malachiten.github.io/post/bi-ji-bian-yi-yuan-li-yin-lun</id>
        <link href="https://malachiten.github.io/post/bi-ji-bian-yi-yuan-li-yin-lun">
        </link>
        <updated>2019-10-06T03:05:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="编译程序">编译程序</h2>
<p>编译程序特指<strong>将高级语言源程序翻译成低级语言目标程序</strong>的翻译程序.</p>
<h3 id="翻译程序">&quot;翻译程序&quot;</h3>
<p>将一种语言的程序(源语言程序)翻译成另一种语言的程序(目标语言程序).</p>
<h3 id="解释程序">&quot;解释程序&quot;</h3>
<p>不产生目标程序,将源语言程序逐条取出语句并立即执行的程序.这是和编译程序不一样的.</p>
<h3 id="编译程序的种类">编译程序的种类</h3>
<ol>
<li>帮助找出错误的 诊断编译程序</li>
<li>提供优化编译开关的 优化编译程序</li>
<li>交叉编译程序 编译程序</li>
</ol>
<h3 id="宿主机与目标机">宿主机与目标机</h3>
<p>宿主机:编译程序运行的平台.</p>
<p>目标机:目标代码程序运行的平台.</p>
<h3 id="可变目标的编译程序">可变目标的编译程序</h3>
<p>能够通过不同编译开关产生不同的目标代码而运行于不同的目标机上的编译程序,称为可变目标的编译程序.</p>
<h3 id="设计语言的流程">设计语言的流程</h3>
<p>设计程序设计语言</p>
<ol>
<li>设计程序设计语言的规范</li>
<li>设计其编译程序</li>
</ol>
<h2 id="抽象的思维">抽象的思维</h2>
<p>经过抽象,就能研究事物的本质与规律.</p>
<h3 id="引入">引入</h3>
<ol>
<li>忽略与当前问题或目标无关的,集中考虑有关的</li>
<li>忽略非本质的特征,抽取本质性特征</li>
<li>从个体把握一般,从事物把握本质</li>
</ol>
<blockquote>
<p>毕加索的《牛》的变化.<br>
伦敦的地铁图的变化.(各个城市的地铁地图)</p>
</blockquote>
<h3 id="图灵机">图灵机</h3>
<p>通过一条无限长的<strong>纸带</strong>,一个<strong>读写头</strong>,一个控制读写头的<strong>规则</strong>,和一个<strong>状态寄存器</strong>,来完成各项的计算.有了这个模型,就可以研究计算的过程的本质.</p>
<blockquote>
<p>对&quot;可计算&quot;和&quot;算法&quot;的定义:&quot;如果一个过程<strong>能被图灵机执行</strong>,则其可计算/为一个算法&quot;</p>
</blockquote>
<h3 id="编译程序设计中的抽象">编译程序设计中的抽象</h3>
<p>抽象在编译程序设计中是普遍的.如:形式文法,有限自动机......</p>
<h4 id="自动化的思维">自动化的思维</h4>
<p>把事物抽象之后,把抽象的事物在计算机上实现.是将计算思维物化的过程.</p>
<p>程序的本质是用自动化的思维解决问题.</p>
<p>自动化的思想,可以指导编译程序设计,并提高开发的效率.(词法分析,语法分析,有限自动机)</p>
<h2 id="分解的思维">分解的思维</h2>
<p>即模块化的思想.</p>
<p>先将问题模块化,分解为各个子问题,如果子问题足够小能够解决则解决,能继续分解则继续分解(将编译过程分解为不同的阶段,先生成中间代码,再生成目标代码)</p>
<p>实际上,递归就是这样的问题.实际上,递归求解的子问题的结构与父问题相同.只是规模减小了.在编译的过程中,广泛的运用了递归.(应用:递归下降分析,语法制导翻译,基于树的遍历的属性计算)</p>
<h2 id="权衡-折中">权衡 / 折中</h2>
<p>对于理论上的设计,由于实际限制条件的存在,实际设计会与理论设计有差别,即需要这种折中的思维.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 欧拉路 [Ongoing]]]></title>
        <id>https://malachiten.github.io/post/bi-ji-ou-la-lu</id>
        <link href="https://malachiten.github.io/post/bi-ji-ou-la-lu">
        </link>
        <updated>2019-10-04T09:06:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是欧拉路">什么是欧拉路</h2>
<p>欧拉路是指从图中任意一个点开始到图中任意一个点结束的路径，并且图中每条边通过的且只通过一次。</p>
<h2 id="怎样判断有欧拉路存在">怎样判断有欧拉路存在</h2>
<h3 id="无向图">无向图</h3>
<p>图一定要联通，且:</p>
<p>所有顶点度数均为偶数，则存在欧拉回路</p>
<p>两个点度数为奇数，其余的为偶数，则存在欧拉通路</p>
<h3 id="有向图">有向图</h3>
<p>图联通依然是一个必要条件。且:</p>
<p>每个点的入度等于出度，则存在欧拉回路(任意一点有度的点都可以作为起点)</p>
<p>除某两点外，所有入度等于出度。这两点中一点的出度比入度大，另一点的出度比入度小，则存在欧拉通路。出度大者是起点，入度大者是终点。</p>
<h2 id="怎样找到欧拉路">怎样找到欧拉路</h2>
<p>之前的内容大致只是用于<strong>发现该题目应该使用欧拉回路的方法求解</strong>。</p>
<p>以下寻找方法均建立在假设图中存在欧拉回路的基础上，其自身并不能判断图是否满足条件。</p>
<p>从一个非孤立的点开始<em>DFS</em>，点可以重复经过，每次任意走一条边，并将这条边从邻接表中删去。走到目标终点(找到欧拉通路)，或者走回起点(找到欧拉回路)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 二分图匹配 / 最大匹配]]></title>
        <id>https://malachiten.github.io/post/bi-ji-er-fen-tu-pi-pei-zui-da-pi-pei</id>
        <link href="https://malachiten.github.io/post/bi-ji-er-fen-tu-pi-pei-zui-da-pi-pei">
        </link>
        <updated>2019-10-02T00:52:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义">定义</h2>
<h3 id="什么是二分图">什么是二分图</h3>
<p>从理解意义上，二分图是指一种特殊的图，其中的顶点可以被划分到两个不同的集合中，同时，每个顶点都有一条到另一个集合中的点的边。</p>
<p>其等效理解则是，图中不含具有奇数边数的环。</p>
<p>对此，百度百科的定义:</p>
<blockquote>
<p>二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边(i，j)所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。</p>
</blockquote>
<h3 id="二分图匹配是啥意思">二分图匹配是啥意思</h3>
<p>这指的是“二分图”的“匹配”。“匹配”则是图论中的一个定义:</p>
<blockquote>
<p>一个<strong>匹配</strong>是一个由边组成的集合，其中任意两条边都没有公共顶点。</p>
</blockquote>
<p>附: 百度百科的定义</p>
<blockquote>
<p>给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。</p>
</blockquote>
<h3 id="匹配点-匹配边-未匹配点-未匹配边">匹配点、匹配边、未匹配点、未匹配边</h3>
<p>显然，匹配点是指在一种匹配中，连有匹配边的点。未匹配点与之相反，没有匹配边。</p>
<p>匹配边则是对于连接在两个匹配点之间，满足匹配定义的特定边。</p>
<p>如图：</p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/10/02/uaMNL9.png" alt="uaMNL9.png"></figure>
<p>在这张图中，有这样两种匹配方式:</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1→5</td>
<td style="text-align:center">1→4</td>
</tr>
<tr>
<td style="text-align:center">2→6</td>
<td style="text-align:center">2→6</td>
</tr>
<tr>
<td style="text-align:center">Null</td>
<td style="text-align:center">3→5</td>
</tr>
</tbody>
</table>
<p>那么，按照第一种匹配方式，匹配点有<code>1</code>,<code>2</code>,<code>4</code>,<code>6</code>这4个,其他点均为未匹配点。匹配边有<code>1→5</code>,<code>2→6</code>这两条,其他边均为未匹配边。</p>
<p>按照第二种匹配方式，匹配点就有<code>1</code>,<code>2</code>,<code>3</code>,<code>4</code>,<code>5</code>,<code>6</code>,全部匹配完了。匹配边有<code>1→4</code>,<code>2→6</code>,<code>3→5</code>,剩下的其他边就是未匹配边了。</p>
<p>因为:</p>
<blockquote>
<p>既得易见平凡，仿照上例显然。留作习题答案略，读者自证不难。</p>
</blockquote>
<p>(手动滑稽)</p>
<h3 id="最大匹配-完美匹配">最大匹配 &amp; 完美匹配</h3>
<p><strong>最大匹配</strong>的定义:</p>
<blockquote>
<p>一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。<br>
每个图必定存在一个最大匹配。</p>
</blockquote>
<p>而<strong>完美匹配</strong>是指:</p>
<blockquote>
<p>如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。<br>
不是每一个图都有完美匹配。<br>
完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突</p>
</blockquote>
<p>需要注意的是，由于完美匹配中所有顶点均为匹配点，所以一个二分图的完美匹配一定是这个图的最大匹配。然而，不是每个二分图都能够找到它的完美匹配，但最大匹配一定存在。因此，每个图的最大匹配不一定是完美匹配。</p>
<p>因此，按照上例:</p>
<p>第一种匹配方式仅仅是一种常规的匹配。</p>
<p>第二种匹配方式是匹配所有点的完美匹配。<strong>因此它又是该图的最大匹配</strong>。</p>
<p>因为:</p>
<blockquote>
<p>反之亦然同理，推论自然成立。略去过程QED，由上可知证毕。</p>
</blockquote>
<p>(手动滑稽)</p>
<p>需要前置了解的基本定义就这些了。</p>
<p>那么，分析算法实现。</p>
<h2 id="算法实现">算法实现</h2>
<h3 id="算法介绍">算法介绍</h3>
<p>一般，求二分图最大匹配的问题由<strong>匈牙利算法</strong>解决。</p>
<p>下面有两个<strong>专为解释该算法而生</strong>(非基础)的概念:</p>
<ul>
<li><strong>交替路</strong></li>
</ul>
<blockquote>
<p>若二分图中存在一种路径，其起点是一个非匹配点，而<strong>依次交替</strong>经过非匹配边、匹配边、非匹配边……那么这样的路径称为<strong>交替路</strong>。</p>
</blockquote>
<ul>
<li><strong>增广路</strong></li>
</ul>
<blockquote>
<p>若二分图中存在一条交替路，其经过一个<strong>除起点外的</strong>非匹配点，那么这一条路径称为<strong>增广路</strong>。</p>
</blockquote>
<blockquote>
<p>注: (2019/10/2)当前暂未开始学习<code>[ 网络流 / 最大流 ]</code>的课程，但是早有耳闻网络流中的增广路。不知道这里有没有联系呢？</p>
</blockquote>
<p>增广路具有一个性质: 非匹配边比匹配边多一条。由此，研究增广路能改进匹配。我们要做的只是:</p>
<ol>
<li>对于当前交替路，找到一条增广路。</li>
<li>把这条增广路中的匹配边和非匹配边调换(把匹配边变成非匹配边，非匹配边变成匹配边)，由此造出一条新的交替路。这样一来，我们的路径长度就比原来增加了1。匹配被改进了。</li>
<li>一直以当前交替路为基础重复找增广路，不断改进匹配。</li>
<li>当当前交替路找不到增广路，即找到最大匹配。</li>
</ol>
<p>实际上，这就是<strong>增广路定理</strong>。匈牙利算法正是利用该定理的流程来找到最大匹配。</p>
<h3 id="模板代码实现">模板代码实现</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

//const prepare
const int N=101;

//prepare
int n/*集合1中的点数*/,m/*集合2中的点数*/,s/*边数*/,l[N][N]/*邻接矩阵*/,matching[N]/*存储与这一个点相匹配的*/;

//kernel
bool dfs(int node){
    for(int i=1;i&lt;=n;i++){
        if(l[node][i]==1&amp;&amp;!vis[i]){
            vis[i]=1;
            if(!matching[i]||dfs(matching[i])){//节点从1开始的。如果是从0开始的,需要先memset(matching,-1,sizeof matching);,这里||的左边判matching[i]==-1
                matching[i]=node;
                return 1;
            }
        }
    }
    return 0;
}

//main process
int main(){
    cin&gt;&gt;s&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=s;i++){
        int tmp1,tmp2;
        cin&gt;&gt;tmp1&gt;&gt;tmp2;
        l[tmp1][tmp2]=1;
        l[tmp2][tmp1]=1;//对于有向图去除这句
    }
    int ans=0;
    for(int i=1;i&lt;=m;i++){
        if(!matching[i]){
            memset(vis,0,sizeof vis);
            ans+=dfs(i);//有增广路则+1,无则+0
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</code></pre>
<h2 id="例题-hdu2063">例题 HDU2063</h2>
<h3 id="题目描述">题目描述</h3>
<p><code>RPG girls</code>今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做<code>partner</code>和她同坐。但是，每个女孩都有各自的想法，举个例子把，<code>Rabbit</code>只愿意和<code>XHD</code>或<code>PQK</code>做<code>partner</code>，<code>Grass</code>只愿意和<code>linle</code>或<code>LL</code>做<code>partner</code>，<code>PrincessSnow</code>愿意和<code>水域浪子</code>或<code>伪酷儿</code>做<code>partner</code>。考虑到经费问题，<code>boss刘</code>决定只让找到<code>partner</code>的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的ACMer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？</p>
<h3 id="输入">输入</h3>
<p>输入数据的第一行是三个整数<code>K</code>,<code>M</code>,<code>N</code>，分别表示可能的组合数目，女生的人数，男生的人数。<code>0&lt;K&lt;=1000</code>,<code>1&lt;=N</code>,<code>M&lt;=500</code>.接下来的K行，每行有两个数，分别表示女生<code>Ai</code>愿意和男生<code>Bj</code>做<code>partner</code>。最后一个<code>0</code>结束输入。</p>
<h3 id="输出">输出</h3>
<p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p>
<h3 id="样例数据">样例数据</h3>
<h4 id="样例输入">样例输入</h4>
<p><code>6 3 3 1 1 1 2 1 3 2 1 2 3 3 1 0</code></p>
<h4 id="样例输出">样例输出</h4>
<p><code>3</code></p>
<h3 id="代码实现">代码实现</h3>
<p>引用自<a href="https://article.itxueyuan.com/Aeava9">乌克兰大野猪</a>的<a href="https://www.itxueyuan.com/">IT学院</a>博客,有改动。</p>
<p><strong>可以看出本题只需要实现有向图的版本</strong></p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
using namespace std;

//const prepare
const int N = 505;

//normal prepare
int mat[N][N];
int boy[N];                                   //记录男孩i被女孩选择的女孩编号，未被选则0
int vis[N];                                   //很巧妙的使用，每次记录男孩i是否被占用了
int k, m, n;

//kernel
bool dfs(int x){
    for(int i = 1; i &lt;= n; i++){              //遍历所有的男生编号 
        if(mat[x][i] == 1 &amp;&amp; vis[i] == 0){    //如果有连线且boy[i]没有被本次查找遍历过 
            vis[i] = 1;                       //假设i号boy被遍历到了 
            if(boy[i] == 0 || dfs(boy[i])){   //如果boy[i]没有被占用或者能把占用boy[i]的人换一个连线，短路原则如果没有被占用则不会执行后面的部分 
                boy[i] = x;                   //这一步的作用是执意要将boy[i]匹配给x(尽可能给腾位置出来，因为她可能占了别的女生相匹配的男生)        
                return true;
            } 
        }
    }
    return false;
}

//main process
int main(){
    while(scanf(&quot;%d&quot;, &amp;k) != EOF){
        if(k == 0) break;
        scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
        memset(mat, 0, sizeof(mat));
        memset(boy, 0, sizeof(boy));           //boy[]数组存放的是已经匹配好的方案，如果是0则未匹配 
        for(int i = 1; i &lt;= k; i++){
            int x, y;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            mat[x][y] = 1;
        }
        int ans = 0;
        for(int i = 1; i &lt;= m; i++){
            memset(vis, 0, sizeof(vis));        //vis每一次都将所有的男生编号都标记为没遍历过，注意区分vis[]和boy[]数组功能的区别 
            if(dfs(i)) ans++;                   //如果能直接相连或别人腾出位置总数+1 
        }
        printf(&quot;%dn&quot;, ans);
    }
    return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 图的存储 / 邻接表-链式前向星]]></title>
        <id>https://malachiten.github.io/post/bi-ji-lin-jie-biao-lian-shi-qian-xiang-xing</id>
        <link href="https://malachiten.github.io/post/bi-ji-lin-jie-biao-lian-shi-qian-xiang-xing">
        </link>
        <updated>2019-10-01T00:52:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="引入">引入</h2>
<p>一般而言采用这种朴素的存储方式( <strong>邻接矩阵</strong> )，读写图时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，存图空间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-cpp">int graph[maxn][maxn],n;
cin&gt;&gt;n;
for(int i=1;i&lt;=n;i++){
    cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;
    graph[t1][t2]=t3;
}
</code></pre>
<p>但是当图特别大的时候，这种操作会直接爆掉内存然后<code>Memory Limit Execeed</code></p>
<p>所以，需要进行优化</p>
<p>于是，巨佬就搞出了链式前向星( <strong>时间空间均最优的存图数据结构</strong> )</p>
<p>Talk is cheap,show me the code:</p>
<p>结构体实现</p>
<pre><code class="language-cpp">int head[maxn],ptr;
struct edge{
    int target,value,next;
    edge(){}
    edge(int x,int y,int z){
        target=x;
        value=y;
        next=z;
    }
}edges[maxn];
void clear(){
    memset(head,-1,sizeof head);
    ptr=0;
}
</code></pre>
<p>纯数组实现</p>
<pre><code class="language-cpp">int head[maxn],target[maxn],value[maxn],next[maxn],ptr;
void addEdge(int x/*起始点*/,int y/*终止点*/,int z/*权值*/){
    ++ptr;
    target[ptr]=y;
    next[ptr]=head[x];
    value[ptr]=z;
}
void clear(){
    memset(head,-1,sizeof head);
    ptr=0;
}
</code></pre>
<h2 id="解析">解析</h2>
<h3 id="结构体-edge">结构体 edge</h3>
<p>显然这个结构体描述的是图中的<strong>边</strong>。它具有三个成员变量: <code>target</code>,<code>value</code>,<code>next</code></p>
<ul>
<li><code>target</code>表示了这条边的终点。</li>
<li><code>value</code>表示了这条边的边权。</li>
<li><code>next</code>表示了与这条边起点相同的上一条边的编号。</li>
</ul>
<h3 id="数组-edges">数组 edges</h3>
<p>显然，这个数组用于存储边，然而其中的边是按照读入顺序存储，对于有序遍历图是乱序的。要想顺序读取则需要由一定的规范进行。</p>
<p>描述这个规范的，就是用于中途遍历的<code>edge</code>型对象的<code>next</code>成员，以及用于查找遍历起点的<code>head</code>数组。</p>
<h3 id="数组-head">数组 head</h3>
<p>这个数组描述了“以点<code>n</code>为起点，那么应该在找到<code>edge[head[n]]</code>，从这个<strong>真实起点</strong>开始遍历”。换句话说，这个数组就是用于描述起点的。</p>
<p>而实际上，它存储的是“从点<code>n</code>出发的存入链式前向星的最后一条边”在<code>edge[]</code>中的位置。</p>
<h2 id="实例">实例</h2>
<p>考虑这样一张图:</p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/10/01/uNB6AO.png" alt="graph"></figure>
<p>边的连接可以表示为:</p>
<table>
<thead>
<tr>
<th style="text-align:center">始发点</th>
<th style="text-align:center">终止点</th>
<th style="text-align:center">权值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<p>文字表述(输入的数据)就是:</p>
<pre><code>1 3 2
1 2 4
2 3 1
2 4 5
</code></pre>
<p>这样一来，</p>
<p><code>head[1]</code>中的数据是2，<code>head[2]</code>的数据是4</p>
<p><code>edges[1]</code>中<code>target</code>的值是3，<code>value</code>存的是2，<code>next</code> 中存的是-1(表示没有前驱了)</p>
<p><code>edges[2]</code>中<code>target</code>值是2，<code>value</code>存的是4，<code>next</code>值是1(表示前驱是<code>edges[1]</code>)</p>
<p><code>edges[3]</code>中<code>target</code>值就是3，<code>value</code>存的是1，<code>next</code>则是-1(无前驱)</p>
<p><code>edges[4]</code>中<code>target</code>是4，<code>value</code>存的是5，<code>next</code>是3(前驱为<code>edges[3]</code>)</p>
<h2 id="存储过程">存储过程</h2>
<p>一共n条边，具体到每一步读入，应该是这样的:</p>
<pre><code class="language-cpp">for(int i=1;i&lt;=n;++i){
	int t1,t2,t3;
	cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;
    edges[i]=edge(t2,t3,head[t1]);
	head[t1]=i;
}
</code></pre>
<p>通过一直更新<code>head[i]</code>的值，来达到链式的作用。实际上，邻接表就是个链表。</p>
<h2 id="遍历过程">遍历过程</h2>
<p>这个例程目的为预计将读入的原封不动输出。实际操作时应当在遍历到目标之后进行某种操作，比如跑最短路</p>
<pre><code class="language-cpp">for(int i=1;i&lt;=m;++i){
	for(int j=head[i];~j.next;j=edges[j].next){
		cout&lt;&lt;i&lt;&lt;' '&lt;&lt;edges[k].target&lt;&lt;' '&lt;&lt;edges[k].value&lt;&lt;endl;
	}
}
</code></pre>
<p>因为我们以<code>j.next==-1</code>为链表上一条链的终止点标记，所以使用<code>~j.next</code>来作为循环终止条件。</p>
<h2 id="总结">总结</h2>
<p>一个整体的代码:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

int head[maxn],esize;

struct edge{
    int target,value,next;
    edge(){}
    edge(int x,int y,int z){
        target=x;
        value=y;
        next=z;
    }
}edges[maxn];

void clear(){
    memset(head,-1,sizeof head);
    esize=0;
}

int main(){
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i){
	    int t1,t2,t3;
	    cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;
        edges[i]=edge(t2,t3,head[t1]);
	    head[t1]=i;
    }
    for(int i=1;i&lt;=m;++i){
	    for(int j=head[i];~j.next;j=edges[j].next){
		    cout&lt;&lt;i&lt;&lt;' '&lt;&lt;edges[k].target&lt;&lt;' '&lt;&lt;edges[k].value&lt;&lt;endl;
	    }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[预处理器命令 #define / 宏定义 实用性说明]]></title>
        <id>https://malachiten.github.io/post/yu-chu-li-qi-ming-ling-define-hong-ding-yi-shi-yong-xing-shuo-ming</id>
        <link href="https://malachiten.github.io/post/yu-chu-li-qi-ming-ling-define-hong-ding-yi-shi-yong-xing-shuo-ming">
        </link>
        <updated>2019-09-27T09:04:09.000Z</updated>
        <content type="html"><![CDATA[<p>注明:本文大量引用、摘抄、改编自 <a href="https://blog.csdn.net/king110108/article/details/80728010">king110108的CSDN博客</a>。若重复引用本文，请别忘了添加对以上博客的引用。</p>
<p>正如引用源标题(《#define用法集锦(非常全)》)所言，该文对<code>#define</code>的用法总结的极为全面，但是对于每种用法的详细介绍较少。因此，本文主要进行的是对该文章内容的总结和重排。</p>
<h2 id="0宏定义是什么">0.宏定义是什么</h2>
<p>define，顾名思义，表示的是进行某些定义。这种定义被称为宏(marco)。</p>
<p>宏定义是一种传递给预处理器的命令。通过提前告诉预处理器本文件中定义的宏，能够使预处理器按照定义的方式自动替换文本中的字符串(这种过程一般称为“宏展开”)，从而大大<strong>简化</strong>代码。</p>
<h2 id="1如何定义宏-取消宏">1.如何定义宏、取消宏</h2>
<p>定义一个宏:</p>
<pre><code class="language-cpp">#define [MacroName)] [MacroValue]
</code></pre>
<p>定义之后，除非存在取消指令，否则对于文件中所有出现该MacroName的地方，就替换为对应的MacroValue。</p>
<p>取消一个宏:</p>
<pre><code class="language-cpp">#undef [MacroName]
</code></pre>
<p>取消之后，除非再次定义，否则对于该MacroName不再进行替换。<s>(形象地理解就是这个MarcoName被预处理器甩了)</s></p>
<h2 id="2定义常量">2.定义常量</h2>
<p>例1:</p>
<pre><code class="language-cpp">#define MAXN 2147483647
</code></pre>
<p>本例将当前文件中所有字符串&quot;MAXN&quot;全部替换成了<code>INT_MAX</code>的值<code>2147483647</code>。这就是简单的使用#define定义常量的方式。<strong>(依然建议使用const关键字来声明常量，以免引起不可预知的问题。)</strong></p>
<h2 id="3定义数据类型">3.定义数据类型</h2>
<p>很多时候，很像定义常量时，我们想<s>少打几个字而实现相同的效果</s>咳咳，使数据修改方便，我们也想使较长的数据类型名称被一个自定义的关键字代表。这时我们可以自定义一个宏来简化数据类型。</p>
<p>例:</p>
<pre><code class="language-cpp">#define ull unsigned long long
</code></pre>
<p>本例将当前文件中所有字符串&quot;ull&quot;全部替换成了<code>unsigned long long</code>。这可以使一个较长的类型名称变得非常短，从而简化代码。<strong>(跟上面一样，通常情况下依然建议使用专门的关键字typedef来简化指定类型的名称，如果发生了不可预知的问题可别怪我啊)</strong></p>
<p>所谓“不可预知的问题”就像下面这个：</p>
<pre><code class="language-cpp">#define pin (int*);
pin a,b;
</code></pre>
<p>a是<code>int</code>型指针类型，而b是<code>int</code>型常规变量。而我们期望的其实是使a和b均为<code>int</code>型指针(<code>int*</code>)。</p>
<p>要使a和b就都是<code>int</code>型指针，我们只能使用<code>typedef</code>了。这也使我们注意到一点：我们在定义的时候，一定要养成一个良好的习惯，建议所有的层次都要加括号。</p>
<p>不过，在某些特殊情形下，比如开发机与目标机的操作系统及硬件存在巨大差异~~(比如你硬要用Core i9的机子给上世纪的80486写程序)~~的时候，由于编译器、操作系统对代码中数据类型的理解大不相同，<code>typedef</code>完全无法满足我们的需求(如果强行通过<code>typedef</code>改变编译器数据类型的定义，似乎会直接报出重复定义的错误)。这时，我们反而建议使用<code>#define</code>。</p>
<p>例:</p>
<pre><code class="language-cpp">typedef  unsigned char      boolean;     /* Boolean value type. */
typedef  unsigned long int  uint32;      /* Unsigned 32 bit value */
typedef  unsigned short     uint16;      /* Unsigned 16 bit value */
typedef  unsigned char      uint8;       /* Unsigned 8  bit value */
typedef  signed long int    int32;       /* Signed 32 bit value */
typedef  signed short       int16;       /* Signed 16 bit value */
typedef  signed char        int8;        /* Signed 8  bit value */
</code></pre>
<p>对于另外一些数据类型，即使是非常情况下，依然不建议使用哦……</p>
<p>就是这些啦</p>
<pre><code class="language-cpp">typedef  unsigned char     byte;         /* Unsigned 8  bit value type. */
typedef  unsigned short    word;         /* Unsinged 16 bit value type. */
typedef  unsigned long     dword;        /* Unsigned 32 bit value type. */
typedef  unsigned char     uint1;        /* Unsigned 8  bit value type. */
typedef  unsigned short    uint2;        /* Unsigned 16 bit value type. */
typedef  unsigned long     uint4;        /* Unsigned 32 bit value type. */
typedef  signed char       int1;         /* Signed 8  bit value type. */
typedef  signed short      int2;         /* Signed 16 bit value type. */
typedef  long int          int4;         /* Signed 32 bit value type. */
typedef  signed long       sint31;       /* Signed 32 bit value */
typedef  signed short      sint15;       /* Signed 16 bit value */
typedef  signed char       sint7;        /* Signed 8  bit value */
</code></pre>
<h2 id="4条件编译">4.条件编译</h2>
<p>例:</p>
<pre><code class="language-cpp">#define debug
#ifdef debug
//do something
#else
//do something
#endif
#ifndef debug
//do something 
#else
//do something
#endif
</code></pre>
<p>本例中，提到了这几种预处理器命令:本文主要介绍的<code>#define</code>,以及依附于它而存在的命令<code>#ifdef</code>、<code>ifndef</code>、<code>else</code>、<code>endif</code>。这些命令，一般被称为“<strong>条件编译开关</strong>”。<s>(虽然我觉得叫预处理器条件分歧之类的更好听……)</s></p>
<p><code>ifdef</code>,展开缩写为：if define，表示<strong>如果定义了</strong>某个宏，则编译从此处开始直到一个<code>endif</code>标记的位置的代码。如果没有定义，则这一部分的代码不会被编译。<s>(就像被注释掉了一样)</s></p>
<p><code>ifndef</code>,展开缩写为：if not define，表示<strong>若未定义</strong>某个宏，则编译从此处开始直到一个<code>endif</code>标记的位置的代码。如果没有定义，则不会编译这些代码。</p>
<p><code>else</code>,表示否则，用于对上述两个预处理器条件命令的“条件表达式”(有没有定义)进行“取反”，只能用于这两个命令作为开头、<code>endif</code>命令作为结尾的区间内。换言之，现有一个区间，从<code>#ifdef test</code>到<code>#endif</code>，其中具备了一个<code>else</code>。那么，如果本程序在该区间开始前定义了宏<code>test</code>，那么，它将编译从<code>#ifdef test</code>后到<code>#else</code>前的部分。如果没有定义该宏，则将编译从<code>else</code>后到<code>endif</code>前的部分。</p>
<p><code>endif</code>,则是表示对于<code>ifdef</code>、<code>ifndef</code>的界限的命令。<code>endif</code>标记之后的所有代码，<strong>不受</strong>之前标记的<code>ifdef</code>、<code>else</code>和<code>ifndef</code>影响。</p>
<p>在大规模的开发过程中，特别是跨平台和系统的软件里，define最重要的功能是条件编译。就像这样，define可以用于跨平台:</p>
<pre><code class="language-cpp">#ifdef WINDOWS
//do something
#endif
#ifdef LINUX
//do something
#endif
</code></pre>
<p>这样就能通过在文件开始时写上<code>#define WINDOWS</code>、<code>#define LINUX</code>而简单地在Windows和Linux中编译不同的代码，而不需要麻烦地寻找哪些需要在Windows下编译，哪些需要在Linux下编译，然后在需要编译出对应平台的程序时注释掉另一部分……<s>(人生苦短，C++可能真比不上Python)</s></p>
<h2 id="5函数式的宏定义">5.函数式的宏定义</h2>
<p>这是一个<strong>宏定义的说明文章不可或缺的部分</strong>哦！敲黑板看重点啦！</p>
<p>~~众所周知，宏定义的知识博大精深。~~它甚至可以当做一个类似函数的东西来用！</p>
<p>例：</p>
<pre><code class="language-cpp">#define Add(a,b) (a)+(b);
</code></pre>
<p>这<strong>看起来似乎</strong>是一个实现将形式参数a与b相加并返回其值的函数。</p>
<p>我们观察这个宏定义，发现其中的结构其实是这样的：</p>
<pre><code class="language-cpp">#define [FunctionalMarcoName]([Argument1],[Argument2],...) [FunctionalMarcoValue]
</code></pre>
<p>同时要注意，FunctionalMarcoValue中对于形式参数的引用，应该使用小括号“()”将它们括起来，否则这些参数变成替换上去的字符串之后是否产生歧义将无法保证！</p>
<p>正因为如此上面这样写，与下面这个函数的效果其实也有差别哦！这些歧义也使函数式宏定义在某些意义下不安全。</p>
<pre><code class="language-cpp">int Add(int a,int b){
    return a+b;
}
</code></pre>
<p>我们考虑这样一个情况：<code>c*Add(a,b)*d</code>。</p>
<p>我们将会发现，正常来说，这行程序的逻辑是：先将a与b相加，将它们的和与c、d连乘。</p>
<p>可是很<s>不</s>明显的是，预处理器将会<s>像个憨憨一样</s>忠实地按照宏定义的定义，将程序文本中的<code>Add(a,b)</code>全给换成<code>a+b</code>！这样一来……它将会计算<code>c*a+b*d</code>的值！它的逻辑将会变成，分别将a与c、b与d相乘，然后将两个乘积相加！这是我们不期望的。一定要警惕！因此，我们应该使用这样写法才能保证安全：</p>
<pre><code class="language-cpp">#define Add(a,b) ((a)+(b))
</code></pre>
<p>宏定义为了防止错误而使用小括号的例子：</p>
<pre><code class="language-cpp">#define DUMP_WRITE(addr,nr) {memcpy(bufp,addr,nr); bufp += nr;}//BUG
#define DO(a,b) do{a+b;a++;}while(0)//应该使用的定义
</code></pre>
<p>当这样使用时：</p>
<pre><code class="language-cpp">if(addr)DUMP_WRITE(addr,nr);
else do_somethong_else();
</code></pre>
<p>宏将展开，程序变为：</p>
<pre><code class="language-cpp">if(addr){memcpy(bufp,addr,nr); bufp += nr;};
else do_something_else();
</code></pre>
<p>gcc在碰到else前面的“;”时就认为if语句已经结束，因而后面的else不在if语句中。而**采用do{} while(0)的定义，在任何情况下都没有问题。**而改为 <code>#define DO(a,b) do{a+b;a++;}while(0)</code> 的定义则在任何情况下都不会出错。</p>
<p>在<strong>避免危险情况出现的前提下</strong>，某些宏定义能够在极短的空间内完成极为复杂的操作！</p>
<p>比如，我们已经知道，宏是用来<strong>在原文本中替换字符串</strong>的。</p>
<p>因此，宏定义为我们提供了这几种操作：<code>#</code>、<code>@#</code>和<code>##</code>。先看一个例子：</p>
<pre><code class="language-cpp">#define paster(n) printf(&quot;token&quot;#n&quot;=%d\n&quot;,token##n)
</code></pre>
<p>我们了解：</p>
<p><code>#</code>用来将宏定义的形式参数转换为“作为字符串(string/char数组)数据类型存在的”字符串，并用于替换。</p>
<p><code>##</code>则用于将转换成“程序文本意义上的”字符串与其他程序文本相连接。</p>
<p>于是我们可以知道：</p>
<p><strong>设token1=1,token2=2,……,tokenn=n</strong></p>
<ul>
<li><code>paster(1)</code>等效于<code>printf(&quot;token1=%d\n&quot;,token1);</code>，输出&quot;token1=1&quot;,</li>
<li><code>paster(2)</code>等效于<code>printf(&quot;token2=%d\n&quot;,token2);</code>，输出&quot;token2=2&quot;;</li>
<li>……</li>
<li><code>paster(n)</code>等效于<code>printf(&quot;tokenn=%d\n&quot;,tokenn);</code>，输出&quot;tokenn=n&quot;。</li>
</ul>
<p>不过我们必须知道，这些处理是在预处理器中完成的！不要希望使用预处理器命令在程序运行过程中临时声明常规变量！不过这种写法不受影响：</p>
<pre><code class="language-cpp">#define newInt(n) int* (n)=new int(##n))
</code></pre>
<p>上例没有提到的写法是<code>@#</code>。它用于将后面的参数变为<strong>单字符(char)字符数据类型意义上的</strong>字符串。</p>
<p>原文作者通过引用另一个作者hustli的文章，提供了几个少见的例子用来阐明这些操作之间的差别,不过日常开发中几乎不会出现，看看就好吧：</p>
<pre><code class="language-cpp">#define A(x) T_##x
#define B（x) #@x
#define C（x) #x
</code></pre>
<p>我们假设：x=1，则有：</p>
<ul>
<li>A(1)等效于程序文本T_1</li>
<li>B(1)等效于字符'1'</li>
<li>C(1)等效于字符串&quot;1&quot;</li>
</ul>
<p><code>#define</code>的特殊操作就这些，很简单吧~</p>
<p>下一个知识点！就像一般函数都包含换行，写成函数形式的宏定义也能包含换行哦。</p>
<p>很出名的MFC官方例：</p>
<pre><code class="language-cpp">#define MACRO(arg1, arg2) do { /
/* declarations */ /
stmt1; /
stmt2; /
/* ... */ /
} while(0) /* (no trailing ; ) */
</code></pre>
<p>可见，要在每一个换行的时候加上一个&quot;/&quot;。这种写法其实非常麻烦，已经违背了实用性说明的原则，因此我其实不建议使用这种写法。<s>(同时希望大家都学着压行)</s></p>
<p>引用源的作者也这样认为。他在原文中对这个例子的评价是：&quot;非常的经典，虽然让人看了恶心&quot;。</p>
<p>对于函数式的宏定义，就说到这里了。下面是几个常用的方便例子：</p>
<ul>
<li>得到指定地址上的一个字节或字</li>
</ul>
<pre><code class="language-cpp">#define  MEM_B(x) (*((byte*)(x)))
#define  MEM_W(x) (*((word*)(x)))
</code></pre>
<ul>
<li>求最大值和最小值</li>
</ul>
<pre><code class="language-cpp">#define  MAX( x, y ) ( ((x) &gt; (y)) ? (x) : (y) )
#define  MIN( x, y ) ( ((x) &lt; (y)) ? (x) : (y) )
</code></pre>
<ul>
<li>得到一个field在结构体(struct)中的偏移量</li>
</ul>
<pre><code class="language-cpp">#define FPOS( type, field ) /
/*lint -e545 */ ( (dword) &amp;(( type *) 0)-&gt; field ) /*lint +e545 */
</code></pre>
<ul>
<li>得到一个结构体中field所占用的字节数</li>
</ul>
<pre><code class="language-cpp">#define FSIZ( type, field ) sizeof( ((type *) 0)-&gt;field )
</code></pre>
<ul>
<li>按照LSB格式把两个字节转化为一个Word</li>
</ul>
<pre><code class="language-cpp">#define  FLIPW( ray ) ( (((word) (ray)[0]) * 256) + (ray)[1] )
</code></pre>
<ul>
<li>按照LSB格式把一个Word转化为两个字节</li>
</ul>
<pre><code class="language-cpp">#define  FLOPW( ray, val ) /
  (ray)[0] = ((val) / 256); /
  (ray)[1] = ((val) &amp; 0xFF)
</code></pre>
<ul>
<li>得到一个变量的地址（word宽度）</li>
</ul>
<pre><code class="language-cpp">#define  B_PTR( var )  ( (byte *) (void *) &amp;(var) )
#define  W_PTR( var )  ( (word *) (void *) &amp;(var) )
</code></pre>
<ul>
<li>得到一个字的高位和低位字节</li>
</ul>
<pre><code class="language-cpp">#define  WORD_LO(xxx)  ((byte) ((word)(xxx) &amp; 255))
#define  WORD_HI(xxx)  ((byte) ((word)(xxx) &gt;&gt; 8))
</code></pre>
<ul>
<li>返回一个比X大的最接近的8的倍数</li>
</ul>
<pre><code class="language-cpp">#define RND8( x )    ((((x) + 7) / 8 ) * 8 )
</code></pre>
<ul>
<li>将一个字母转换为大写</li>
</ul>
<pre><code class="language-cpp">#define  UPCASE( c ) ( ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') ? ((c) - 0x20) : (c) )
</code></pre>
<ul>
<li>判断字符是不是10进值的数字</li>
</ul>
<pre><code class="language-cpp">#define  DECCHK( c ) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')
</code></pre>
<ul>
<li>判断字符是不是16进值的数字</li>
</ul>
<pre><code class="language-cpp">#define  HEXCHK( c ) (  ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9') ||/
                        ((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'F') ||/
                        ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'f') )
</code></pre>
<ul>
<li>防止溢出的一个方法</li>
</ul>
<pre><code class="language-cpp">#define  INC_SAT( val )  (val = ((val)+1 &gt; (val)) ? (val)+1 : (val))
</code></pre>
<ul>
<li>返回数组元素的个数</li>
</ul>
<pre><code class="language-cpp">#define  ARR_SIZE( a )  ( sizeof( (a) ) / sizeof( (a[0]) ) )
</code></pre>
<ul>
<li>返回一个无符号数n尾的值</li>
</ul>
<pre><code class="language-cpp">#define MOD_BY_POWER_OF_TWO( val, mod_by ) /
                           ( (dword)(val) &amp; (dword)((mod_by)-1) )
</code></pre>
<ul>
<li>对于IO空间映射在存储空间的结构，输入输出处理</li>
</ul>
<pre><code class="language-cpp">#define inp(port)         (*((volatile byte *) (port)))
#define inpw(port)        (*((volatile word *) (port)))
#define inpdw(port)       (*((volatile dword *)(port)))
#define outp(port, val)   (*((volatile byte *) (port)) = ((byte) (val)))
#define outpw(port, val)  (*((volatile word *) (port)) = ((word) (val)))
#define outpdw(port, val) (*((volatile dword *) (port)) = ((dword) (val)))
</code></pre>
<ul>
<li>使用一些宏跟踪调试</li>
</ul>
<p>这一部分原文说明得相当清晰，因此直接引用原文。</p>
<p>ANSI标准说明了五个预定义的宏名。它们是：</p>
<pre><code class="language-cpp">__LINE__
__FILE__

//__LINE__ 及 __FILE__ 宏指示，#line指令可以改变它的值，简单的讲，编译时，它们包含程序的当前行数和文件名。

__DATE__

//__DATE__ 宏指令含有形式为月/日/年的串,表示源文件被翻译到代码时的日期。

__TIME__

//__TIME__ 宏指令包含程序编译的时间。时间用字符串表示，其形式为：分：秒

__STDC__

//__STDC__ 宏指令的意义是编译时定义的。一般来讲，如果__STDC__已经定义，编译器将仅接受不包含任何非标准扩展的标准C/C++代码。如果实现是标准的,则宏__STDC__含有十进制常量1。如果它含有任何其它数,则实现是非标准的。
</code></pre>
<p>C++中还定义了 <code>__cplusplus</code>。__cplusplus 与标准c++一致的编译器把它定义为一个包含至少6为的数值。与标准c++不一致的编译器将使用具有5位或更少的数值。</p>
<p>如果编译器不是标准的,则可能仅支持以上宏名中的几个,或根本不支持。记住编译程序也许还提供其它预定义的宏名。</p>
<p>为了调试，我们还可以定义宏,例如:</p>
<p>当定义了_DEBUG,输出数据信息和所在文件所在行</p>
<pre><code class="language-cpp">#ifdef _DEBUG
#define DEBUGMSG(msg,date) printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_)
#else
#define DEBUGMSG(msg,date)
#endif
</code></pre>
<p>原文引用结束(看这个引用区域，像不像<code>ifdef</code>和<code>endif</code>呢?)</p>
<h2 id="6避免重复包含-重复定义">6.避免重复包含、重复定义</h2>
<p>由于头文件包含可以嵌套，那么 * / *.cpp / *.h / *.hpp 文件就有可能多次包含同一个头文件，就可能出现重复定义的错误，而且极难查出。<s>(我一个题的解题代码因为写反true和false这样极为???的问题，调了一个小时，如果我在数个文件中发生重复定义，怕是一年都调不出来……)</s></p>
<p>不过好在，有了<strong>条件编译开关</strong>，就可以避免重复包含(重复定义)啦！</p>
<p>例:</p>
<pre><code class="language-cpp">#ifndef __headerfileXXX__
#define __headerfileXXX__
//file
#endif
</code></pre>
<p>这样，我们就能保证即使头文件被多次包含，也不会导致里面的内容被多次定义啦！</p>
<h2 id="7总结">7.总结</h2>
<p>写了这么多，感觉也把<code>#define</code>这个预处理器命令整理的比较明白了吧。</p>
<p>同时，引用源也提供了大量的模板供给大家参考。感谢king110108巨佬的博客！</p>
<p>最后附上<code>#define</code>的英文原版定义，供给有兴趣的同学们参考：</p>
<pre><code>The define Directive
You can use the #define directive to give a meaningful name to a constant in your program. The two forms of the syntax are:
Syntax
define identifier token-stringopt
define identifier[( identifieropt, ... , identifieropt )] token-stringopt
</code></pre>
<p>那么，下篇博客再见咯！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 : 搜索 / DFS BFS ID A*]]></title>
        <id>https://malachiten.github.io/post/bi-ji-sou-suo</id>
        <link href="https://malachiten.github.io/post/bi-ji-sou-suo">
        </link>
        <updated>2019-09-27T06:08:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dfs-深度优先搜索">DFS / 深度优先搜索</h2>
<h3 id="寻找最优解这是最常用的方法">寻找最优解(这是最常用的方法)</h3>
<p>这种情况下,一般会有很多种不同的状态</p>
<pre><code class="language-cpp">void dfs(int cur){
    if(!check(cur)){
        //可行性剪枝。如果预测到某个状态以下的所有答案走到底均不可行，则剪去剩余搜索子树
        return;
    }
    if(cur无法比当前最优解更优)){
        //最优性剪枝。如果预测到某个状态下所有答案不能比当前ans更优，则剪去剩余搜索子树
        return;
    }
    标记当前状态已访问;
    存储当前状态的信息或者更新答案;//这一步在答案比较简单时可放到dfs的参数里面避免手动回溯
    for(枚举当前状态所有决策){
        dfs(next(cur));
    }
    //回溯:
    消除当前状态存储的信息并将其对答案的影响消去;
    将当前状态标记为未访问;
    //因为DFS算法必须通过回溯消去影响，因此又称为回溯算法
}
</code></pre>
<h3 id="寻找可行解">寻找可行解</h3>
<pre><code class="language-cpp">bool dfs(int cur){
    if(!check(cur)){
        //可行性剪枝
        return 0;
    }
    将当前状态标记为已访问;
    if(goal(cur)){
        记录可行解;
        return 1;
    }
    for(枚举当前状态的所有决策){
        if(dfs(next(cur))){
            return 1;
        }
    }
    将当前状态标记为未访问;
    return 0;
}
</code></pre>
<h3 id="dfs例题-luogu-p3154-cqoi2009循环赛">DFS例题: Luogu P3154 [CQOI2009]循环赛</h3>
<p>解析(<strong>转载自:<a href="http://www.cnblogs.com/autsky-jadek/">AutSky_JadeK的博客</a></strong>)</p>
<p><strong>思路</strong></p>
<ul>
<li>dfs+剪枝*4</li>
<li>1.只枚举一半的比赛，另一半直接得出</li>
<li>2.处理前缀和，若大于目标得分则剪枝</li>
<li>3.前缀和加上若接下来全胜的得分 仍小于目标得分，则剪枝。</li>
<li>4.枚举到每个人的最后一场比赛时直接用目标得分-前缀和 计算出最后一场的应得分。</li>
</ul>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
const int f[]={3,1,0,0};
int n,a[9],ans,Pre[9];
void dfs(int x,int y)
{
    if(Pre[x]&gt;a[x])return;
    if(Pre[x]+(n-y+1)*3&lt;a[x])return;
    if(x==n){ans++;return;}
    if(y==n)
      {
          int tmp=a[x]-Pre[x];
          if(tmp==2)return;
          Pre[y]+=f[tmp];
        dfs(x+1,x+2);
          Pre[y]-=f[tmp];
      }else{
    Pre[x]+=3;dfs(x,y+1);Pre[x]-=3;
    Pre[y]+=3;dfs(x,y+1);Pre[y]-=3;
    Pre[x]++;Pre[y]++;dfs(x,y+1);Pre[x]--;Pre[y]--;}
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
      scanf(&quot;%d&quot;,&amp;a[i]);
    dfs(1,2);
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
</code></pre>
<h3 id="dfs-枚举子集">DFS 枚举子集</h3>
<pre><code class="language-cpp">void dfs(int cur){
    if(cur){
        将cur添加进当前集合;
    }
    对子集的处理;
    for(int i=cur+1;i&lt;=n;i++){
        dfs(i);
    }
}
</code></pre>
<p>该算法处理集合 {1,2,3,4} 的过程如下:</p>
<pre><code>1
1 2
1 2 3
1 2 3 4
2
2 3
2 3 4
3
3 4
4
</code></pre>
<p>可见，该算法是<strong>将过程全部输出</strong>的DFS。</p>
<h2 id="bfs-广度优先搜索">BFS / 广度优先搜索</h2>
<pre><code class="language-cpp">void bfs(){
    q.push(st_start);
    vis[st_start]=true;
    while(!q.empty()){
        st U=q.front();
        for(i in next(st)){
            if(!vis[i]&amp;&amp;check(i)){
                vis[i]=true;
                i.d=st.d+1;
                if(goal(i)){
                    对最终状态的处理;
                    return;
                }
                q.push(i);
            }
        }
        q.pop();
    }
}
</code></pre>
<h2 id="id-dfs-迭代加深-深度优先搜索">ID DFS / 迭代加深 深度优先搜索</h2>
<p><strong>首先深度优先搜索k层，若没有找到可行解，再深度优先搜索k+1层，直到找到可行解为止</strong>。由于深度是从小到大逐渐增加的，所以当搜索到结果时可以保证搜索深度是最小的。这也是迭代加深搜索在一部分情况下可以代替广度优先搜索的原因。</p>
<h2 id="id-a-迭代加深-启发式搜索">ID A* / 迭代加深 启发式搜索</h2>
<pre><code class="language-cpp">void dfs(int cur){
    if(!check(cur)){
        //可行性剪枝。如果预测到某个状态以下的所有答案走到底均不可行，则剪去剩余搜索子树
        return;
    }
    if(/*估价函数*/cantBetter(cur)){
        //最优性剪枝。如果预测到某个状态下所有答案不能比当前ans更优，则剪去剩余搜索子树
        return;
    }
    标记当前状态已访问;
    存储当前状态的信息或者更新答案;//这一步在答案比较简单时可放到dfs的参数里面避免手动回溯
    for(枚举当前状态所有决策){
        dfs(next(cur));
    }
    //回溯:
    消除当前状态存储的信息并将其对答案的影响消去;
    将当前状态标记为未访问;
    //因为DFS算法必须通过回溯消去影响，因此又称为回溯算法
}
</code></pre>
<p>上面就是DFS的例子。其实ID A*就是用了启发式搜索的估价函数来改写最优性剪枝的方案。</p>
<h2 id="a-启发式搜索">A* / 启发式搜索</h2>
<ul>
<li>给广搜的状态一个估价函数，然后以估价参数为优先级使用优先队列代替队列。</li>
<li>重点是估价函数的设计。</li>
<li>估价函数h(s)是当前状态到目标状态的乐观估计最优解。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Luogu P1305 新二叉树 题解]]></title>
        <id>https://malachiten.github.io/post/p1305-xin-er-cha-shu-ti-jie</id>
        <link href="https://malachiten.github.io/post/p1305-xin-er-cha-shu-ti-jie">
        </link>
        <updated>2019-09-27T02:16:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="luogu-p1305-新二叉树-题解">Luogu P1305 新二叉树 题解</h1>
<p>很水的一道二叉树的题。其实并不需要真正利用在程序中构造二叉树进行求解的思路，而是利用二叉树的性质，找出规律，从而得出结果。</p>
<p>首先让我们看到题目：</p>
<h2 id="题目描述">题目描述</h2>
<p><strong>输入一串二叉树，用遍历前序打出。</strong></p>
<p>一看这个题目，似乎还无法得出一个规律。不过我们产生了问题：如何输入这一串二叉树？</p>
<h2 id="输入格式">输入格式</h2>
<p><strong>第一行为二叉树的节点数</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>≤</mo><mn>26</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(n≤26)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mclose">)</span></span></span></span>。</p>
<p><strong>后面n行，每一个字母为节点，后两个字母分别为其左右儿子。</strong></p>
<p><strong>空节点用星号表示。</strong></p>
<p>这样似乎就明了了：二叉树好像是通过这几种形式输入的：</p>
<ul>
<li>父亲 左儿子 右儿子</li>
<li>父亲 儿子 星号</li>
<li>父亲 星号 星号</li>
</ul>
<h2 id="输出格式">输出格式</h2>
<p><strong>前序排列的二叉树。</strong></p>
<p>既然要求这样输出，那么我们就可以寻找一下前序排列的规律：</p>
<p>在只有一个节点的情况下，这棵树长这样：</p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/08/22/mwEKi9.png" alt="1"></figure>
<p>它的前序排列自然是这样： <code>A</code></p>
<p>如果有了两个节点，则会变成这样：</p>
<figure data-type="image" tabindex="2"><img src="https://s2.ax1x.com/2019/08/22/mwEma4.png" alt="2"></figure>
<p>前序排列为： <code>AB</code></p>
<p>有了三个节点，会变成这样：</p>
<figure data-type="image" tabindex="3"><img src="https://s2.ax1x.com/2019/08/22/mwEnIJ.png" alt="3"></figure>
<p>前序排列为： <code>ABC</code></p>
<p>似乎还没有看出什么端倪。不过，让我们继续向下发展这棵二叉树：</p>
<figure data-type="image" tabindex="4"><img src="https://s2.ax1x.com/2019/08/22/mwEeZF.png" alt="4"></figure>
<p>前序排列： <code>ABDC</code></p>
<p>等等，怎么……顺序发生了一些变化？不再是依字母表顺序排列了？</p>
<p>再来！</p>
<figure data-type="image" tabindex="5"><img src="https://s2.ax1x.com/2019/08/22/mwEMGR.png" alt="5"></figure>
<p>前序排列： <code>ABDEC</code></p>
<p>原来规律是这样！</p>
<p><strong>每次第一个输入的序列（根节点及其子节点） 直接被加入前序中；</strong></p>
<p><strong>后续有两种儿子的，则忽略 “ 星号 ” 字符，将左儿子插入序列中其父亲节点后的一位，将右儿子插入序列中其左儿子节点的后一位。</strong></p>
<p><strong>仅有一种儿子的（表现形式为 父亲 儿子 星号 ），就简单将其儿子插入父亲节点的后一位即可。</strong></p>
<p><strong>找到父亲节点或左儿子的方法很简单：通过 <code>string</code> 类的这个成员函数即可完成：</strong></p>
<pre><code class="language-cpp">int find(string s);
</code></pre>
<p>这个成员函数的作用是<strong>返回子字符串s在原串中的位置</strong>。如果找不到，则返回：</p>
<pre><code class="language-cpp">string::npos
</code></pre>
<p>这个常量。（这个常量在不同的编译器中，有不同的值，虽然有些时候是 <code>static_cast&lt;size_type&gt;(-1)</code> ，但是可能其他时候会出差错(比如变成size_t的最大值,4294967295)。因此，我们在这里不写-1，而写这个常量更为保险。如果想继续深入了解这个用于标记<code>find</code>失败的常量，可以参考<a href="https://blog.csdn.net/JIEJINQUANIL/article/details/51789682">其他巨佬的博客</a>）</p>
<p>然后，我们再使用这个类里面的另一个函数 <code>insert</code> 向指定的位置插入代表子节点的字符：</p>
<pre><code class="language-cpp">void insert(int position,int length,string s);
</code></pre>
<p>它的作用是 <strong>从字符串中的第position个位置开始，插入length个字符，这些字符来源于s</strong> 。</p>
<p>这样，我们就可以得到这题的代码！</p>
<h3 id="代码如下">代码如下：</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
string t;
int n;
string s;
int main(){
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;s;
		if(t.find(s[0])==string::npos){t=s;continue;}
		if(s[1]!='*') t.insert(t.find(s[0])+1,1,s[1]);
		if(s[2]!='*') t.insert(t.find(s[1])+1,1,s[2]);
	}
	cout&lt;&lt;t&lt;&lt;endl;
}
</code></pre>
<h5 id="你觉得一次就能ac了">你觉得一次就能AC了？</h5>
<h4 id="并不是">并不是！</h4>
<h3 id="实际上">实际上！</h3>
<h2 id="这个只有20分">这个只有20分！！！</h2>
<figure data-type="image" tabindex="6"><img src="https://s2.ax1x.com/2019/08/22/mwmhAU.png" alt="x1"></figure>
<p>为什么？为什么只有20分？</p>
<p>很简单。下载数据后，你会发现这是因为这份代码没有考虑到这种数据的存在：</p>
<p><strong>“指示根节点及其子节点的第一行就含星号 ！！！”</strong></p>
<p>这种数据会带来什么影响？</p>
<p><strong>你的程序将把“ 星号 ”当作一种子节点！！！</strong></p>
<p>于是，之后的输出就完全混乱了。毕竟，由于第一行是特判全部输入，“ 星号 ”这样的鬼东西都被插进了字符串里面。</p>
<p>不过这样一来，你就找到了修改的思路：</p>
<p>使用 <code>string</code> 类的这个成员函数： <code>erase</code> ！</p>
<pre><code class="language-cpp">void erase(string::iterator start,string::iterator end);
</code></pre>
<p>直接运用它，产生的作用其实是消除<strong>一个字符串中的一段连续的长度</strong>。那么怎么达到消除<strong>全部指定字符</strong>（此处为标明了根节点及其儿子的字符串中的 “ * ” ）呢？</p>
<p>使用 <code>algorithm</code> 库中的 <code>remove</code> 函数！</p>
<pre><code class="language-cpp">iterator remove(iterator start,iterator end,auto c);
</code></pre>
<p>有了这个，我们就能够不断地清除字符串中的目标字符，并不断返回指向其未被删除元素的下一个元素的迭代器，从而使用erase函数清除它。</p>
<p>于是，我们得到了用于<strong>清除一段字符串中全部指定字符</strong>的完整代码：</p>
<pre><code class="language-cpp">erase(remove(string::iterator start,string::iterator end,char c),string::iterator end);
</code></pre>
<p>那么，新的代码也呼之欲出了！</p>
<h3 id="新代码如下">新代码如下：</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
string t;
int n;
string s;
int main(){
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;s;
		if(t.find(s[0])==string::npos){
			s.erase(remove(s.begin(),s.end(),'*'),s.end());
			t=s;
			continue;
		}
		if(s[1]!='*') t.insert(t.find(s[0])+1,1,s[1]);
		if(s[2]!='*') t.insert(t.find(s[1])+1,1,s[2]);
	}
	cout&lt;&lt;t&lt;&lt;endl;
}
</code></pre>
<h5 id="你又觉得这次就能ac了">你又觉得这次就能AC了？</h5>
<h4 id="并不是-2">并不是！</h4>
<h3 id="其实">其实！</h3>
<h2 id="这个只有30分">这个只有30分！！！</h2>
<figure data-type="image" tabindex="7"><img src="https://s2.ax1x.com/2019/08/22/mwm4NF.png" alt="x2"></figure>
<p><s>才多过了一个点啊……</s></p>
<p>这次又是为什么？？！</p>
<p>下载数据后发现，这次是栽在了一种之前<strong>从未考虑到的输入情况</strong>上。</p>
<p>这次导致出错的输入数据为：</p>
<ul>
<li>父亲 星号 儿子</li>
</ul>
<p>……</p>
<p><s>这也太坑了吧</s></p>
<p>我们为了AC此题，只能继续努力了……</p>
<p>这次更改并不需要什么新的技术，只需要添加几个判断即可绕过大坑。</p>
<h3 id="代码如下-2">代码如下：</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
string t;
int n;
string s;
int main(){
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;s;
		if(t.find(s[0])==string::npos){
			s.erase(remove(s.begin(),s.end(),'*'),s.end());
			t=s;
			continue;
		}
		if(s[1]!='*'&amp;&amp;s[2]!='*'){
			t.insert(t.find(s[0])+1,1,s[1]);
			t.insert(t.find(s[1])+1,1,s[2]);
		}
		if(s[1]=='*'&amp;&amp;s[2]!='*'){
			t.insert(t.find(s[0])+1,1,s[2]);
		}
		if(s[1]!='*'&amp;&amp;s[2]=='*'){
			t.insert(t.find(s[0])+1,1,s[1]);
		}
	}
	cout&lt;&lt;t&lt;&lt;endl;
}
</code></pre>
<p>看着屏幕上蓝色方块上转着白色的圈圈，你想到：之前（指20分变30分那次）做了那么大的修改，才多过了一个点，想必这个算法还存在很多问题吧……难不成<strong>还得再重写几次？？！</strong></p>
<p>然后……</p>
<figure data-type="image" tabindex="8"><img src="https://s2.ax1x.com/2019/08/22/mwK3hF.png" alt="v"></figure>
<p>？？？？？？</p>
<h2 id="过了就过了">过了？？！就过了？？？？？！</h2>
<p>历经千辛万苦，终于过了啊……<s>（接受现实）</s></p>
<p><s>bilibili干杯！（好像并没有什么不对）</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[压行技巧]]></title>
        <id>https://malachiten.github.io/post/zhong-ji-ya-xing-ji-qiao</id>
        <link href="https://malachiten.github.io/post/zhong-ji-ya-xing-ji-qiao">
        </link>
        <updated>2019-09-27T02:07:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="压行技巧">压行技巧</h1>
<p>Luogu P1914 小书童——密码 可能最短的AC代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
int main(){
	int n; std::string str;
	std::cin&gt;&gt;n&gt;&gt;str;
	for(int i=0;i&lt;str.length();i++) std::cout&lt;&lt;(char)(str[i]+n&gt;122?str[i]+n-26:str[i]+n);
}
</code></pre>
<p>其实是采用了这些方法来缩减长度：</p>
<p>1.采用**略去using namespace std;**的方法减去一行长度。代价是使用名称空间<code>std</code>中的函数或对象时必须添加<code>std::</code>前缀。不过本方法的用处在压行，对于在一行中增加长度的代价，可以忽略不计。</p>
<p>2.使用<strong>三目运算符</strong>在一行中实现</p>
<pre><code class="language-cpp">if(/*the value of the expression isn't False(0)*/){
    //do something
}else{
    //do something
}
</code></pre>
<p>的效果，从而将三行压成一行。</p>
<p>3.从C++0x(C++11)标准开始，主函数末尾即可略去<code>return 0;</code>。采用这一特性，可以省掉一行。</p>
]]></content>
    </entry>
</feed>