
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>Screeps 教程 | Malachite</title>
<meta name="description" content="夕焼けの中に吸い込まれて消えてった">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://malachiten.github.io/favicon.ico?v=1572505109874">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://malachiten.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://malachiten.github.io">
        <img class="avatar" src="https://malachiten.github.io/images/avatar.png?v=1572505109874" alt="" width="32px" height="32px">
      </a>
      <a href="https://malachiten.github.io">
        <h1 class="site-title">Malachite</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">Screeps 教程</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2019-10-22</span>
            
          </div>
          <div class="post-content">
            <p>不了解的人可以前往<a href="https://screeps.com/">Screeps官网</a>了解一下，也许我们能成为同一个<code>Shard</code>的邻居。</p>
<p>不过，看完简介也不要贸然在Steam购买，我打教程都打了不止一整天，肯定是退不了款的。在真正接触到本身之前，也不会知道它到底怎样玩。不过，在官网上有它的 Live DEMO 可供试玩，建议尝试。</p>
<h2 id="让我们开始吧界面简介">让我们开始吧：界面简介</h2>
<blockquote>
<p>Let's begin. This is a playing field called a &quot;room&quot;. In the real game, rooms are connected to each other with exits, but in the simulation mode only one room is available to you.</p>
</blockquote>
<p>屏幕中间的一大片叫做<code>room</code>，在实际游戏中，它与其他房间相连，但是在教程这里，它仅对你开放。</p>
<blockquote>
<p>The object in the center of the screen is your first spawn, your colony center.</p>
</blockquote>
<p>屏幕中间的物体是你的<code>creep</code>们的生成器。</p>
<blockquote>
<p>You play by writing code in the panel in the bottom of the screen.</p>
</blockquote>
<p>你要操作这个游戏，就得在屏幕下方的黑框框里面打代码，嘿嘿嘿。</p>
<blockquote>
<p>You can see all the characteristics of your creep (or other objects) by utilizing the &quot;View&quot; action.</p>
</blockquote>
<p>你要想看到你的所有物体的信息，需要切换到<code>View</code>视图。具体一点，点击屏幕上方的眼睛<br>
图标就可以了。</p>
<blockquote>
<p>Hide the editor panel with Alt+Enter and select your creep with the help of the &quot;View&quot; action.</p>
</blockquote>
<p>当你需要查看信息时，按下<code>Alt+Enter</code>隐藏编辑器，然后点击目标。</p>
<blockquote>
<p>Here you can see the characteristics of the object you are now looking at. Values of each characteristic and functions of body parts are described in the documentation.</p>
</blockquote>
<p>这样，在屏幕右侧工具栏中，你就能看见所选目标的全部属性。</p>
<h2 id="第一个要接触的东西控制台">第一个要接触的东西：控制台</h2>
<p><code>Console</code> 控制台 其实是一个<code>JavaScript</code>的 <strong>REPL</strong> (读入 - 执行 - 打印 - 循环) 。</p>
<p>输入一行或一块<code>JavaScript</code>语句，然后按下<code>Enter</code>执行。</p>
<blockquote>
<p>Your command returns a response <s>or execution error</s> in the console below. All output is duplicated into your browser console (Ctrl+Shift+J) where you can expand objects for debugging purposes. You can open and close the bottom panel by pressing Alt+Enter.</p>
</blockquote>
<p>你的命令返回一个结果或一个错误，将立即显示在控制台。</p>
<blockquote>
<p>It is time to put the creep to work! This yellow square is an energy source — a valuable game resource. It can be harvested by creeps with one or more <code>WORK</code> body parts and transported to the spawn by creeps with <code>CARRY</code> parts.</p>
</blockquote>
<p>下面测试下控制台，在控制台中生成一个具有<code>WORK</code>,<code>CARRY</code>,<code>MOVE</code> 的身体部件的 Creep 。</p>
<p>其实这使用了 API ：</p>
<blockquote>
<p>Game.spawns<br>
StructureSpawn.spawnCreep</p>
</blockquote>
<pre><code class="language-javascript">Game.spawns['Spawn1'].spawnCreep( [WORK, CARRY, MOVE], 'Harvester1' );
</code></pre>
<p>这就是我们的第一个<code>Creep</code>，可见，它是由名为<code>Spawn1</code>的生成器生成的，，且名为<code>Harvester1</code>。</p>
<blockquote>
<p>You can address your spawn by its name the following way: Game.spawns['Spawn1'].</p>
</blockquote>
<p>这就是生成器的路径：<code>Game.spawns['Spawn1']</code>。</p>
<blockquote>
<p>Great! You now have a creep with the name &quot;Harvester1&quot; that you can control.</p>
</blockquote>
<h2 id="然后就是最重要的脚本中的-main-模块">然后就是最重要的，脚本中的 Main 模块</h2>
<blockquote>
<p>To give your creep a permanently working command, the console is not enough, since we want the creep to work all the time. So we'll be using the Script tab rather than the console.</p>
</blockquote>
<p>控制台不能满足我们给<code>creep</code>编写工作脚本的需求。我们需要使用脚本编辑器来编写这些脚本。</p>
<blockquote>
<p>Here you can write scripts that will run on a permanent basis, each game tick in a loop. It allows writing constantly working programs to control behaviour of your creeps which will work even while you are offline (in the real game only, not the Simulation Room mode).</p>
</blockquote>
<p>只要你写了脚本，它就会一直循环执行，每<code>Tick</code>一次，即使你离线，也是如此，除非你的<strong>所有</strong>据点都被人炸没了。值得一提，<code>Tick</code>是游戏的时间单位，具体长度由服务器性能及建立据点的玩家数目决定。Screeps一共包含四个服务器，越老的服务器运行速度越慢。最老的服务器<code>shard0</code>的平均ticks时长甚至达到了惊人的5.9秒。也就是说，每过5.9秒。你的代码才会被运行一次。玩家越来越不满缓慢的游戏速度，甚至决定到其他服务器从头开始。</p>
<blockquote>
<p>To commit a script to the game so it can run, use this button or Ctrl+Enter.</p>
</blockquote>
<p>按下<code>Ctrl + Enter</code>提交你的代码。跟发个 QQ 消息一样简单。</p>
<blockquote>
<p>To send a creep to harvest energy, you need to use the methods described in the documentation section below. Commands will be passed each game tick. The harvest method requires that the energy source is adjacent to the creep.</p>
</blockquote>
<p>为了让一个<code>creep</code>收集能量，你需要学习官方 API 文档中定义的方法。执行这些方法，以让它们工作。</p>
<blockquote>
<p>You give orders to a creep by its name this way: Game.creeps['Harvester1']. Use the FIND_SOURCES constant as an argument to the Room.find method.</p>
</blockquote>
<p>具体来说，在收集资源时，需要用到<code>Game.creeps[]</code>数组、将常数<code>FIND_SOURCES</code>作为参数的方法<code>Room.find()</code>。</p>
<p>这次使用的 API 如下，可以在官方文档中查到：</p>
<blockquote>
<p>Game.creeps<br>
RoomObject.room<br>
Room.find<br>
Creep.moveTo<br>
Creep.harvest</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">module.exports.loop = function () {
    var creep = Game.creeps['Harvester1'];
    var sources = creep.room.find(FIND_SOURCES);
    if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
        creep.moveTo(sources[0]);
    }
}
</code></pre>
<p>这时你的唯一一个<code>Creep</code>会向地图上最近的黄点移动，然后开始工作。这个黄点称为<code>Source</code>，即能量源。</p>
<blockquote>
<p>A bubbling yellow spot inside the creep means that it has started collecting energy from the source.</p>
</blockquote>
<p>如果一个<code>Creep</code>内部的颜色变成亮黄色，则说明它正在收集能量源中的能量。</p>
<p><strong>It works!</strong></p>
<p>可是，当其收集满自身容量之后，就需要返回出生点 (即<code>Creep</code>的生成器，<code>Spawn</code>) 。</p>
<blockquote>
<p>To make the creep transfer energy back to the spawn, you need to use the method <code>Creep.transfer</code>. However, remember that it should be done when the creep is next to the spawn, so the creep needs to walk back.</p>
</blockquote>
<p>使用 API 提供的方法<code>Creep.transfer</code>来达成这个任务。</p>
<blockquote>
<p>If you modify the code by adding the check <code>.carry.energy</code> &lt; <code>.carryCapacity</code>to the creep, it will be able to go back and forth on its own, giving energy to the spawn and returning to the source.</p>
</blockquote>
<p>这是算法的实现方法：简单判断目标<code>Creep</code>的携带能量是否小于其最大容量。如果小于，则一直让它收集。否则，令其返回<code>Spawn</code>，将能量注入其中。</p>
<p>要实现这些，可参见 API 文档：</p>
<blockquote>
<p>Creep.transfer<br>
Creep.carry<br>
Creep.carryCapacity</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">module.exports.loop = function () {
    var creep = Game.creeps['Harvester1'];

    if(creep.carry.energy &lt; creep.carryCapacity) {
        var sources = creep.room.find(FIND_SOURCES);
        if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
            creep.moveTo(sources[0]);
        }
    }
    else {
        if( creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE ) {
            creep.moveTo(Game.spawns['Spawn1']);
        }
    }
}
</code></pre>
<blockquote>
<p>Great! This creep will now work as a harvester until it dies. Remember that almost any creep has a life cycle of 1500 game ticks, then it &quot;ages&quot; and dies (this behavior is disabled in the Tutorial).</p>
</blockquote>
<p>这样就完成了让它一直收集能量直到死亡的规划。</p>
<p>值得一提的是，每个<code>Creep</code>在出生时均具备 1500 个<code>Ticks</code>的生命时长，之后逐步减少。不过，这个行为在教程中被禁用了，目前你的<code>Creep</code>具有无限寿命。</p>
<blockquote>
<p>Let's create another worker creep to help the first one. It will cost another 200 energy units, so you may need to wait until your harvester collects enough energy. The spawnCreep method will return an error code <code>ERR_NOT_ENOUGH_ENERGY</code> (-6) until then.</p>
</blockquote>
<p>我们马上就要建造另一个工人<code>Creep</code>来帮助减轻第一个的负担了。这会消耗 200 个之前的工人收集来的能量单位，所以你需要等待你的收集者收集足够的能量。在 API 中提供的<code>spawnCreep</code>方法在没有足够能量的时候，不会生成<code>Creep</code>，而是返回一个错误常量<code>ERR_NOT_ENOUGH_ENERGY</code>。值得一提的是，它的值为 -6 。</p>
<blockquote>
<p>Remember: to execute code once just type it in the &quot;Console&quot; tab.</p>
</blockquote>
<p>像这种只需要执行一次的命令，可以只用将其输入到控制台。</p>
<p>那么具体的指令就很简单了：</p>
<pre><code class="language-javascript">Game.spawns['Spawn1'].spawnCreep( [WORK, CARRY, MOVE], 'Harvester2' );
</code></pre>
<blockquote>
<p>The second creep is ready, but it won't move until we include it into the program.</p>
</blockquote>
<p>由于我们根本没写它的脚本，所以它暂时还不会动。</p>
<blockquote>
<p>To set the behavior of both creeps we could just duplicate the entire script for the second one, but it's much better to use the for loop against all the screeps in <code>Game.creeps</code>.</p>
</blockquote>
<p>我们可以单独为它编写脚本，但是我们注意到它的脚本和第一个几乎没有差别。为了<s>偷懒</s>提高代码复用率，我们可以使用循环来解决这个问题。</p>
<p>Code:</p>
<pre><code class="language-javascript">module.exports.loop = function () {
    for(var name in Game.creeps) {
        var creep = Game.creeps[name];

        if(creep.carry.energy &lt; creep.carryCapacity) {
            var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0]);
            }
        }
        else {
            if(creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                creep.moveTo(Game.spawns['Spawn1']);
            }
        }
    }
}
</code></pre>
<h2 id="为了更加极致的脱发体验我们还可以编写其他模块达成目的">为了更加极致的脱发体验，我们还可以编写其他模块达成目的。</h2>
<blockquote>
<p>Now let's improve our code by taking the workers' behavior out into a separate module. Create a module called role.harvester with the help of the Modules section on the left of the script editor and define a run function inside the <code>module.exports</code> object, containing the creep behavior.</p>
</blockquote>
<p>除了<code>Main</code>之外的模块就像 C / C++ 中的头文件，供给<code>Main</code>调用。我们可以使用这个特性，编写一个专们描述收集能量的工人<code>Creep</code>的行为的模块。</p>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = {

    /** @param {Creep} creep **/
    run: function(creep) {
	    if(creep.carry.energy &lt; creep.carryCapacity) {
            var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0]);
            }
        }
        else {
            if(creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                creep.moveTo(Game.spawns['Spawn1']);
            }
        }
	}
};

module.exports = roleHarvester;
</code></pre>
<p>这份脚本描述了所有具有<code>Harvester</code>性质的<code>Creep</code>的工作流程，此处不再赘述。</p>
<p>那么现在，我们如何编写我们的<code>Main</code>来调用刚刚写的这些呢？</p>
<blockquote>
<p>Now you can rewrite the main module code, leaving only the loop and a call to your new module by the method <code>require('role.harvester')</code>.</p>
</blockquote>
<p>明显，只需要使用<code>require('role.harvester')</code>的语句，就可以达成与 C / C++ 中<code>#include &quot;role_harvester.hpp&quot;</code>一样的效果了。</p>
<blockquote>
<p>It's much better now!</p>
</blockquote>
<p>头发少多了！</p>
<blockquote>
<p>By adding new roles and modules to your creeps this way, you can control and manage the work of many creeps. In the next Tutorial section, we’ll develop a new creep role.</p>
</blockquote>
<p>通过给你的<code>creep</code>们添加新的角色和模块，你能控制并管理大量的<code>creeps</code>。下一步，我们要开发一个新的角色。</p>
<h2 id="升级房间控制器roomcontroller">升级房间控制器RoomController</h2>
<blockquote>
<p>In this Tutorial section we’ll talk about a key strategic object in your room: <code>Room Controller</code>. By controlling this invincible structure you can build facilities in the room. The higher the controller level, the more structures available to build.</p>
</blockquote>
<p>在设计这个新的角色之前，我们需要认识一个新东西，叫<code>Room Controller</code>。这个东西的等级决定了你能在你房间里面建造哪些结构。</p>
<blockquote>
<p>You will need a new worker creep to upgrade your controller level. Let's call it &quot;Upgrader1&quot;. In following sections we'll discuss how to create creeps automatically, but for now let's send a command manually to the console.</p>
</blockquote>
<p>为了给它升级，我们要造一个名为“Upgrader1”的新工人。</p>
<p>在以后的教程中我们会认识到如何自动生成<code>creeps</code>，不过这次，我们还是使用控制台吧。</p>
<p>Code:</p>
<pre><code class="language-javascript">Game.spawns['Spawn1'].spawnCreep( [WORK, CARRY, MOVE], 'Upgrader1' );
</code></pre>
<p>它具体生成了什么，想必不用多说了。</p>
<blockquote>
<p>Creep &quot;Upgrader1&quot; went to perform the same task as the harvester, but we don't want it to. We need to differentiate creep roles.</p>
</blockquote>
<p>目前它暂时还只能像<code>harvester</code>一样工作。不过，我们得干点什么让它与老前辈不一样。</p>
<blockquote>
<p>To do that, we need to utilize the memory property of each creep that allows writing custom information into the creep's &quot;memory&quot;. Let's do this to assign different roles to our creeps.</p>
<p>All your stored memory is accessible via the global Memory object. You can use it any way you like.</p>
</blockquote>
<p>我们使用<code>memory</code>来区分不同<code>creeps</code>各自的角色。实际上，我们可以往一个<code>creep</code>的“记忆”里面写任何东西来达成我们的任意目的。</p>
<p>Code:</p>
<pre><code class="language-javascript"> Game.creeps['Harvester1'].memory.role = 'harvester';
 Game.creeps['Upgrader1'].memory.role = 'upgrader';
</code></pre>
<blockquote>
<p>You can check your creeps' memory in either the creep information panel on the left or on the <code>Memory</code> tab.</p>
</blockquote>
<p>通过检查<code>Memory</code>面板，你可以确认“你的<code>Creeps</code>有没有深入贯彻你的思想”。</p>
<blockquote>
<p>Now let's define the behavior of the new creep. Both creeps should harvest energy, but the creep with the role harvester should bring it to the spawn, while the creep with the role upgrader should go to the Controller and apply the function <code>upgradeController</code> to it (you can get the Controller object with the help of the <code>Creep.room.controller</code> property).</p>
</blockquote>
<p>现在开工了，去设计新<code>creep</code>的行为。每一个<code>creep</code>都应当收集能量，但是<code>harvester</code>应该把能量送到<code>spawn</code>，而<code>upgrader</code>应该把能量送去<code>Room Controller</code>。</p>
<blockquote>
<p>In order to do this, we’ll create a new module called <code>role.upgrader</code>.</p>
</blockquote>
<p>为此，我们应当创建一个名为<code>role.upgrader</code>的<code>module</code>。</p>
<p>这用到了这些 API ：</p>
<blockquote>
<p>RoomObject.room<br>
Room.controller<br>
Creep.upgradeController</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleUpgrader = {

    /** @param {Creep} creep **/
    run: function(creep) {
	    if(creep.carry.energy == 0) {
            var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0]);
            }
        }
        else {
            if(creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {
                creep.moveTo(creep.room.controller);
            }
        }
	}
};

module.exports = roleUpgrader;
</code></pre>
<blockquote>
<p>In our main module, all creeps run the same role. We need to divide their behavior depending on the previously defined property <code>Creep.memory.role</code> by connecting the new module.</p>
</blockquote>
<p>目前我们的<code>main</code>模块中，所有<code>creeps</code>还被当作同一种角色处理。这是不行的：如果<code>main</code>说是一样的就是一样的，那我多没面子。所以</p>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleUpgrader = require('role.upgrader');

module.exports.loop = function () {

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
    }
}
</code></pre>
<p>听我的！听我的！听我的！</p>
<p>所以——</p>
<blockquote>
<p>Perfect, you have upgraded your Controller level!</p>
</blockquote>
<p><code>WA</code>，你的头发又少了几根！</p>
<blockquote>
<p><strong>Important</strong>: If you don’t upgrade your Controller within 20,000 game ticks, it loses one level. On reaching level 0, you will lose control over the room, and another player will be able to capture it freely. Make sure that at least one of your creeps regularly performs the function upgradeController.</p>
</blockquote>
<p>很重要的一点：如果你连续两万个<code>tick</code>不升级你的<code>Room Controller</code>，它就会降级。当它降到 0 级时，你就失去了这个房间的控制权。</p>
<h2 id="建造新结构">建造新结构</h2>
<blockquote>
<p>The Controller upgrade gives access to some new structures: walls, ramparts, and extensions. We’ll discuss walls and ramparts in the next Tutorial section, for now let’s talk about extensions.</p>
</blockquote>
<p>控制器一旦被升级，你就可以获取建造新结构的权限。这些结构主要有：地形墙、防御壁垒，以及扩展。我们教程的下一步会讲到地形墙和城墙，这次只会讲到扩展。</p>
<blockquote>
<p><strong>Extensions</strong> are required to build larger creeps. A creep with only one body part of one type works poorly. Giving it several <strong>WORKs</strong> will make him work proportionally faster.</p>
</blockquote>
<p>当你觉得你的<code>creeps</code>工作能力不行的时候，你想要往你的<code>creeps</code>身上插更多的身体部件。给他更强的工作能力。</p>
<blockquote>
<p>However, such a creep will be costly and a lone spawn can only contain 300 energy units. To build creeps costing over 300 energy units you need spawn extensions.</p>
</blockquote>
<p>可是，这样的<code>creeps</code>势必造成建造花费的提高。你的<code>spawn</code>只能容纳 300 单位的能量，是远远不够的。建造花费高于 300 单位能量的 <code>creeps</code>，就需要使用扩展。</p>
<blockquote>
<p>The second Controller level has 5 extensions available for you to build.This number increases with each new level.</p>
</blockquote>
<p>控制器等级 2 允许你建造 5 个扩展。而且这个数量还会随<code>Room Controller</code>等级不断提升。</p>
<blockquote>
<p>You can place extensions at any spot in your room, and a spawn can use them regardless of the distance. In this Tutorial we have already placed corresponding construction sites for your convenience.</p>
</blockquote>
<p>你可以将扩展放在房间的任何位置，而且一个<code>spawn</code>可以在任何距离使用它们。在教程中，我们已经将其放置在构造好的位置上。</p>
<blockquote>
<p>Let’s create a new creep whose purpose is to build structures. This process will be similar to the previous Tutorial sections. But this time let’s set <code>memory</code> for the new creep right in the method <code>Spawn.spawnCreep</code> by passing it in the third argument.</p>
</blockquote>
<p>我们建造一种新类型的<code>creep</code>来干这事。这种事情非常简单，我们之前都做得多了。不过，这次我们试试新的写法：使用第三个参数来传递内存值，免去重新设置内存的麻烦。</p>
<p>Code:</p>
<pre><code class="language-javascript">Game.spawns['Spawn1'].spawnCreep( [WORK, CARRY, MOVE], 'Builder1',
    { memory: { role: 'builder' } } );
</code></pre>
<p>在<code>builder</code>的定义未声明时，它将不会移动。</p>
<blockquote>
<p>As before, let’s move this role into a separate module role.builder. The building is carried out by applying the method <code>Creep.build</code> to the construction sites searchable by <code>Room.find(FIND_CONSTRUCTION_SITES)</code>. The structure requires energy which your creep can harvest on its own.</p>
</blockquote>
<p>像之前一样，我们需要设计一个新<code>module</code>。</p>
<p><code>Creep.build</code>和<code>Room.find(FIND_CONSTRUCTION_SITES)</code>两个方法可以帮到我们。</p>
<blockquote>
<p>To avoid having the creep run back and forth too often but make it deplete the cargo, let’s complicate our logic by creating a new Boolean variable <code>creep.memory.building</code> which will tell the creep when to switch tasks. We'll also add new <code>creep.say</code> call and <code>visualizePathStyle</code> option to the moveTo method to visualize the creep's intentions.</p>
</blockquote>
<p>为了避免它来回频繁运行耗尽计算资源，我们设计一个布尔值<code>creep.memory.building</code>来控制它究竟是挖矿还是建造。同时，我们打开可视化其移动路径的选项，并使用<code>creep.say</code>方法，来使它所处的模式可视化。</p>
<p>这次用到了这些 API :</p>
<blockquote>
<p>RoomObject.room<br>
Room.find<br>
Creep.build<br>
Creep.say</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleBuilder = {

    /** @param {Creep} creep **/
    run: function(creep) {

	    if(creep.memory.building &amp;&amp; creep.carry.energy == 0) {
            creep.memory.building = false;
            creep.say('🔄 harvest');
	    }
	    if(!creep.memory.building &amp;&amp; creep.carry.energy == creep.carryCapacity) {
	        creep.memory.building = true;
	        creep.say('🚧 build');
	    }

	    if(creep.memory.building) {
	        var targets = creep.room.find(FIND_CONSTRUCTION_SITES);
            if(targets.length) {
                if(creep.build(targets[0]) == ERR_NOT_IN_RANGE) {
                    creep.moveTo(targets[0], {visualizePathStyle: {stroke: '#ffffff'}});
                }
            }
	    }
	    else {
	        var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0], {visualizePathStyle: {stroke: '#ffaa00'}});
            }
	    }
	}
};

module.exports = roleBuilder;
</code></pre>
<blockquote>
<p>Let’s create a call of the new role in the main module and wait for the result.</p>
</blockquote>
<p>这样就可以了。不过我们还得改改主模块<code>Main</code></p>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleBuilder = require('role.builder');

module.exports.loop = function () {

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'builder') {
            roleBuilder.run(creep);
        }
    }
}
</code></pre>
<blockquote>
<p>Your extensions have been built. Now let’s learn to work with them.</p>
</blockquote>
<p>这样一来，扩展就修建好了。那么现在怎么让它们工作呢？</p>
<blockquote>
<p>Maintaining extensions requires you to teach your harvesters to carry energy not just to a spawn but also to extensions. To do this, you can either use the <code>Game.structures</code> object or search within the room with the help of <code>Room.find(FIND_STRUCTURES)</code>. In both cases, you will need to filter the list of items on the condition structure.<code>structureType == STRUCTURE_EXTENSION</code> (or, alternatively, <code>structure instanceof StructureExtension</code>) and also check them for energy load, as before.</p>
</blockquote>
<p>先要教会<code>havester</code>将收集的资源注入扩展。否则这些扩展用处不大。</p>
<p>所用 API：</p>
<blockquote>
<p>Game.structures<br>
Room.find<br>
StructureExtension</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = {

    /** @param {Creep} creep **/
    run: function(creep) {
	    if(creep.carry.energy &lt; creep.carryCapacity) {
            var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0], {visualizePathStyle: {stroke: '#ffaa00'}});
            }
        }
        else {
            var targets = creep.room.find(FIND_STRUCTURES, {
                    filter: (structure) =&gt; {
                        return (structure.structureType == STRUCTURE_EXTENSION || structure.structureType == STRUCTURE_SPAWN) &amp;&amp;
                            structure.energy &lt; structure.energyCapacity;
                    }
            });
            if(targets.length &gt; 0) {
                if(creep.transfer(targets[0], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                    creep.moveTo(targets[0], {visualizePathStyle: {stroke: '#ffffff'}});
                }
            }
        }
	}
};

module.exports = roleHarvester;
</code></pre>
<blockquote>
<p>To know the total amount of energy in the room, you can use the property <code>Room.energyAvailable</code>. Let’s add the output of this property into the console in order to track it during the filling of extensions.</p>
</blockquote>
<p>同时，为了得知房间能源总数，我们需要使用方法<code>Room.energyAvailable</code>，在<code>Main</code>中添加一个输出，让系统输出总能源信息到控制台。</p>
<p>可能用到的 API 文档是：</p>
<blockquote>
<p>Room.energyAvailable</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleBuilder = require('role.builder');

module.exports.loop = function () {

    for(var name in Game.rooms) {
        console.log('Room &quot;'+name+'&quot; has '+Game.rooms[name].energyAvailable+' energy');
    }

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'builder') {
            roleBuilder.run(creep);
        }
    }
}
</code></pre>
<blockquote>
<p>In total, we have 550 energy units in our spawn and extensions. It is enough to build a creep with the body [WORK,WORK,WORK,WORK,CARRY,MOVE,MOVE]. This creep will work 4 times faster than a regular worker creep. Its body is heavier, so we’ll add another MOVE to it. However, two parts are still not enough to move it at the speed of a small fast creep which would require 4xMOVEs or building a road.</p>
</blockquote>
<p>准备好造个大家伙了吗？具体有多大，见英文部分。（笑）</p>
<blockquote>
<p>Building this creep took energy from all storages and completely drained them.</p>
</blockquote>
<p>为了侍候这个大家伙，我们的所有能量存储器都耗尽了。</p>
<blockquote>
<p>As you can see on the right panel, this powerful creep harvests 8 energy units per tick. A few such creeps can completely drain an energy source before it refills thus giving your colony a maximum energy boost.</p>
</blockquote>
<p>不过当你看到它的面板时，你会觉得这是非常值得的。它能够在 1 <code>Tick</code> 中采集 8 单位能量，给予你极大的能源支持。</p>
<blockquote>
<p>Hence, by upgrading your Controller, constructing new extensions and more powerful creeps, you considerably improve the effectiveness of your colony work. Also, by replacing a lot of small creeps with fewer large ones, you save CPU resources on controlling them which is an important prerequisite to play in the online mode.</p>
</blockquote>
<p>可见，升级控制器，建造新扩展和更多强大的<code>Creeps</code>，能够提高工作效率，节省下CPU时间。值得一提，为了避免有玩家使用死循环卡系统，对于每一个玩家的代码，系统都有一个CPU时间限制，如果你的程序运行超出了CPU时间，则会被强制打断，<code>continue</code>到下一次循环中。当然，购买订阅甚至终身无限CPU时间的巨佬可以无视CPU时间限制。</p>
<h2 id="全自动生产新creeps">全自动生产新Creeps</h2>
<blockquote>
<p>Until now, we have created new creeps directly in the console. It’s not a good idea to do it constantly since the very idea of Screeps is making your colony control itself. You will do well if you teach your spawn to produce creeps in the room on its own.</p>
</blockquote>
<p>直到现在，我们都在使用控制台新建<code>creep</code>。由于真实游戏中所有<code>creeps</code>有 1500 <code>ticks</code>的生命限制，你必须要这并不是一个能让你一直挂着机摸鱼的好办法。我们需要找出让机器给我们自动创建<code>creep</code>的办法。</p>
<blockquote>
<p>This is a rather complicated topic and many players spend months perfecting and refining their auto-spawning code. But let’s try at least something simple and master some basic principles to start with.</p>
</blockquote>
<p>为了改进自己的自动创建器，很多玩家花费了几个月的时间。不过我们用不着那么麻烦——这只是个教程，搞个够用的就行了。</p>
<blockquote>
<p>You will have to create new creeps when old ones die from age or some other reasons. Since there are no events in the game to report death of a particular creep, the easiest way is to just count the number of required creeps, and if it becomes less than a defined value, to start spawning.</p>
</blockquote>
<p>由于游戏不提供<code>creeps</code>死亡时的全局广播，最简单的确认是否需要新建<code>creeps</code>的方法就是……emmm，数数。没错，数现在你自己有了多少<code>creeps</code>，而实际上需要多少。如果不够，就造。</p>
<blockquote>
<p>There are several ways to count the number of creeps of the required type. One of them is filtering <code>Game.creeps</code> with the help of the <code>_.filter</code> function and using the role in their memory. Let’s try to do that and bring the number of creeps into the console.</p>
</blockquote>
<p>有很多种方式让你数你需要的类型的<code>creeps</code>有多少个。最好用的就是在过滤器成员函数<code>filter</code>协助下的<code>Game.creeps</code>对象。在主模块中，我们通过过滤它们的<code>memory</code>来判断它们是否是适合的类型，同时，唔，数数。</p>
<p>可能用到的 API ：</p>
<blockquote>
<p>Game.creeps<br>
lodash.filter</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleUpgrader = require('role.upgrader');

module.exports.loop = function () {

    var harvesters = _.filter(Game.creeps, (creep) =&gt; creep.memory.role == 'harvester');
    console.log('Harvesters: ' + harvesters.length);

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
    }
}
</code></pre>
<blockquote>
<p>Let’s say we want to have at least two harvesters at any time. The easiest way to achieve this is to run <code>StructureSpawn.spawnCreep</code> each time we discover it’s less than this number. You may not define its name (it will be given automatically in this case), but don’t forget to define the needed role.</p>
</blockquote>
<p>我们现在同时需要两个<code>harvester</code>。最方便来保持这个状态的方式就是让主模块在每次发现<code>harvester</code>数量不够的时候执行<code>StructureSpawn.spawnCreep</code>。在这个方法的帮助下，我们甚至不需要给它们命名（我们能写出自动命名用的方法），只要别忘记定义角色行为就行。</p>
<blockquote>
<p>We may also add some new <code>RoomVisual</code> call in order to visualize what creep is being spawned.</p>
</blockquote>
<p>我们还能添加一些新的<code>RoomVisual</code>调用来可视化哪一种<code>creep</code>正在被生产出来。</p>
<p>这里可能帮到忙的 API :</p>
<blockquote>
<p>StructureSpawn.spawnCreep<br>
RoomVisual</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleUpgrader = require('role.upgrader');

module.exports.loop = function () {

    var harvesters = _.filter(Game.creeps, (creep) =&gt; creep.memory.role == 'harvester');
    console.log('Harvesters: ' + harvesters.length);

    if(harvesters.length &lt; 2) {
        var newName = 'Harvester' + Game.time;
        console.log('Spawning new harvester: ' + newName);
        Game.spawns['Spawn1'].spawnCreep([WORK,CARRY,MOVE], newName, 
            {memory: {role: 'harvester'}});        
    }
    
    if(Game.spawns['Spawn1'].spawning) { 
        var spawningCreep = Game.creeps[Game.spawns['Spawn1'].spawning.name];
        Game.spawns['Spawn1'].room.visual.text(
            '🛠️' + spawningCreep.memory.role,
            Game.spawns['Spawn1'].pos.x + 1, 
            Game.spawns['Spawn1'].pos.y, 
            {align: 'left', opacity: 0.8});
    }

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
    }
}
</code></pre>
<blockquote>
<p>Now let’s try to emulate a situation when one of our harvesters dies. You can now give the command suicide to the creep via the console or its properties panel on the right.</p>
</blockquote>
<p>我们现在模拟一下当我们的<code>harvesters</code>中的一位永远地离开我们的情况……嗯，用某个方法让它当场挂掉就行。</p>
<p>可能用到的 API ：</p>
<blockquote>
<p>Creep.suicide</p>
</blockquote>
<p>（有没有感到一种深深的恶意）</p>
<pre><code class="language-javascript">Game.creeps['Harvester1'].suicide()
</code></pre>
<blockquote>
<p>As you can see from the console, after we lacked one harvester, the spawn instantly started building a new one with a new name.</p>
</blockquote>
<p>从控制台中可以看到，每当我们缺乏<code>harvester</code>时，我们的<code>spawn</code>就会自动地造一个具备新名字的<code>harvester</code>出来。</p>
<blockquote>
<p>An important point here is that the memory of dead creeps is not erased but kept for later reuse. If you create creeps with random names each time it may lead to memory overflow, so you should clear it in the beginning of each tick (prior to the creep creation code).</p>
</blockquote>
<p>另外的一个重点，就是你的<code>creeps</code>凉的时候不会清空它所占用的内存空间。一个随机名字的<code>creep</code>挂了之后，可能会导致内存泄漏。为了应对这个情况，你需要修改主模块，在每个<code>tick</code>的开始时进行内存垃圾回收，它的优先级甚至高于生产建造新<code>creep</code>的指令。</p>
<p>Code:</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleUpgrader = require('role.upgrader');

module.exports.loop = function () {

    for(var name in Memory.creeps) {
        if(!Game.creeps[name]) {
            delete Memory.creeps[name];
            console.log('Clearing non-existing creep memory:', name);
        }
    }

    var harvesters = _.filter(Game.creeps, (creep) =&gt; creep.memory.role == 'harvester');
    console.log('Harvesters: ' + harvesters.length);

    if(harvesters.length &lt; 2) {
        var newName = 'Harvester' + Game.time;
        console.log('Spawning new harvester: ' + newName);
        Game.spawns['Spawn1'].spawnCreep([WORK,CARRY,MOVE], newName, 
            {memory: {role: 'harvester'}});
    }
    
    if(Game.spawns['Spawn1'].spawning) { 
        var spawningCreep = Game.creeps[Game.spawns['Spawn1'].spawning.name];
        Game.spawns['Spawn1'].room.visual.text(
            '🛠️' + spawningCreep.memory.role,
            Game.spawns['Spawn1'].pos.x + 1, 
            Game.spawns['Spawn1'].pos.y, 
            {align: 'left', opacity: 0.8});
    }

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
    }
}
</code></pre>
<blockquote>
<p>Now the memory of the deceased is relegated to oblivion which saves us resources.</p>
</blockquote>
<p>我很高兴你节省下了一点内存。<s>一直节省内存，你就能存下钱来买生发剂。</s></p>
<blockquote>
<p>Apart from creating new creeps after the death of old ones, there is another way to maintain the needed number of creeps: the method <code>StructureSpawn.renewCreep</code>. Creep aging is disabled in the Tutorial, so we recommend that you familiarize yourself with it on your own.</p>
</blockquote>
<p>实际上，除了让旧的<code>creep</code>老化死掉时创建新的<code>creep</code>，你还能使用<code>StructureSpawn.renewCreep</code>方法解决问题。老化在教程中被禁用，所以建议自行熟悉。</p>
<p>与之相关的 API：</p>
<blockquote>
<p>StructureSpawn.renewCreep</p>
</blockquote>
<h2 id="守卫你的房间">守卫你的房间</h2>
<blockquote>
<p>The world of Screeps is not the safest place. Other players may have claims on your territory. Besides, your room may be raided by neutral NPC creeps occasionally. So you ought to think about your colony defense in order to develop it successfully.</p>
</blockquote>
<p>Screeps中，玩家可以互相攻击，还会产生敌对NPC。所以，我们需要开发防御脚本。</p>
<blockquote>
<p>This hostile creep has come from the left entry and attacked your colony. It’s good that we have walls to restrain it temporarily. But they will fall sooner or later, so we need to deal with the problem.</p>
</blockquote>
<p>入侵者已经从左侧入口进入并已经在攻击你的领地。我们有墙可以防御，但是这些墙迟早会倒下。所以，我们应该积极应对这一问题。</p>
<blockquote>
<p>The surest way to fend off an attack is using the room Safe Mode. In safe mode, no other creep will be able to use any harmful methods in the room (but you’ll still be able to defend against strangers).</p>
</blockquote>
<p>目前最可靠的防御方式，是使用房间安全模式<code>room Safe Mode</code>。在安全模式时限内，敌人的所有有害方法都会被锁死。这是对于陌生来访者最好的防御方式。</p>
<blockquote>
<p>The safe mode is activated via the room controller which should have activations available to use. Let’s spend one activation to turn it on in our room.</p>
</blockquote>
<p>我们需要通过房间控制器才能打开房间安全模式。让我们试试。<s>(试试就逝世)</s></p>
<p>这个操作所用的方法涉及 API：</p>
<blockquote>
<p>StructureController.activateSafeMode</p>
</blockquote>
<p>这种即时性强的代码使用控制台来执行：</p>
<p>Code:</p>
<pre><code class="language-javascript">Game.spawns['Spawn1'].room.controller.activateSafeMode();
</code></pre>
<blockquote>
<p>As you can see, the enemy creep stopped attacking the wall – its harmful methods are blocked. We recommend that you activate safe mode when your defenses fail.</p>
</blockquote>
<p>可见，该敌对<code>Creep</code>停止攻击墙壁，一切有害行为均已锁定。我们建议你在防守失败时激活房间安全模式。</p>
<blockquote>
<p>Now let’s cleanse the room from unwanted guests.</p>
</blockquote>
<p>那么现在，让我们清除不受欢迎的入侵者。</p>
<blockquote>
<p>Towers are the easiest way to actively defend a room. They use energy and can be targeted at any creep in a room to attack or heal it. The effect depends on the distance between the tower and the target.</p>
</blockquote>
<p>塔是积极活跃防御房间的优秀方式。它们消耗能量，并以<code>Creep</code>为目标进行维护或攻击。效果取决于塔离目标的距离</p>
<blockquote>
<p>To start with, let’s lay a foundation for our new tower. You can set any place you wish inside the walls and place the construction site there with the help of the button “Construct” on the upper panel.</p>
</blockquote>
<p>首先，我们为建造新塔打好基础。你能够使用<code>Construct</code>视图在墙内任意位置建造一座塔。</p>
<p>API 调用如下：</p>
<blockquote>
<p>StructureTower<br>
Room.createConstructionSite</p>
</blockquote>
<p>Code:</p>
<pre><code class="language-javascript">Game.spawns['Spawn1'].room.createConstructionSite( 23, 22, STRUCTURE_TOWER );
</code></pre>
<blockquote>
<p>A tower uses energy, so let’s set the harvester role to bring energy to the tower along with other structures. To do this, you need to add the constant STRUCTURE_TOWER to the filter of structures your harvester is aimed at.</p>
</blockquote>
<p>塔消耗能源。所以，我们需要更改<code>Harvester</code>的模块，使该角色将能源带给塔及其他结构。</p>
<pre><code class="language-javascript">var roleHarvester = {

    /** @param {Creep} creep **/
    run: function(creep) {
	    if(creep.carry.energy &lt; creep.carryCapacity) {
            var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0], {visualizePathStyle: {stroke: '#ffaa00'}});
            }
        }
        else {
            var targets = creep.room.find(FIND_STRUCTURES, {
                    filter: (structure) =&gt; {
                        return (structure.structureType == STRUCTURE_EXTENSION ||
                                structure.structureType == STRUCTURE_SPAWN ||
                                structure.structureType == STRUCTURE_TOWER) &amp;&amp; structure.energy &lt; structure.energyCapacity;
                    }
            });
            if(targets.length &gt; 0) {
                if(creep.transfer(targets[0], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                    creep.moveTo(targets[0], {visualizePathStyle: {stroke: '#ffffff'}});
                }
            }
        }
	}
};

module.exports = roleHarvester;
</code></pre>
<blockquote>
<p>Excellent, your tower is ready to use!</p>
</blockquote>
<p>众所周知，塔消耗头发而产生某种效果……嗯。</p>
<blockquote>
<p>Like a creep, a tower has several similar methods: attack, heal, and repair. Each action spends 10 energy units. We need to use attack on the closest enemy creep upon its discovery. Remember that distance is vital: the effect can be several times stronger with the same energy cost!</p>
</blockquote>
<p>就像一个<code>Creep</code>，塔可以攻击、给<code>Creep</code>回复生命、维修建筑物。每一项方法的执行均消耗10单位能量。我们现在对它进行设定，使它攻击最近的敌人。记住，它的效果取决于离目标的距离！</p>
<blockquote>
<p>To get the tower object directly you can use its ID from the right panel and the method <code>Game.getObjectById</code>.</p>
</blockquote>
<p>我们可以通过右边的面板以及 API 方法<code>Game.getObjectById</code>来操作直接获取塔对象。</p>
<p>这回用到的 API 不少：</p>
<blockquote>
<p>Game.getObjectById<br>
RoomObject.pos<br>
RoomPosition.findClosestByRange<br>
StructureTower.attack</p>
</blockquote>
<p>这样修改主模块：</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleUpgrader = require('role.upgrader');
var roleBuilder = require('role.builder');

module.exports.loop = function () {

    var tower = Game.getObjectById('d629245dccf490c645352fb6');
    if(tower) {
        var closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
        if(closestHostile) {
            tower.attack(closestHostile);
        }
    }

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
        if(creep.memory.role == 'builder') {
            roleBuilder.run(creep);
        }
    }
}
</code></pre>
<p>可见，这次塔的 ID 为：<code>d629245dccf490c645352fb6</code>。</p>
<blockquote>
<p>The enemy creep is eliminated and our colony can breathe easy. However, the invader has damaged some walls during the brief attack. You’d better set up auto-repair.</p>
</blockquote>
<p>敌人已经被消灭，但是它留下的伤害还没有被磨灭。敌对目标攻击了你的墙，因此你需要维护它，以应对下一次入侵。实际上，实现一个自动修复是很好的解决方案。</p>
<blockquote>
<p>Damaged structures can be repaired by both creeps and towers. Let’s try to use a tower for that. We’ll need the method <code>repair</code>. You will also need the method <code>Room.find</code> and a filter to locate the damaged walls.</p>
</blockquote>
<p>受伤的结构，能够被<code>creeps</code>和<code>towers</code>修复。让我们试试我们这座塔的<code>repair</code>方法。在实际的实现过程中，我们使用<code>Room.find</code>方法配合过滤器找到墙上受到损伤的位置。</p>
<p>API：</p>
<blockquote>
<p>Room.find<br>
StructureTower.repair</p>
</blockquote>
<p>主模块代码：</p>
<pre><code class="language-javascript">var roleHarvester = require('role.harvester');
var roleUpgrader = require('role.upgrader');
var roleBuilder = require('role.builder');

module.exports.loop = function () {

    var tower = Game.getObjectById('d629245dccf490c645352fb6');
    if(tower) {
        var closestDamagedStructure = tower.pos.findClosestByRange(FIND_STRUCTURES, {
            filter: (structure) =&gt; structure.hits &lt; structure.hitsMax
        });
        if(closestDamagedStructure) {
            tower.repair(closestDamagedStructure);
        }

        var closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
        if(closestHostile) {
            tower.attack(closestHostile);
        }
    }

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
        if(creep.memory.role == 'harvester') {
            roleHarvester.run(creep);
        }
        if(creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
        if(creep.memory.role == 'builder') {
            roleBuilder.run(creep);
        }
    }
}
</code></pre>
<blockquote>
<p>All the damage from the attack has been repaired</p>
</blockquote>
<p>我们注意到了你发量见底了。</p>
<blockquote>
<p>Congratulations, you have completed the Tutorial! Now you have enough knowledge and code to start playing in the online mode. Choose your room, found a colony, and set out on your own quest for domination in the world of Screeps!</p>
</blockquote>
<p>所以教程结束了。恭喜你，你已经练成了进入秃头服务器的能力。选择你的房间，建立你的领地，跟我们一起脱发叭！</p>
<p>在这些地方，你能继续找到你们需要的东西：</p>
<blockquote>
<p>Documentation<br>
Community forums<br>
Slack chat</p>
</blockquote>
<blockquote>
<p>Have fun scripting!</p>
</blockquote>
<p>在脱发中寻找快乐！</p>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://malachiten.github.io/post/bi-ji-zui-xiao-sheng-cheng-shu-kruskal-suan-fa">
              <h3 class="post-title">
                下一篇：笔记 : 最小生成树 / Kruskal算法
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">夕焼けの中に吸い込まれて消えてった</div>
  <div class="social-container">
    
      
        <a href="https://github.com/MalachiteN" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
        <a href="https://www.zhihu.com/people/bao-chi-leng-jing-rev4/activities" target="_blank">
          <i class="fab fa-zhihu"></i>
        </a>
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> and <a herf="https://github.com/MalachiteN">MalachiteN</a> | <a class="rss" href="https://malachiten.github.io/atom.xml" target="_blank">RSS</a>
  <div>
    <span id="busuanzi_container_site_pv">
      本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
  </div>
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
